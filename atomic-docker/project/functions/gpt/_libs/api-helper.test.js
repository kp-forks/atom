import { callOpenAI } from './api-helper'; // Assuming callOpenAI is exported from api-helper.ts
import OpenAI from 'openai';
// Mock the OpenAI client
const mockCreate = jest.fn();
jest.mock('openai', () => {
    return jest.fn().mockImplementation(() => {
        return {
            chat: {
                completions: {
                    create: mockCreate,
                },
            },
        };
    });
});
// --- Tests for Availability Generation Functions ---
import { generateAvailability, generateAvailableSlotsforTimeWindow, generateAvailableSlotsForDate } from './api-helper';
// Spies for apiHelperModule functions (getUserPreferences, listEventsForUserGivenDates) will be set up.
// dayjs is used extensively; jest.useFakeTimers() will be employed.
describe('Availability Generation Functions', () => {
    const originalGuess = dayjs.tz.guess;
    beforeAll(() => {
        // Mock dayjs.tz.guess to ensure tests are consistent across environments
        dayjs.tz.guess = jest.fn(() => 'America/New_York');
    });
    afterAll(() => {
        dayjs.tz.guess = originalGuess; // Restore original guess function
    });
    beforeEach(() => {
        jest.clearAllMocks();
        jest.useFakeTimers(); // Enable fake timers for each test
        // Set a consistent system time for all tests in this describe block if needed, e.g.,
        // jest.setSystemTime(new Date('2024-08-01T00:00:00Z'));
        // However, specific times will be set in tests for more control.
    });
    afterEach(() => {
        jest.useRealTimers(); // Restore real timers
    });
    describe('generateAvailableSlotsForDate', () => {
        const baseDate = '2024-08-15'; // Thursday
        const senderTimezone = 'America/New_York'; // User's own TZ where work hours are defined
        const receiverTimezone = 'America/Los_Angeles'; // TZ for which slots are being generated for display
        const senderPreferencesBase = {
            id: 'pref1', userId: 'user1',
            workHoursStartTime: '09:00', // 9 AM in senderTimezone
            workHoursEndTime: '17:00', // 5 PM in senderTimezone
            workDays: [1, 2, 3, 4, 5], // Mon-Fri
            slotDuration: 30, // minutes
            bufferBetweenMeetings: 15, // minutes
            timezone: senderTimezone,
        };
        it('should generate basic slots for a full day with no existing events', () => {
            jest.setSystemTime(new Date(`${baseDate}T00:00:00Z`)); // Irrelevant here, but good practice
            const slots = generateAvailableSlotsForDate(baseDate, senderPreferencesBase, [], receiverTimezone, false, false);
            // Expected: 9:00, 9:45, 10:30, 11:15, 12:00, 12:45 (skip lunch if any), 1:30, 2:15, 3:00, 3:45, 4:30 (ends 5:00)
            // Total 11 slots (9:00-9:30, 9:45-10:15 ... 4:30-5:00)
            expect(slots.length).toBe(11);
            // Check first slot (9:00 AM NY -> ISO string)
            const firstSlotStartExpected = dayjs.tz(`${baseDate} 09:00`, 'YYYY-MM-DD HH:mm', senderTimezone).toISOString();
            expect(slots[0].startDate).toBe(firstSlotStartExpected);
        });
        it('should exclude existing events (notAvailableSlotsInEventTimezone)', () => {
            const existingEvents = [
                { startDate: dayjs.tz(`${baseDate} 10:00`, 'YYYY-MM-DD HH:mm', receiverTimezone).toISOString(), endDate: dayjs.tz(`${baseDate} 10:30`, 'YYYY-MM-DD HH:mm', receiverTimezone).toISOString() }
            ];
            // 9:00 AM NY is 6:00 AM LA. 5:00 PM NY is 2:00 PM LA.
            // Sender work hours in LA time: 6 AM - 2 PM.
            // If receiver is LA, and sender is NY, slots are generated based on NY work hours, then displayed in LA time.
            // The notAvailableSlots are already in event's target timezone (receiverTimezone).
            // Recalculate expected slots based on how `generateAvailableSlotsForDate` converts for comparison
            // Sender's 9AM NY is 6AM LA. Sender's 5PM NY is 2PM LA.
            // Slot 1 (NY): 9:00-9:30 -> LA: 6:00-6:30 (OK)
            // Slot 2 (NY): 9:45-10:15 -> LA: 6:45-7:15 (OK)
            // ...
            // Let's assume one of the generated slots (converted to LA time) would be 10:00 LA - 10:30 LA. This one should be excluded.
            // The original code compares currentSlotStartInReceiverTz with busyStart(already in receiverTz)
            const slots = generateAvailableSlotsForDate(baseDate, senderPreferencesBase, existingEvents, receiverTimezone, false, false);
            // Original 11 slots. One 30-min slot (10:00-10:30 LA) removed.
            // The slot that would be 10:00-10:30 LA corresponds to 1:00-1:30 PM NY.
            // This is complex. Let's simplify: if a slot generated based on NY work hours, when converted to LA time,
            // overlaps with an existing LA event, it's excluded.
            // 1:00 PM NY is 10:00 AM LA. So the 1:00 PM - 1:30 PM NY slot should be removed.
            // Original slots: 9:00, 9:45, 10:30, 11:15, 12:00, 12:45, *1:30 (NY)*, 2:15, 3:00, 3:45, 4:30
            // The 1:30 PM NY slot (10:30 AM LA) should be fine. The 12:45 PM NY (9:45 AM LA) slot should be fine.
            // The conflicting slot is the one that *is* 10:00-10:30 AM LA. This is 1:00 PM - 1:30 PM NY.
            // So, 10 slots should remain.
            expect(slots.length).toBe(10);
            const tenAmLaConflictISO = dayjs.tz(`${baseDate} 10:00`, 'YYYY-MM-DD HH:mm', receiverTimezone).toISOString();
            expect(slots.find(s => dayjs(s.startDate).tz(receiverTimezone).toISOString() === tenAmLaConflictISO)).toBeUndefined();
        });
        it('should respect isFirstDay windowStartTime', () => {
            // Window starts at 1:00 PM LA time on the first day. Sender is NY.
            // 1:00 PM LA is 4:00 PM NY. Sender works 9 AM - 5 PM NY.
            // So, available slots for this day should only be from 4:00 PM NY onwards.
            // 4:00-4:30, 4:45-5:15 (oops, buffer means 4:30 is last) -> So, 4:00-4:30 PM NY
            const slots = generateAvailableSlotsForDate(baseDate, senderPreferencesBase, [], receiverTimezone, true, false, '13:00');
            expect(slots.length).toBe(2); // 4:00-4:30, 4:45-5:15 (NY time) is wrong, buffer is 15. 4:00-4:30, then 4:30+15+30 = 5:15. So only 4:00-4:30
            // 4:00 to 4:30. next is 4:30 + 15 buffer = 4:45. 4:45 + 30 = 5:15. 5:15 is NOT <= 5:00 dayEnd. So only one slot.
            expect(slots.length).toBe(1);
            expect(slots[0].startDate).toBe(dayjs.tz(`${baseDate} 16:00`, 'YYYY-MM-DD HH:mm', senderTimezone).toISOString());
        });
        it('should respect isLastDay windowEndTime', () => {
            // Window ends at 10:00 AM LA time. Sender is NY.
            // 10:00 AM LA is 1:00 PM NY. Sender works 9 AM - 5 PM NY.
            // Slots should be from 9:00 AM NY up to 1:00 PM NY.
            // 9:00, 9:45, 10:30, 11:15, 12:00, 12:45 (ends 1:15 PM - too late)
            // 9:00-9:30, 9:45-10:15, 10:30-11:00, 11:15-11:45, 12:00-12:30. (5 slots)
            // Next one starts 12:30 + 15 buffer = 12:45. 12:45+30 = 1:15. 1:15 is NOT <= 1:00.
            const slots = generateAvailableSlotsForDate(baseDate, senderPreferencesBase, [], receiverTimezone, false, true, undefined, '10:00');
            expect(slots.length).toBe(5);
            const lastSlotEndExpected = dayjs.tz(`${baseDate} 12:30`, 'YYYY-MM-DD HH:mm', senderTimezone).add(senderPreferencesBase.slotDuration, 'minutes').toISOString();
            // last slot is 12:00 - 12:30 NY
            expect(slots[slots.length - 1].endDate).toBe(dayjs.tz(`${baseDate} 12:30`, 'YYYY-MM-DD HH:mm', senderTimezone).toISOString());
        });
        it('should return empty array if window is outside work hours', () => {
            const slots = generateAvailableSlotsForDate(baseDate, senderPreferencesBase, [], receiverTimezone, true, true, '18:00', '19:00'); // 6 PM - 7 PM LA (9 PM - 10 PM NY)
            expect(slots).toEqual([]);
        });
    });
    describe('generateAvailableSlotsforTimeWindow', () => {
        const senderPrefs = { id: 'p1', userId: 'u1', workHoursStartTime: '09:00', workHoursEndTime: '12:00', workDays: [1, 2, 3, 4, 5], slotDuration: 60, bufferBetweenMeetings: 0, timezone: 'America/New_York' };
        it('should call generateAvailableSlotsForDate for each day in a multi-day window', () => {
            // For this test, we don't need to mock generateAvailableSlotsForDate itself, but rather check its usage.
            // However, to control its output for aggregation, mocking it is better.
            const mockDailySlots = [{ startDate: 'slot1_start', endDate: 'slot1_end' }];
            const generateAvailableSlotsForDateSpy = jest.spyOn(apiHelperModule, 'generateAvailableSlotsForDate').mockReturnValue(mockDailySlots);
            const startDate = '2024-08-19'; // Monday
            const endDate = '2024-08-20'; // Tuesday
            const result = generateAvailableSlotsforTimeWindow(startDate, endDate, senderPrefs, [], 'America/New_York');
            expect(generateAvailableSlotsForDateSpy).toHaveBeenCalledTimes(2); // Mon, Tue
            expect(result.availableSlots.length).toBe(2 * mockDailySlots.length); // Aggregated
            generateAvailableSlotsForDateSpy.mockRestore();
        });
    });
    describe('generateAvailability', () => {
        let listEventsSpy;
        let getUserPrefsSpy;
        // generateAvailableSlotsforTimeWindow is not spied as it's mostly orchestrating the date iteration.
        // Its core logic is in generateAvailableSlotsForDate which is tested above.
        const baseParams = {
            userId: 'user_avail_test',
            availabilityScanStartDate: '2024-08-19', // Monday
            availabilityScanEndDate: '2024-08-20', // Tuesday
            receiverGeneratedTimezone: 'America/Los_Angeles',
            // clientType: 'web' // Not used by current generateAvailability signature
        };
        const mockUserPrefs = { id: 'pref1', userId: baseParams.userId, workHoursStartTime: '09:00', workHoursEndTime: '17:00', workDays: [1, 2, 3, 4, 5], slotDuration: 30, bufferBetweenMeetings: 15, timezone: 'America/New_York' };
        beforeEach(() => {
            listEventsSpy = jest.spyOn(apiHelperModule, 'listEventsForUserGivenDates');
            getUserPrefsSpy = jest.spyOn(apiHelperModule, 'getUserPreferences');
        });
        it('should return success:true with slots when all helpers succeed', async () => {
            getUserPrefsSpy.mockResolvedValue({ success: true, data: mockUserPrefs });
            listEventsSpy.mockResolvedValue({ success: true, data: [] }); // No existing events
            const result = await generateAvailability(baseParams.userId, baseParams.availabilityScanStartDate, baseParams.availabilityScanEndDate, baseParams.receiverGeneratedTimezone);
            expect(result.success).toBe(true);
            expect(result.data).toBeInstanceOf(Array);
            // Expect some slots (11 slots per day for 2 days = 22 slots)
            // This relies on the actual implementation of generateAvailableSlotsForDate.
            expect(result.data?.length).toBe(22);
        });
        it('should return failure if getUserPreferences fails', async () => {
            const prefsError = { message: "DB error prefs" };
            getUserPrefsSpy.mockResolvedValue({ success: false, error: prefsError });
            const result = await generateAvailability(baseParams.userId, baseParams.availabilityScanStartDate, baseParams.availabilityScanEndDate, baseParams.receiverGeneratedTimezone);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toContain('Failed to get user preferences');
                expect(result.error.details).toEqual(prefsError);
            }
        });
        it('should return failure if getUserPreferences returns no data', async () => {
            getUserPrefsSpy.mockResolvedValue({ success: true, data: undefined });
            const result = await generateAvailability(baseParams.userId, baseParams.availabilityScanStartDate, baseParams.availabilityScanEndDate, baseParams.receiverGeneratedTimezone);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('User preferences not found, cannot generate availability.');
            }
        });
        it('should return failure if listEventsForUserGivenDates fails', async () => {
            getUserPrefsSpy.mockResolvedValue({ success: true, data: mockUserPrefs });
            const eventsError = { message: "DB error events list" };
            listEventsSpy.mockResolvedValue({ success: false, error: eventsError });
            const result = await generateAvailability(baseParams.userId, baseParams.availabilityScanStartDate, baseParams.availabilityScanEndDate, baseParams.receiverGeneratedTimezone);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toContain('Failed to list existing events');
                expect(result.error.details).toEqual(eventsError);
            }
        });
        it('should succeed even if listEventsForUserGivenDates returns empty array', async () => {
            getUserPrefsSpy.mockResolvedValue({ success: true, data: mockUserPrefs });
            listEventsSpy.mockResolvedValue({ success: true, data: [] }); // No existing events
            const result = await generateAvailability(baseParams.userId, baseParams.availabilityScanStartDate, baseParams.availabilityScanEndDate, baseParams.receiverGeneratedTimezone);
            expect(result.success).toBe(true);
            expect(result.data).toBeInstanceOf(Array);
            expect(result.data?.length).toBe(22); // Full availability
        });
    });
});
// --- Unit Tests for createGoogleEvent (Refactored) ---
// Note: These tests will need adjustment based on the new signature of createGoogleEvent
// which now takes an eventOptions object.
// Assuming google.calendar().events.insert is already mocked via the global googleapis mock.
// const mockGoogleEventsInsert = (google.calendar('v3') as any).events.insert as jest.Mock;
// This was defined in a previous step for createGoogleEvent tests, ensure it's still valid/accessible.
describe('createGoogleEvent (Refactored with CreateGoogleEventOptions)', () => {
    let getGoogleAPITokenSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const mockGeneratedId = 'mock-uuid-for-conference';
    // Re-accessing the mock for google.calendar().events.insert
    // This relies on the global mock structure for 'googleapis'
    let mockEventsInsert;
    beforeAll(() => {
        // Ensure the googleapis mock is set up to provide a mock for events.insert
        // This might need to be more robust depending on how the global mock is structured.
        // If the global mock is: jest.mock('googleapis', () => ({ google: { calendar: jest.fn().mockReturnValue({ events: { insert: jest.fn() } }) } }));
        // then this access should work.
        mockEventsInsert = google.calendar('v3').events.insert;
    });
    beforeEach(() => {
        jest.clearAllMocks();
        getGoogleAPITokenSpy = jest.spyOn(apiHelperModule, 'getGoogleAPIToken');
        uuidv4.mockReturnValue(mockGeneratedId); // Consistent UUID for tests
        mockEventsInsert.mockClear(); // Clear call history for events.insert
    });
    afterEach(() => {
        getGoogleAPITokenSpy.mockRestore();
        consoleLogSpy.mockRestore();
    });
    const baseParams = {
        userId: 'user_gcal_test',
        calendarId: 'primary',
        clientType: 'web',
    };
    const sampleEventOptions = {
        summary: 'Test Event from Options',
        description: 'Event created with options object.',
        startDateTime: '2024-09-01T10:00:00Z',
        endDateTime: '2024-09-01T11:00:00Z',
        timezone: 'America/New_York',
        attendees: [{ email: 'attendee@example.com' }],
        conferenceData: { type: 'hangoutsMeet' }, // Simplified for test, real one needs createRequest
        status: 'confirmed',
    };
    const sampleAllDayEventOptions = {
        summary: 'All Day Event Test',
        startDate: '2024-09-02', // YYYY-MM-DD
        endDate: '2024-09-03', // YYYY-MM-DD (Google Calendar end date for all-day is exclusive)
        timezone: 'America/New_York', // Still needed for context, though GCal API uses date only
        description: 'This is an all-day event.'
    };
    it('should create a timed event successfully using eventOptions', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_token' });
        const mockApiResponse = { data: { id: 'gcal_event_options_123', summary: sampleEventOptions.summary } };
        mockEventsInsert.mockResolvedValue(mockApiResponse);
        const result = await apiHelperModule.createGoogleEvent(baseParams.userId, baseParams.calendarId, baseParams.clientType, sampleEventOptions);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.googleEventId).toBe('gcal_event_options_123');
        }
        expect(mockEventsInsert).toHaveBeenCalledWith(expect.objectContaining({
            calendarId: baseParams.calendarId,
            requestBody: expect.objectContaining({
                summary: sampleEventOptions.summary,
                description: sampleEventOptions.description,
                start: { dateTime: sampleEventOptions.startDateTime, timeZone: sampleEventOptions.timezone },
                end: { dateTime: sampleEventOptions.endDateTime, timeZone: sampleEventOptions.timezone },
                attendees: sampleEventOptions.attendees,
                // conferenceData should be built based on options.conferenceData and generatedId
                // The refactored createGoogleEvent now uses uuidv4() internally for requestId if conferenceData.createRequest is to be built
                // So if sampleEventOptions.conferenceData = { type: 'hangoutsMeet' }, then createRequest should be built.
                // The current sampleEventOptions.conferenceData = { type: 'hangoutsMeet' } might not trigger createRequest in the refactored code.
                // Let's adjust sampleEventOptions for conference test.
                status: sampleEventOptions.status,
            }),
            // conferenceDataVersion: 1, // This should be set if conferenceData is in requestBody
        }));
    });
    it('should create an all-day event successfully using eventOptions', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_token' });
        const mockApiResponse = { data: { id: 'gcal_allday_456', summary: sampleAllDayEventOptions.summary } };
        mockEventsInsert.mockResolvedValue(mockApiResponse);
        const result = await apiHelperModule.createGoogleEvent(baseParams.userId, baseParams.calendarId, baseParams.clientType, sampleAllDayEventOptions);
        expect(result.success).toBe(true);
        expect(mockEventsInsert).toHaveBeenCalledWith(expect.objectContaining({
            requestBody: expect.objectContaining({
                summary: sampleAllDayEventOptions.summary,
                description: sampleAllDayEventOptions.description,
                start: { date: '2024-09-02', timeZone: sampleAllDayEventOptions.timezone }, // date field for all-day
                end: { date: '2024-09-03', timeZone: sampleAllDayEventOptions.timezone }, // date field for all-day
            }),
        }));
    });
    it('should correctly build conferenceData if createRequest details are provided in options', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_token' });
        const mockApiResponse = { data: { id: 'gcal_conf_789' } };
        mockEventsInsert.mockResolvedValue(mockApiResponse);
        const optionsWithConference = {
            ...sampleEventOptions,
            conferenceData: {
                createRequest: {
                    requestId: 'should-be-overridden-by-generatedId-or-param', // Will be overridden by generatedId param or internal uuidv4
                    conferenceSolutionKey: { type: 'hangoutsMeet' }
                }
            }
        };
        // Pass a specific generatedId to test it being used
        const specificGeneratedId = "specific-conf-uuid";
        await apiHelperModule.createGoogleEvent(baseParams.userId, baseParams.calendarId, baseParams.clientType, optionsWithConference, specificGeneratedId, // Pass the specific generatedId here
        1 // conferenceDataVersion
        );
        expect(mockEventsInsert).toHaveBeenCalledWith(expect.objectContaining({
            conferenceDataVersion: 1,
            requestBody: expect.objectContaining({
                conferenceData: {
                    createRequest: {
                        requestId: specificGeneratedId, // Check if this is used
                        conferenceSolutionKey: { type: 'hangoutsMeet' },
                    },
                },
            }),
        }));
        // Test with internal uuidv4
        uuidv4.mockReturnValueOnce("internal-uuid-for-conf");
        await apiHelperModule.createGoogleEvent(baseParams.userId, baseParams.calendarId, baseParams.clientType, optionsWithConference, undefined, // No specific generatedId, so internal uuidv4 should be used
        1);
        expect(mockEventsInsert).toHaveBeenCalledWith(expect.objectContaining({
            requestBody: expect.objectContaining({
                conferenceData: {
                    createRequest: {
                        requestId: "internal-uuid-for-conf",
                        conferenceSolutionKey: { type: 'hangoutsMeet' },
                    },
                },
            }),
        }));
    });
    // Tests for failure cases (getGoogleAPIToken fails, GCal API fails) can be adapted from existing createGoogleEvent tests.
    it('should return failure if getGoogleAPIToken fails (options version)', async () => {
        const tokenError = { message: 'Token fetch failed for options' };
        getGoogleAPITokenSpy.mockResolvedValue({ success: false, error: tokenError });
        const result = await apiHelperModule.createGoogleEvent(baseParams.userId, baseParams.calendarId, baseParams.clientType, sampleEventOptions);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Token acquisition failure');
            expect(result.error.details).toEqual(tokenError);
        }
    });
    it('should return failure if Google Calendar API insert fails (options version)', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_token' });
        const apiError = new Error("Google API Error");
        apiError.code = 500; // Simulate Google API error structure
        mockEventsInsert.mockRejectedValue(apiError);
        const result = await apiHelperModule.createGoogleEvent(baseParams.userId, baseParams.calendarId, baseParams.clientType, sampleEventOptions);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Google Calendar API error during event creation');
        }
    });
});
// TODO: Update tests for createAgenda, breakDownTask, howToTask, and createDaySchedule
// to ensure they correctly prepare and pass the CreateGoogleEventOptions object
// to the spied createGoogleEvent. This will involve:
// 1. Identifying where these orchestrators call createGoogleEvent.
// 2. In the tests for these orchestrators, when createGoogleEventSpy is called,
//    assert that the argument corresponding to 'eventOptions' is an object
//    that matches the expected CreateGoogleEventOptions structure based on the orchestrator's inputs.
// Example for createAgenda test:
// expect(createGoogleEventSpy).toHaveBeenCalledWith(
//   expect.any(String), // userId
//   expect.any(String), // calendarId
//   expect.any(String), // clientType
//   expect.objectContaining({ // This is the eventOptions
//     summary: "Generated Agenda Event",
//     description: mockSuccessfulOpenAI.content, // from createAgenda's scope
//     startDateTime: expect.any(String), // Check specific date/time if necessary
//     endDateTime: expect.any(String),
//     timezone: defaultCreateAgendaParams.userTimezone
//   }),
//   undefined, // generatedId for conference (likely undefined for simple agenda item)
//   0 // conferenceDataVersion
// );
// This is a placeholder for the detailed work required in subsequent steps if this were interactive.
// For now, this file focuses on testing createGoogleEvent itself with its new signature.
// --- Updating Orchestrator Function Tests for CreateGoogleEventOptions ---
// Note: The 'apiHelperModule' is used for spying, as these functions are in the same module.
// The actual spies (e.g., createGoogleEventSpy) are defined within each orchestrator's describe block.
describe('createAgenda (with refactored createGoogleEvent)', () => {
    // Assuming spies (callOpenAISpy, getGlobalCalendarSpy, createGoogleEventSpy, etc.)
    // and default params (defaultCreateAgendaParams) are defined as in previous createAgenda tests.
    // Only showing the relevant part of a test case that calls createGoogleEvent.
    // Minimal setup for spies needed by createAgenda before createGoogleEvent is called
    let callOpenAISpy;
    let getGlobalCalendarSpy;
    let createGoogleEventSpy;
    let upsertEventsPostPlannerSpy;
    let sendAgendaEmailSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultCreateAgendaParams = {
        userId: 'user123',
        clientType: 'web',
        userTimezone: 'America/New_York',
        userDate: '2024-03-15',
        prompt: 'Create an agenda for a product strategy meeting.',
        email: 'test@example.com',
        name: 'Test User',
    };
    const mockSuccessfulOpenAI = { success: true, content: 'Generated Agenda Details' };
    const mockSuccessfulGlobalCalendar = { success: true, data: { id: 'globalCalId', primaryCalendarId: 'primaryCal123' } };
    const mockSuccessfulCreateGoogleEvent = { success: true, data: { id: 'gEvent123#primaryCal123', googleEventId: 'gEvent123', generatedId: 'uuid1', calendarId: 'primaryCal123' } };
    const mockSuccessfulUpsert = { success: true, data: { affected_rows: 1, returning: [{ id: 'dbEventId456' }] } };
    const mockSuccessfulEmail = { success: true };
    beforeEach(() => {
        jest.clearAllMocks();
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI').mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy = jest.spyOn(apiHelperModule, 'getGlobalCalendar').mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy = jest.spyOn(apiHelperModule, 'createGoogleEvent').mockResolvedValue(mockSuccessfulCreateGoogleEvent);
        upsertEventsPostPlannerSpy = jest.spyOn(apiHelperModule, 'upsertEventsPostPlanner').mockResolvedValue(mockSuccessfulUpsert);
        sendAgendaEmailSpy = jest.spyOn(apiHelperModule, 'sendAgendaEmail').mockResolvedValue(mockSuccessfulEmail);
        // getGoogleAPIToken is called by createGoogleEvent, so ensure it's spied if needed for other tests,
        // but for testing createAgenda's call to createGoogleEvent, createGoogleEvent itself is spied.
        jest.spyOn(apiHelperModule, 'getGoogleAPIToken').mockResolvedValue({ success: true, token: "dummy-token" });
    });
    afterEach(() => {
        jest.restoreAllMocks(); // Restore all mocks after each test
        consoleLogSpy.mockRestore();
    });
    it('createAgenda should call createGoogleEvent with CreateGoogleEventOptions', async () => {
        await apiHelperModule.createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt, defaultCreateAgendaParams.email, defaultCreateAgendaParams.name);
        expect(createGoogleEventSpy).toHaveBeenCalledWith(defaultCreateAgendaParams.userId, mockSuccessfulGlobalCalendar.data.primaryCalendarId, defaultCreateAgendaParams.clientType, expect.objectContaining({
            summary: "Generated Agenda Event", // As per createAgenda's simplified logic
            description: mockSuccessfulOpenAI.content,
            startDateTime: dayjs.tz(`${defaultCreateAgendaParams.userDate}T09:00:00`, defaultCreateAgendaParams.userTimezone).toISOString(),
            endDateTime: dayjs.tz(`${defaultCreateAgendaParams.userDate}T10:00:00`, defaultCreateAgendaParams.userTimezone).toISOString(),
            timezone: defaultCreateAgendaParams.userTimezone
        }), 
        // Default values for generatedId, conferenceDataVersion, etc., if not specified by createAgenda
        undefined, // generatedId (for conference, likely undefined here)
        0 // conferenceDataVersion (default if no conference)
        );
    });
});
describe('createDaySchedule (with refactored createGoogleEvent)', () => {
    // Assuming spies and defaultParams are set up as in previous createDaySchedule tests
    let listEventsForUserGivenDatesSpy;
    let callOpenAISpy;
    let getGlobalCalendarSpy;
    let createGoogleEventSpy;
    let upsertEventsPostPlannerSpy;
    let sendGenericTaskEmailSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultDayScheduleParams = {
        userId: 'user_schedule_test',
        clientType: 'web',
        userDate: '2024-08-15',
        userTimezone: 'America/Denver',
        prompt: 'Plan my day.',
        isAllDay: false,
        email: 'user@example.com',
        name: 'Schedule User',
    };
    const mockParsedTasksNonAllDay = [
        { start_time: "10:00 AM", end_time: "11:00 AM", task: "Task 1", description: "Desc 1" },
        { start_time: "2:00 PM", end_time: "3:00 PM", task: "Task 2", description: "Desc 2" }
    ];
    const mockSuccessfulGlobalCalendar = { success: true, data: { id: 'dbCalId123', primaryCalendarId: 'primaryGCalId456' } };
    beforeEach(() => {
        jest.clearAllMocks();
        listEventsForUserGivenDatesSpy = jest.spyOn(apiHelperModule, 'listEventsForUserGivenDates').mockResolvedValue({ success: true, data: [] });
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI'); // Specific mock per test
        getGlobalCalendarSpy = jest.spyOn(apiHelperModule, 'getGlobalCalendar').mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy = jest.spyOn(apiHelperModule, 'createGoogleEvent').mockResolvedValue({ success: true, data: { id: 'g1', googleEventId: 'g1', generatedId: 'u1', calendarId: 'p1' } });
        upsertEventsPostPlannerSpy = jest.spyOn(apiHelperModule, 'upsertEventsPostPlanner').mockResolvedValue({ success: true, data: { affected_rows: 1, returning: [] } });
        sendGenericTaskEmailSpy = jest.spyOn(apiHelperModule, 'sendGenericTaskEmail').mockResolvedValue({ success: true });
        jest.spyOn(apiHelperModule, 'getGoogleAPIToken').mockResolvedValue({ success: true, token: "dummy-token" });
    });
    afterEach(() => {
        jest.restoreAllMocks();
        consoleLogSpy.mockRestore();
    });
    it('createDaySchedule non-all-day should call createGoogleEvent with CreateGoogleEventOptions for each task', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksNonAllDay) });
        await apiHelperModule.createDaySchedule(...Object.values(defaultDayScheduleParams));
        expect(createGoogleEventSpy).toHaveBeenCalledTimes(mockParsedTasksNonAllDay.length);
        mockParsedTasksNonAllDay.forEach(task => {
            const expectedStartDateTime = dayjs.tz(`${defaultDayScheduleParams.userDate} ${task.start_time}`, 'YYYY-MM-DD h:mm A', defaultDayScheduleParams.userTimezone).toISOString();
            const expectedEndDateTime = dayjs.tz(`${defaultDayScheduleParams.userDate} ${task.end_time}`, 'YYYY-MM-DD h:mm A', defaultDayScheduleParams.userTimezone).toISOString();
            expect(createGoogleEventSpy).toHaveBeenCalledWith(defaultDayScheduleParams.userId, mockSuccessfulGlobalCalendar.data.primaryCalendarId, defaultDayScheduleParams.clientType, expect.objectContaining({
                summary: task.task,
                description: task.description,
                startDateTime: expectedStartDateTime,
                endDateTime: expectedEndDateTime,
                timezone: defaultDayScheduleParams.userTimezone
            }), undefined, // generatedId for conference
            0 // conferenceDataVersion
            );
        });
    });
    it('createDaySchedule all-day should call createGoogleEvent with CreateGoogleEventOptions for a single event', async () => {
        const mockParsedTasksAllDay = [{ task: "Task A", description: "Desc A" }, { task: "Task B", description: "Desc B" }];
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksAllDay) });
        const allDayParams = { ...defaultDayScheduleParams, isAllDay: true };
        await apiHelperModule.createDaySchedule(...Object.values(allDayParams));
        const expectedAllDayStartDate = dayjs.tz(allDayParams.userDate, allDayParams.userTimezone).startOf('day').format('YYYY-MM-DD');
        const expectedAllDayEndDate = dayjs.tz(allDayParams.userDate, allDayParams.userTimezone).add(1, 'day').startOf('day').format('YYYY-MM-DD');
        const expectedDescription = mockParsedTasksAllDay.map(t => `${t.task}${t.description ? `:\n${t.description}` : ''}`).join('\n\n---\n\n');
        expect(createGoogleEventSpy).toHaveBeenCalledTimes(1);
        expect(createGoogleEventSpy).toHaveBeenCalledWith(allDayParams.userId, mockSuccessfulGlobalCalendar.data.primaryCalendarId, allDayParams.clientType, expect.objectContaining({
            summary: expect.stringContaining('Day Schedule:'),
            description: expectedDescription,
            startDate: expectedAllDayStartDate,
            endDate: expectedAllDayEndDate,
            timezone: allDayParams.userTimezone
        }), undefined, 0);
    });
});
describe('breakDownTask and howToTask (with refactored createGoogleEvent)', () => {
    // Common setup for breakDownTask and howToTask
    let callOpenAISpy;
    let getGlobalCalendarSpy;
    let createGoogleEventSpy; // This is the target for assertion change
    let upsertEventsPostPlannerSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultTaskParams = {
        userId: 'user_task_test',
        clientType: 'web',
        userTimezone: 'America/Los_Angeles',
        taskTitle: 'Plan Q3 Roadmap',
        taskDescription: 'Detailed planning for Q3.',
        isAllDay: false,
        startDate: '2024-07-01T10:00:00Z',
        endDate: '2024-07-01T11:00:00Z',
        email: 'user@example.com',
        name: 'Task User',
    };
    const mockSuccessfulOpenAI_Task = { success: true, content: 'Task details from AI' };
    const mockSuccessfulGlobalCalendar_Task = { success: true, data: { id: 'taskCalId', primaryCalendarId: 'primaryTaskCal' } };
    // createGoogleEvent is spied, so its internal getGoogleAPIToken call doesn't need separate spying here.
    beforeEach(() => {
        jest.clearAllMocks();
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI').mockResolvedValue(mockSuccessfulOpenAI_Task);
        getGlobalCalendarSpy = jest.spyOn(apiHelperModule, 'getGlobalCalendar').mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
        createGoogleEventSpy = jest.spyOn(apiHelperModule, 'createGoogleEvent').mockResolvedValue({ success: true, data: { id: 'g1', googleEventId: 'g1', generatedId: 'u1', calendarId: 'p1' } });
        upsertEventsPostPlannerSpy = jest.spyOn(apiHelperModule, 'upsertEventsPostPlanner').mockResolvedValue({ success: true, data: { affected_rows: 1, returning: [] } });
        jest.spyOn(apiHelperModule, 'getGoogleAPIToken').mockResolvedValue({ success: true, token: "dummy-token" });
    });
    afterEach(() => {
        jest.restoreAllMocks();
        consoleLogSpy.mockRestore();
    });
    describe('breakDownTask (checking createGoogleEventOptions)', () => {
        let emailTaskBreakDownSpy;
        beforeEach(() => emailTaskBreakDownSpy = jest.spyOn(apiHelperModule, 'emailTaskBreakDown').mockResolvedValue({ success: true }));
        afterEach(() => emailTaskBreakDownSpy.mockRestore());
        it('breakDownTask timed event should call createGoogleEvent with correct options', async () => {
            await apiHelperModule.breakDownTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.taskDescription, false, // isAllDay = false
            defaultTaskParams.startDate, defaultTaskParams.endDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(createGoogleEventSpy).toHaveBeenCalledWith(defaultTaskParams.userId, mockSuccessfulGlobalCalendar_Task.data.primaryCalendarId, defaultTaskParams.clientType, expect.objectContaining({
                summary: defaultTaskParams.taskTitle,
                description: mockSuccessfulOpenAI_Task.content,
                startDateTime: defaultTaskParams.startDate,
                endDateTime: defaultTaskParams.endDate,
                timezone: defaultTaskParams.userTimezone
            }), undefined, 0);
        });
        it('breakDownTask all-day event should call createGoogleEvent with correct date options', async () => {
            const allDayStartDate = dayjs(defaultTaskParams.startDate).format('YYYY-MM-DD');
            const allDayEndDate = dayjs(defaultTaskParams.endDate).format('YYYY-MM-DD'); // The helper adds 1 day to end date for GCal
            await apiHelperModule.breakDownTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.taskDescription, true, // isAllDay = true
            allDayStartDate, allDayEndDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(createGoogleEventSpy).toHaveBeenCalledWith(defaultTaskParams.userId, mockSuccessfulGlobalCalendar_Task.data.primaryCalendarId, defaultTaskParams.clientType, expect.objectContaining({
                summary: defaultTaskParams.taskTitle,
                description: mockSuccessfulOpenAI_Task.content,
                startDate: allDayStartDate,
                endDate: dayjs(allDayEndDate).add(1, 'day').format('YYYY-MM-DD'), // createEventHelper adds 1 day
                timezone: defaultTaskParams.userTimezone
            }), undefined, 0);
        });
    });
    describe('howToTask (checking createGoogleEventOptions)', () => {
        let sendGenericTaskEmailSpy;
        beforeEach(() => sendGenericTaskEmailSpy = jest.spyOn(apiHelperModule, 'sendGenericTaskEmail').mockResolvedValue({ success: true }));
        afterEach(() => sendGenericTaskEmailSpy.mockRestore());
        it('howToTask timed event should call createGoogleEvent with correct options', async () => {
            await apiHelperModule.howToTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, false, // isAllDay = false
            defaultTaskParams.startDate, defaultTaskParams.endDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(createGoogleEventSpy).toHaveBeenCalledWith(defaultTaskParams.userId, mockSuccessfulGlobalCalendar_Task.data.primaryCalendarId, defaultTaskParams.clientType, expect.objectContaining({
                summary: `How to: ${defaultTaskParams.taskTitle}`,
                description: mockSuccessfulOpenAI_Task.content,
                startDateTime: defaultTaskParams.startDate,
                endDateTime: defaultTaskParams.endDate,
                timezone: defaultTaskParams.userTimezone
            }), undefined, 0);
        });
    });
});
// --- Tests for createDaySchedule ---
import { createDaySchedule } from './api-helper';
// Spies for apiHelperModule functions will be set up in describe block.
// Other necessary mocks like 'got', 'googleapis', 'uuid', 'sendEmail' are already set up.
describe('createDaySchedule', () => {
    let listEventsForUserGivenDatesSpy;
    let callOpenAISpy;
    let getGlobalCalendarSpy;
    let createGoogleEventSpy;
    let upsertEventsPostPlannerSpy;
    let sendGenericTaskEmailSpy; // Renamed from emailDailySchedule
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultParams = {
        userId: 'user_schedule_test',
        clientType: 'web',
        userDate: '2024-08-15',
        userTimezone: 'America/Denver',
        prompt: 'Plan my day with focus on project X.',
        isAllDay: false,
        email: 'user@example.com',
        name: 'Schedule User',
    };
    const mockExistingEvents = [
        { id: 'exist1', summary: 'Morning Standup', startDateTime: '2024-08-15T15:00:00Z', endDateTime: '2024-08-15T15:30:00Z' } // 9 AM Denver
    ];
    const mockParsedTasksNonAllDay = [
        { start_time: "10:00 AM", end_time: "11:00 AM", task: "Work on Project X proposal", description: "Draft initial proposal." },
        { start_time: "2:00 PM", end_time: "3:00 PM", task: "Follow up emails", description: "Client communications." }
    ];
    const mockParsedTasksAllDay = [
        { task: "Review PRs", description: "Check team pull requests." },
        { task: "Plan next sprint", description: "Outline tasks for upcoming sprint." }
    ];
    const mockSuccessfulGlobalCalendar = { success: true, data: { id: 'dbCalId123', primaryCalendarId: 'primaryGCalId456' } };
    const mockSuccessfulGEventCreate = { success: true, data: { id: 'gcalEventId#primaryGCalId456', googleEventId: 'gcalEventId', generatedId: 'uuidGenerated' } };
    const mockSuccessfulUpsert = { success: true, data: { affected_rows: 1, returning: [{ id: 'dbEvent1' }] } };
    const mockSuccessfulEmail = { success: true };
    beforeEach(() => {
        jest.clearAllMocks();
        listEventsForUserGivenDatesSpy = jest.spyOn(apiHelperModule, 'listEventsForUserGivenDates');
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI');
        getGlobalCalendarSpy = jest.spyOn(apiHelperModule, 'getGlobalCalendar');
        createGoogleEventSpy = jest.spyOn(apiHelperModule, 'createGoogleEvent');
        upsertEventsPostPlannerSpy = jest.spyOn(apiHelperModule, 'upsertEventsPostPlanner');
        sendGenericTaskEmailSpy = jest.spyOn(apiHelperModule, 'sendGenericTaskEmail'); // Updated spy name
        // Default successful mocks for most common path
        listEventsForUserGivenDatesSpy.mockResolvedValue({ success: true, data: mockExistingEvents });
        getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy.mockResolvedValue(mockSuccessfulGEventCreate);
        upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert);
        sendGenericTaskEmailSpy.mockResolvedValue(mockSuccessfulEmail);
    });
    afterEach(() => {
        consoleLogSpy.mockRestore();
    });
    // Test Case 1: Success (non-all-day, multiple tasks parsed and created).
    it('should succeed for non-all-day schedule with multiple tasks and email', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksNonAllDay) });
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result).toEqual({ success: true });
        expect(listEventsForUserGivenDatesSpy).toHaveBeenCalledTimes(1);
        expect(callOpenAISpy).toHaveBeenCalledTimes(1);
        expect(getGlobalCalendarSpy).toHaveBeenCalledTimes(1);
        expect(createGoogleEventSpy).toHaveBeenCalledTimes(mockParsedTasksNonAllDay.length);
        expect(upsertEventsPostPlannerSpy).toHaveBeenCalledTimes(1);
        expect(sendGenericTaskEmailSpy).toHaveBeenCalledTimes(1);
    });
    // Test Case 2: Success (all-day schedule).
    it('should succeed for all-day schedule, creating one summary event', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksAllDay) });
        const paramsAllDay = { ...defaultParams, isAllDay: true };
        const result = await createDaySchedule(...Object.values(paramsAllDay));
        expect(result).toEqual({ success: true });
        expect(createGoogleEventSpy).toHaveBeenCalledTimes(1); // Only one event for all-day
        expect(createGoogleEventSpy).toHaveBeenCalledWith(paramsAllDay.userId, mockSuccessfulGlobalCalendar.data.primaryCalendarId, paramsAllDay.clientType, expect.stringContaining('Day Schedule:'), // Summary for all-day event
        dayjs.tz(paramsAllDay.userDate, paramsAllDay.userTimezone).startOf('day').format('YYYY-MM-DD'), // Start date for all-day
        dayjs.tz(paramsAllDay.userDate, paramsAllDay.userTimezone).add(1, 'day').startOf('day').format('YYYY-MM-DD'), // End date for all-day
        paramsAllDay.userTimezone, expect.any(String) // Description will be concatenation of tasks
        );
        expect(upsertEventsPostPlannerSpy).toHaveBeenCalledTimes(1);
        expect(sendGenericTaskEmailSpy).toHaveBeenCalledTimes(1);
    });
    // Test Case 3: callOpenAI fails.
    it('should fail if callOpenAI fails', async () => {
        const openAIError = { message: "AI system offline" };
        callOpenAISpy.mockResolvedValue({ success: false, error: openAIError });
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Failed to generate schedule via OpenAI.');
            expect(result.error.details).toEqual(openAIError);
        }
    });
    // Test Case 4: OpenAI response is not valid JSON.
    it('should fail if OpenAI response is not valid JSON', async () => {
        const nonJsonResponse = "This is just plain text.";
        callOpenAISpy.mockResolvedValue({ success: true, content: nonJsonResponse });
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Failed to parse schedule from OpenAI response as JSON.');
            expect(result.error.rawResponse).toBe(nonJsonResponse);
        }
    });
    // Test Case 5: OpenAI response is JSON but not an array.
    it('should fail if OpenAI response is JSON but not an array', async () => {
        const nonArrayJsonResponse = JSON.stringify({ task: "A single object, not an array" });
        callOpenAISpy.mockResolvedValue({ success: true, content: nonArrayJsonResponse });
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('OpenAI schedule response is not a valid array.');
            expect(result.error.parsedResponse).toEqual(JSON.parse(nonArrayJsonResponse));
        }
    });
    // Test Case 6: One of the createGoogleEvent calls fails (for non-all-day).
    it('should fail if a createGoogleEvent call fails for non-all-day schedule', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksNonAllDay) });
        const gEventError = { message: "Quota exceeded for GCal" };
        createGoogleEventSpy
            .mockResolvedValueOnce(mockSuccessfulGEventCreate) // First task succeeds
            .mockResolvedValueOnce({ success: false, error: gEventError }); // Second task fails
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain(`Failed to create Google Calendar event for task: "${mockParsedTasksNonAllDay[1].task}"`);
            expect(result.error.details).toEqual(gEventError);
        }
        expect(createGoogleEventSpy).toHaveBeenCalledTimes(2); // Called for first and failing second
        expect(upsertEventsPostPlannerSpy).not.toHaveBeenCalled(); // Should stop before upserting
    });
    // Test Case 7: upsertEventsPostPlanner fails.
    it('should fail if upsertEventsPostPlanner fails', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksNonAllDay) });
        const upsertError = { message: "DB connection error" };
        upsertEventsPostPlannerSpy.mockResolvedValue({ success: false, error: upsertError });
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Failed to save scheduled events to database.');
            expect(result.error.details).toEqual(upsertError);
        }
    });
    // Test Case 8: emailDailySchedule fails (if email provided).
    it('should fail if sendGenericTaskEmail (formerly emailDailySchedule) fails', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksNonAllDay) });
        const emailError = { message: "Mail server down" };
        sendGenericTaskEmailSpy.mockResolvedValue({ success: false, error: emailError });
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Failed to send daily schedule email.');
            expect(result.error.details).toEqual(emailError);
        }
    });
    // Test Case 9: No new tasks to schedule after filtering (all overlap existing events).
    it('should succeed with no events created if all parsed tasks overlap existing events', async () => {
        // Make existing events overlap with both parsed tasks
        const overlappingExistingEvents = [
            { id: 'exist1', summary: 'Overlap Task 1', startDateTime: dayjs.tz('2024-08-15 09:30 AM', 'YYYY-MM-DD h:mm A', defaultParams.userTimezone).toISOString(), endDateTime: dayjs.tz('2024-08-15 11:30 AM', 'YYYY-MM-DD h:mm A', defaultParams.userTimezone).toISOString() },
            { id: 'exist2', summary: 'Overlap Task 2', startDateTime: dayjs.tz('2024-08-15 1:30 PM', 'YYYY-MM-DD h:mm A', defaultParams.userTimezone).toISOString(), endDateTime: dayjs.tz('2024-08-15 3:30 PM', 'YYYY-MM-DD h:mm A', defaultParams.userTimezone).toISOString() }
        ];
        listEventsForUserGivenDatesSpy.mockResolvedValue({ success: true, data: overlappingExistingEvents });
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify(mockParsedTasksNonAllDay) });
        sendGenericTaskEmailSpy.mockResolvedValue({ success: true }); // Mock email success for this path
        const result = await createDaySchedule(...Object.values(defaultParams));
        expect(result).toEqual({ success: true });
        expect(createGoogleEventSpy).not.toHaveBeenCalled(); // No new non-overlapping events
        expect(upsertEventsPostPlannerSpy).toHaveBeenCalledWith([]); // Called with empty array
        expect(sendGenericTaskEmailSpy).toHaveBeenCalledWith(defaultParams.email, defaultParams.name, `Your Schedule for ${defaultParams.userDate}`, "Your day schedule was processed. After checking for overlaps with existing events, no new tasks were added to your calendar.");
    });
    it('should succeed with no email if no new tasks parsed from OpenAI', async () => {
        callOpenAISpy.mockResolvedValue({ success: true, content: JSON.stringify([]) }); // OpenAI returns no tasks
        listEventsForUserGivenDatesSpy.mockResolvedValue({ success: true, data: [] }); // No existing events
        const paramsNoEmail = { ...defaultParams, email: undefined, name: undefined };
        const result = await createDaySchedule(...Object.values(paramsNoEmail));
        expect(result).toEqual({ success: true });
        expect(createGoogleEventSpy).not.toHaveBeenCalled();
        expect(upsertEventsPostPlannerSpy).not.toHaveBeenCalled(); // Not called because eventsToUpsert is empty
        expect(sendGenericTaskEmailSpy).not.toHaveBeenCalled();
    });
});
// --- Tests for meetingRequest ---
import { meetingRequest } from './api-helper';
// Spies for apiHelperModule functions will be set up in describe block.
// generateAvailability is also part of apiHelperModule now (as a placeholder to be spied upon).
describe('meetingRequest', () => {
    let generateAvailabilitySpy;
    let callOpenAISpy;
    let sendMeetingRequestTemplateSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultParams = {
        userId: 'user_mr_test',
        clientType: 'web',
        userTimezone: 'America/New_York',
        userDateContext: 'next week',
        attendees: 'bob@example.com, alice@example.com',
        subject: 'Project Sync',
        prompt: 'Need to discuss Q3 goals.',
        durationMinutes: 30,
        shareAvailability: true,
        availabilityUserDateStart: '2024-08-01',
        availabilityUserDateEnd: '2024-08-03',
        emailTo: 'lead@example.com',
        emailName: 'Project Lead',
        yesLink: 'http://example.com/yes',
        noLink: 'http://example.com/no',
    };
    const mockAvailabilitySlots = [
        { startDate: '2024-08-01T10:00:00Z', endDate: '2024-08-01T11:00:00Z' },
        { startDate: '2024-08-01T14:00:00Z', endDate: '2024-08-01T15:00:00Z' },
        { startDate: '2024-08-02T09:00:00Z', endDate: '2024-08-02T10:00:00Z' },
    ];
    beforeEach(() => {
        jest.clearAllMocks();
        generateAvailabilitySpy = jest.spyOn(apiHelperModule, 'generateAvailability');
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI');
        sendMeetingRequestTemplateSpy = jest.spyOn(apiHelperModule, 'sendMeetingRequestTemplate');
    });
    afterEach(() => {
        consoleLogSpy.mockRestore();
    });
    // Test Case 1: Success with availability sharing.
    it('should succeed with availability sharing when all helpers succeed', async () => {
        generateAvailabilitySpy.mockResolvedValue({ success: true, data: mockAvailabilitySlots });
        // Mocking multiple calls to callOpenAI in order
        callOpenAISpy
            .mockResolvedValueOnce({ success: true, content: 'Summary for 2024-08-01' }) // Daily summary for 2024-08-01
            .mockResolvedValueOnce({ success: true, content: 'Summary for 2024-08-02' }) // Daily summary for 2024-08-02
            .mockResolvedValueOnce({ success: true, content: 'Final combined availability summary' }) // Combined summary
            .mockResolvedValueOnce({ success: true, content: 'Drafted email body with availability' }); // Email draft
        sendMeetingRequestTemplateSpy.mockResolvedValue({ success: true });
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result).toEqual({ success: true });
        expect(generateAvailabilitySpy).toHaveBeenCalledTimes(1);
        expect(callOpenAISpy).toHaveBeenCalledTimes(4); // 2 daily + 1 combined + 1 email draft
        expect(sendMeetingRequestTemplateSpy).toHaveBeenCalledTimes(1);
    });
    // Test Case 2: Success without availability sharing.
    it('should succeed without availability sharing', async () => {
        callOpenAISpy.mockResolvedValueOnce({ success: true, content: 'Drafted email body without availability' }); // Email draft
        sendMeetingRequestTemplateSpy.mockResolvedValue({ success: true });
        const paramsNoAvailability = { ...defaultParams, shareAvailability: false };
        const result = await meetingRequest(...Object.values(paramsNoAvailability));
        expect(result).toEqual({ success: true });
        expect(generateAvailabilitySpy).not.toHaveBeenCalled();
        expect(callOpenAISpy).toHaveBeenCalledTimes(1); // Only for email draft
        expect(sendMeetingRequestTemplateSpy).toHaveBeenCalledTimes(1);
    });
    it('should succeed without availability sharing and no email recipient (draft only)', async () => {
        callOpenAISpy.mockResolvedValueOnce({ success: true, content: 'Drafted email body, no recipient' });
        const paramsNoRecipient = { ...defaultParams, shareAvailability: false, emailTo: undefined, emailName: undefined, yesLink: undefined, noLink: undefined };
        const result = await meetingRequest(...Object.values(paramsNoRecipient));
        expect(result).toEqual({ success: true });
        expect(generateAvailabilitySpy).not.toHaveBeenCalled();
        expect(callOpenAISpy).toHaveBeenCalledTimes(1);
        expect(sendMeetingRequestTemplateSpy).not.toHaveBeenCalled(); // Email not sent
    });
    // Test Case 3: generateAvailability returns success: false.
    it('should fail if generateAvailability returns success:false', async () => {
        const genAvailError = { message: 'Failed to connect to calendar API' };
        generateAvailabilitySpy.mockResolvedValue({ success: false, error: genAvailError });
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Failed to generate availability.');
            expect(result.error.details).toEqual(genAvailError);
        }
    });
    // Test Case 4: generateAvailability returns success: true, data: [] (no slots).
    it('should fail if generateAvailability returns no slots', async () => {
        generateAvailabilitySpy.mockResolvedValue({ success: true, data: [] });
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('No availability slots found to share.');
        }
    });
    it('should fail if availability start/end dates are missing when shareAvailability is true', async () => {
        const paramsMissingDates = { ...defaultParams, availabilityUserDateStart: undefined, availabilityUserDateEnd: undefined };
        const result = await meetingRequest(...Object.values(paramsMissingDates));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Availability start and end dates are required when shareAvailability is true.');
        }
    });
    // Test Case 5: Any callOpenAI call fails.
    it('should fail if first callOpenAI (daily summary) fails', async () => {
        generateAvailabilitySpy.mockResolvedValue({ success: true, data: mockAvailabilitySlots });
        const openAIError = { message: "AI daily summary failed" };
        callOpenAISpy.mockResolvedValueOnce({ success: false, error: openAIError }); // Fail first daily summary
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toMatch(/Failed to summarize availability for date/);
            expect(result.error.details).toEqual(openAIError);
        }
    });
    it('should fail if second callOpenAI (combined summary) fails', async () => {
        generateAvailabilitySpy.mockResolvedValue({ success: true, data: mockAvailabilitySlots });
        callOpenAISpy
            .mockResolvedValueOnce({ success: true, content: 'Summary for 2024-08-01' })
            .mockResolvedValueOnce({ success: true, content: 'Summary for 2024-08-02' })
            .mockResolvedValueOnce({ success: false, error: { message: "AI combined summary failed" } }); // Fail combined
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Failed to generate combined availability summary.');
        }
    });
    it('should fail if third callOpenAI (email draft) fails', async () => {
        generateAvailabilitySpy.mockResolvedValue({ success: true, data: mockAvailabilitySlots });
        callOpenAISpy
            .mockResolvedValueOnce({ success: true, content: 'Summary for 2024-08-01' })
            .mockResolvedValueOnce({ success: true, content: 'Summary for 2024-08-02' })
            .mockResolvedValueOnce({ success: true, content: 'Final combined availability summary' })
            .mockResolvedValueOnce({ success: false, error: { message: "AI email draft failed" } }); // Fail email draft
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Failed to draft meeting request email body.');
        }
    });
    // Test Case 6: sendMeetingRequestTemplate fails.
    it('should fail if sendMeetingRequestTemplate fails', async () => {
        generateAvailabilitySpy.mockResolvedValue({ success: true, data: mockAvailabilitySlots });
        callOpenAISpy
            .mockResolvedValueOnce({ success: true, content: 'Daily summary 1' })
            .mockResolvedValueOnce({ success: true, content: 'Daily summary 2' })
            .mockResolvedValueOnce({ success: true, content: 'Combined summary' })
            .mockResolvedValueOnce({ success: true, content: 'Email body' });
        const emailError = { message: "SMTP error" };
        sendMeetingRequestTemplateSpy.mockResolvedValue({ success: false, error: emailError });
        const result = await meetingRequest(...Object.values(defaultParams));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Failed to send meeting request email.');
            expect(result.error.details).toEqual(emailError);
        }
    });
});
// --- Tests for Orchestrator Functions: createSummaryOfTimePeriod, breakDownTask, howToTask ---
import { createSummaryOfTimePeriod, breakDownTask, howToTask } from './api-helper';
// Spies for apiHelperModule functions will be set up in describe blocks or beforeEach.
// Other necessary mocks like 'got', 'googleapis', 'uuid', 'sendEmail' are already set up.
describe('createSummaryOfTimePeriod', () => {
    let listEventsForDateSpy;
    let callOpenAISpy;
    let sendSummaryEmailSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultParams = {
        userId: 'user_sum_test',
        startDate: '2024-03-01',
        endDate: '2024-03-07',
        timezone: 'America/New_York',
        email: 'test@example.com',
        name: 'Test User',
    };
    beforeEach(() => {
        jest.clearAllMocks();
        listEventsForDateSpy = jest.spyOn(apiHelperModule, 'listEventsForDate');
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI');
        sendSummaryEmailSpy = jest.spyOn(apiHelperModule, 'sendSummaryEmail');
    });
    afterEach(() => {
        consoleLogSpy.mockRestore();
    });
    it('should successfully create summary and send email', async () => {
        const mockEvents = [{ id: 'e1', summary: 'Event 1', startDateTime: '2024-03-01T10:00:00Z', endDateTime: '2024-03-01T11:00:00Z' }];
        listEventsForDateSpy.mockResolvedValue({ success: true, data: mockEvents });
        const summaryText = 'This is a great summary.';
        callOpenAISpy.mockResolvedValue({ success: true, content: summaryText });
        sendSummaryEmailSpy.mockResolvedValue({ success: true });
        const result = await createSummaryOfTimePeriod(defaultParams.userId, defaultParams.startDate, defaultParams.endDate, defaultParams.timezone, defaultParams.email, defaultParams.name);
        expect(result.success).toBe(true);
        if (result.success)
            expect(result.data).toBe(summaryText);
        expect(listEventsForDateSpy).toHaveBeenCalledTimes(1);
        expect(callOpenAISpy).toHaveBeenCalledTimes(1);
        expect(sendSummaryEmailSpy).toHaveBeenCalledTimes(1);
    });
    it('should successfully create summary without sending email if email/name not provided', async () => {
        const mockEvents = [{ id: 'e1', summary: 'Event 1' }];
        listEventsForDateSpy.mockResolvedValue({ success: true, data: mockEvents });
        const summaryText = 'Summary text here.';
        callOpenAISpy.mockResolvedValue({ success: true, content: summaryText });
        const result = await createSummaryOfTimePeriod(defaultParams.userId, defaultParams.startDate, defaultParams.endDate, defaultParams.timezone);
        expect(result.success).toBe(true);
        if (result.success)
            expect(result.data).toBe(summaryText);
        expect(sendSummaryEmailSpy).not.toHaveBeenCalled();
    });
    it('should return failure if listEventsForDate fails', async () => {
        const listError = { message: 'DB error listing events' };
        listEventsForDateSpy.mockResolvedValue({ success: false, error: listError });
        const result = await createSummaryOfTimePeriod(defaultParams.userId, defaultParams.startDate, defaultParams.endDate, defaultParams.timezone);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('event listing failure');
            expect(result.error.details).toEqual(listError);
        }
        expect(callOpenAISpy).not.toHaveBeenCalled();
    });
    it('should return specific failure if no events are found by listEventsForDate', async () => {
        listEventsForDateSpy.mockResolvedValue({ success: true, data: [] }); // No events
        const result = await createSummaryOfTimePeriod(defaultParams.userId, defaultParams.startDate, defaultParams.endDate, defaultParams.timezone);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('No events found to summarize.');
        }
        expect(callOpenAISpy).not.toHaveBeenCalled();
    });
    it('should return failure if callOpenAI fails', async () => {
        listEventsForDateSpy.mockResolvedValue({ success: true, data: [{ id: 'e1' }] });
        const openAIError = { message: 'AI unavailable' };
        callOpenAISpy.mockResolvedValue({ success: false, error: openAIError });
        const result = await createSummaryOfTimePeriod(defaultParams.userId, defaultParams.startDate, defaultParams.endDate, defaultParams.timezone);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('OpenAI call failure');
            expect(result.error.details).toEqual(openAIError);
        }
    });
    it('should return failure if sendSummaryEmail fails', async () => {
        listEventsForDateSpy.mockResolvedValue({ success: true, data: [{ id: 'e1' }] });
        callOpenAISpy.mockResolvedValue({ success: true, content: "summary" });
        const emailError = { message: "SMTP down" };
        sendSummaryEmailSpy.mockResolvedValue({ success: false, error: emailError });
        const result = await createSummaryOfTimePeriod(defaultParams.userId, defaultParams.startDate, defaultParams.endDate, defaultParams.timezone, defaultParams.email, defaultParams.name);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Failed to send summary email');
            expect(result.error.details).toEqual(emailError);
        }
    });
    it('should retry and succeed if Google Calendar API insert fails initially then succeeds', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_auth_token' });
        const apiError = new Error("Google API Error Attempt 1");
        apiError.code = 500; // Retryable error
        const mockSuccessfulApiResponse = { data: { id: 'gcal_event_retry_success', summary: basicEventDetails.summary } };
        mockGoogleEventsInsert
            .mockRejectedValueOnce(apiError) // Fails first time
            .mockResolvedValueOnce(mockSuccessfulApiResponse); // Succeeds second time
        const result = await createGoogleEvent(basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType, basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime, basicEventDetails.timezone);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.googleEventId).toBe('gcal_event_retry_success');
        }
        expect(mockGoogleEventsInsert).toHaveBeenCalledTimes(2); // Called twice (1 initial + 1 retry)
        // Check logger.warn was called for the retry
        const { localApiHelperLogger } = require('./api-helper'); // Access actual logger if tests are in same module, or mock
        expect(localApiHelperLogger.warn).toHaveBeenCalledWith("Retrying Google event creation", expect.objectContaining({
            operation_name: "GoogleCreateEvent_onRetry",
            attempt: 2, // onRetry is called *before* the next attempt, so attempt 2 is the one being prepared
            error_message: "Google API Error Attempt 1",
        }));
    });
    it('should fail after all retries if Google Calendar API insert consistently fails', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_auth_token' });
        const apiError1 = new Error("Google API Error Attempt 1");
        apiError1.code = 503;
        const apiError2 = new Error("Google API Error Attempt 2");
        apiError2.code = 503;
        const apiError3 = new Error("Google API Error Attempt 3");
        apiError3.code = 503;
        // async-retry default is 3 retries, so 4 calls total (1 initial + 3 retries)
        // However, the current config in createGoogleEvent is retries: 3 (meaning 1 initial + up to 3 retries, total 4 attempts)
        // Let's adjust to match the current implementation: retries: 3 means 1 initial + 3 retries (4 total calls).
        // The provided code has retries: 3 in the retry options, which typically means 1 initial + 3 retries = 4 total attempts.
        // The test should mock it to fail 4 times if that's the config.
        // The createGoogleEvent has `retries: 3`. async-retry's `retries` option means "total number of attempts is retries + 1".
        // So, 3 retries means 4 attempts.
        mockGoogleEventsInsert
            .mockRejectedValueOnce(apiError1)
            .mockRejectedValueOnce(apiError2)
            .mockRejectedValueOnce(apiError3)
            .mockRejectedValueOnce(new Error("Google API Error Attempt 4")); // Should fail on the 4th attempt if retries = 3
        const result = await createGoogleEvent(basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType, basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime, basicEventDetails.timezone);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Google Calendar API error during event creation: Google API Error Attempt 4');
        }
        expect(mockGoogleEventsInsert).toHaveBeenCalledTimes(4); // 1 initial + 3 retries
        const { localApiHelperLogger } = require('./api-helper');
        expect(localApiHelperLogger.warn).toHaveBeenCalledTimes(3); // Warns on each retry
        // Check the final error log if one is added in the catch block of createGoogleEvent after all retries
        // The current createGoogleEvent re-throws, so the final error comes from async-retry's last attempt.
        // localApiHelperLogger.error would be called if the function itself caught the final error and logged it.
        // The test already asserts the error message.
    });
});
describe('breakDownTask and howToTask common helper mocks', () => {
    // These spies are common to breakDownTask and howToTask
    let callOpenAISpy;
    let getGlobalCalendarSpy;
    let createGoogleEventSpy;
    let upsertEventsPostPlannerSpy;
    // Email spies will be specific to each function's describe block
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    const defaultTaskParams = {
        userId: 'user_task_test',
        clientType: 'web',
        userTimezone: 'America/Los_Angeles',
        taskTitle: 'Plan Q3 Roadmap',
        taskDescription: 'Detailed planning for all Q3 features.',
        isAllDay: false,
        startDate: '2024-07-01T00:00:00Z', // Assuming specific time if not all-day
        endDate: '2024-07-01T02:00:00Z',
        email: 'user@example.com',
        name: 'Task User',
    };
    const mockSuccessfulOpenAI_Task = { success: true, content: 'Task breakdown details or How-to steps' };
    const mockSuccessfulGlobalCalendar_Task = { success: true, data: { id: 'taskCalId', primaryCalendarId: 'primaryTaskCal' } };
    const mockSuccessfulCreateGoogleEvent_Task = { success: true, data: { id: 'gEventTask#primaryTaskCal', googleEventId: 'gEventTask', generatedId: 'uuidTask', calendarId: 'primaryTaskCal' } };
    const mockSuccessfulUpsert_Task = { success: true, data: { affected_rows: 1, returning: [{ id: 'dbEventTask' }] } };
    beforeEach(() => {
        jest.clearAllMocks();
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI');
        getGlobalCalendarSpy = jest.spyOn(apiHelperModule, 'getGlobalCalendar');
        // Note: createEventHelper is not exported, so we test its effects by mocking its dependencies:
        // getGlobalCalendar (already spied) and createGoogleEvent (spied below)
        // getGoogleAPIToken is also called by createGoogleEvent, so we ensure it's spied if createGoogleEvent is not fully mocked out.
        // For simplicity, we'll spy on createGoogleEvent directly as it's an exported helper.
        createGoogleEventSpy = jest.spyOn(apiHelperModule, 'createGoogleEvent');
        upsertEventsPostPlannerSpy = jest.spyOn(apiHelperModule, 'upsertEventsPostPlanner');
    });
    afterEach(() => {
        consoleLogSpy.mockRestore();
    });
    describe('breakDownTask', () => {
        let emailTaskBreakDownSpy;
        beforeEach(() => {
            emailTaskBreakDownSpy = jest.spyOn(apiHelperModule, 'emailTaskBreakDown');
        });
        afterEach(() => {
            emailTaskBreakDownSpy.mockRestore();
        });
        it('should successfully break down task, create event, and send email', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task); // For createEventHelper and for direct call
            createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent_Task);
            upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert_Task);
            emailTaskBreakDownSpy.mockResolvedValue({ success: true });
            const result = await breakDownTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.taskDescription, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(result).toEqual({ success: true });
            expect(callOpenAISpy).toHaveBeenCalledTimes(1);
            expect(createGoogleEventSpy).toHaveBeenCalledTimes(1);
            expect(upsertEventsPostPlannerSpy).toHaveBeenCalledTimes(1);
            expect(emailTaskBreakDownSpy).toHaveBeenCalledTimes(1);
        });
        it('should succeed for all-day event without email', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
            createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent_Task);
            upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert_Task);
            const paramsAllDay = { ...defaultTaskParams, isAllDay: true, email: undefined, name: undefined };
            const result = await breakDownTask(paramsAllDay.userId, paramsAllDay.clientType, paramsAllDay.userTimezone, paramsAllDay.taskTitle, paramsAllDay.taskDescription, paramsAllDay.isAllDay, dayjs(paramsAllDay.startDate).format('YYYY-MM-DD'), // All-day expects YYYY-MM-DD
            dayjs(paramsAllDay.endDate).format('YYYY-MM-DD') // All-day expects YYYY-MM-DD
            );
            expect(result).toEqual({ success: true });
            expect(emailTaskBreakDownSpy).not.toHaveBeenCalled();
            expect(createGoogleEventSpy).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), expect.anything(), dayjs(paramsAllDay.startDate).format('YYYY-MM-DD'), // Check all-day date format
            dayjs(paramsAllDay.endDate).add(1, 'day').format('YYYY-MM-DD'), // Check all-day end date format
            expect.anything(), expect.anything());
        });
        it('should fail if callOpenAI fails for breakDownTask', async () => {
            callOpenAISpy.mockResolvedValue({ success: false, error: { message: "AI broke" } });
            const result = await breakDownTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.taskDescription, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('OpenAI call failed');
            expect(createGoogleEventSpy).not.toHaveBeenCalled();
        });
        it('should fail if createGoogleEvent (via helper) fails for breakDownTask', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task); // For createEventHelper
            createGoogleEventSpy.mockResolvedValue({ success: false, error: { message: "GCal create error" } });
            const result = await breakDownTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.taskDescription, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Google event creation failed');
        });
        it('should fail if emailTaskBreakDown fails', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
            createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent_Task);
            upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert_Task);
            emailTaskBreakDownSpy.mockResolvedValue({ success: false, error: { message: "Email broke" } });
            const result = await breakDownTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.taskDescription, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Email sending failed');
        });
    });
    describe('howToTask', () => {
        let sendGenericTaskEmailSpy;
        beforeEach(() => {
            sendGenericTaskEmailSpy = jest.spyOn(apiHelperModule, 'sendGenericTaskEmail');
        });
        afterEach(() => {
            sendGenericTaskEmailSpy.mockRestore();
        });
        it('should successfully process howToTask, create event, and send email', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
            createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent_Task);
            upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert_Task);
            sendGenericTaskEmailSpy.mockResolvedValue({ success: true });
            const result = await howToTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(result).toEqual({ success: true });
            expect(callOpenAISpy).toHaveBeenCalledTimes(1);
            expect(createGoogleEventSpy).toHaveBeenCalledTimes(1);
            expect(upsertEventsPostPlannerSpy).toHaveBeenCalledTimes(1);
            expect(sendGenericTaskEmailSpy).toHaveBeenCalledTimes(1);
        });
        it('should succeed for all-day howToTask event without email', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
            createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent_Task);
            upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert_Task);
            const paramsAllDay = { ...defaultTaskParams, isAllDay: true, email: undefined, name: undefined };
            const result = await howToTask(paramsAllDay.userId, paramsAllDay.clientType, paramsAllDay.userTimezone, paramsAllDay.taskTitle, paramsAllDay.isAllDay, dayjs(paramsAllDay.startDate).format('YYYY-MM-DD'), dayjs(paramsAllDay.endDate).format('YYYY-MM-DD'));
            expect(result).toEqual({ success: true });
            expect(sendGenericTaskEmailSpy).not.toHaveBeenCalled();
            expect(createGoogleEventSpy).toHaveBeenCalledWith(expect.anything(), expect.anything(), expect.anything(), expect.stringContaining('How to:'), // Summary check
            dayjs(paramsAllDay.startDate).format('YYYY-MM-DD'), dayjs(paramsAllDay.endDate).add(1, 'day').format('YYYY-MM-DD'), expect.anything(), expect.anything());
        });
        it('should fail if callOpenAI fails for howToTask', async () => {
            callOpenAISpy.mockResolvedValue({ success: false, error: { message: "AI broke howto" } });
            const result = await howToTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('OpenAI call failed');
        });
        it('should fail if createGoogleEvent (via helper) fails for howToTask', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
            createGoogleEventSpy.mockResolvedValue({ success: false, error: { message: "GCal create error howto" } });
            const result = await howToTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Google event creation failed');
        });
        it('should fail if sendGenericTaskEmail fails', async () => {
            callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI_Task);
            getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar_Task);
            createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent_Task);
            upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert_Task);
            sendGenericTaskEmailSpy.mockResolvedValue({ success: false, error: { message: "Generic email broke" } });
            const result = await howToTask(defaultTaskParams.userId, defaultTaskParams.clientType, defaultTaskParams.userTimezone, defaultTaskParams.taskTitle, defaultTaskParams.isAllDay, defaultTaskParams.startDate, defaultTaskParams.endDate, defaultTaskParams.email, defaultTaskParams.name);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Email sending failed');
        });
    });
});
// --- Tests for createAgenda ---
import { createAgenda } from './api-helper';
import * as apiHelperModule from './api-helper'; // Used for spying on self-module calls
// sendEmail is already mocked from Email Wrapper Functions tests.
// got is already mocked.
// googleapis is already mocked.
// uuid is already mocked.
describe('createAgenda', () => {
    let callOpenAISpy;
    let getGlobalCalendarSpy;
    let getCalendarIntegrationSpy; // Though not directly called by createAgenda, getGoogleAPIToken calls it.
    let createGoogleEventSpy;
    let upsertEventsPostPlannerSpy;
    let sendAgendaEmailSpy;
    let getGoogleAPITokenSpy; // createGoogleEvent calls this
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    beforeEach(() => {
        jest.clearAllMocks(); // Clears all mocks including those for got, sendEmail, etc.
        // Spy on all helper functions within the same module
        callOpenAISpy = jest.spyOn(apiHelperModule, 'callOpenAI');
        getGlobalCalendarSpy = jest.spyOn(apiHelperModule, 'getGlobalCalendar');
        // getCalendarIntegrationSpy = jest.spyOn(apiHelperModule, 'getCalendarIntegration'); // Not directly called by createAgenda
        getGoogleAPITokenSpy = jest.spyOn(apiHelperModule, 'getGoogleAPIToken'); // Spied because createGoogleEvent calls it
        createGoogleEventSpy = jest.spyOn(apiHelperModule, 'createGoogleEvent');
        upsertEventsPostPlannerSpy = jest.spyOn(apiHelperModule, 'upsertEventsPostPlanner');
        sendAgendaEmailSpy = jest.spyOn(apiHelperModule, 'sendAgendaEmail');
    });
    afterEach(() => {
        // Restore all spies
        callOpenAISpy.mockRestore();
        getGlobalCalendarSpy.mockRestore();
        // getCalendarIntegrationSpy.mockRestore();
        getGoogleAPITokenSpy.mockRestore();
        createGoogleEventSpy.mockRestore();
        upsertEventsPostPlannerSpy.mockRestore();
        sendAgendaEmailSpy.mockRestore();
        consoleLogSpy.mockRestore();
    });
    const defaultCreateAgendaParams = {
        userId: 'user123',
        clientType: 'web',
        userTimezone: 'America/New_York',
        userDate: '2024-03-15',
        prompt: 'Create an agenda for a product strategy meeting.',
        email: 'test@example.com',
        name: 'Test User',
    };
    // Mock successful responses for all helpers by default
    const mockSuccessfulOpenAI = { success: true, content: 'Generated Agenda Details' };
    const mockSuccessfulGlobalCalendar = { success: true, data: { id: 'globalCalId', primaryCalendarId: 'primaryCal123' } };
    // getGoogleAPIToken is called by createGoogleEvent, so its mock is implicit via createGoogleEvent's mock if not spied directly.
    // However, createGoogleEvent itself is spied upon, so we control its direct output.
    const mockSuccessfulCreateGoogleEvent = { success: true, data: { id: 'gEvent123#primaryCal123', googleEventId: 'gEvent123', generatedId: 'uuid1', calendarId: 'primaryCal123' } };
    const mockSuccessfulUpsert = { success: true, data: { affected_rows: 1, returning: [{ id: 'dbEventId456' }] } };
    const mockSuccessfulEmail = { success: true };
    // Test Case 1: Successful agenda creation and email sent.
    it('should successfully create agenda and send email when all helpers succeed', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent);
        upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert);
        sendAgendaEmailSpy.mockResolvedValue(mockSuccessfulEmail);
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt, defaultCreateAgendaParams.email, defaultCreateAgendaParams.name);
        expect(result).toEqual({ success: true });
        expect(callOpenAISpy).toHaveBeenCalledTimes(1);
        expect(getGlobalCalendarSpy).toHaveBeenCalledWith(defaultCreateAgendaParams.userId);
        expect(createGoogleEventSpy).toHaveBeenCalledTimes(1); // Simplified: one event
        expect(upsertEventsPostPlannerSpy).toHaveBeenCalledTimes(1);
        expect(sendAgendaEmailSpy).toHaveBeenCalledWith(defaultCreateAgendaParams.email, defaultCreateAgendaParams.name, "Your Generated Agenda", mockSuccessfulOpenAI.content);
    });
    // Test Case 2: callOpenAI fails.
    it('should fail if callOpenAI fails', async () => {
        const openAIError = { message: 'OpenAI API limit reached' };
        callOpenAISpy.mockResolvedValue({ success: false, error: openAIError });
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('OpenAI call failed');
            expect(result.error.details).toEqual(openAIError);
        }
        expect(getGlobalCalendarSpy).not.toHaveBeenCalled();
        expect(createGoogleEventSpy).not.toHaveBeenCalled();
        expect(upsertEventsPostPlannerSpy).not.toHaveBeenCalled();
        expect(sendAgendaEmailSpy).not.toHaveBeenCalled();
    });
    // Test Case 3: getGlobalCalendar fails.
    it('should fail if getGlobalCalendar fails', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        const calendarError = { message: 'Global calendar not found' };
        getGlobalCalendarSpy.mockResolvedValue({ success: false, error: calendarError });
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('global calendar retrieval failure');
            expect(result.error.details).toEqual(calendarError);
        }
        expect(createGoogleEventSpy).not.toHaveBeenCalled();
    });
    // Test Case 4: createGoogleEvent fails.
    it('should fail if createGoogleEvent fails', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar);
        const eventCreationError = { message: 'Google Calendar API error' };
        createGoogleEventSpy.mockResolvedValue({ success: false, error: eventCreationError });
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Google event creation failure');
            expect(result.error.details).toEqual(eventCreationError);
        }
        expect(upsertEventsPostPlannerSpy).not.toHaveBeenCalled();
    });
    // Test Case 5: sendAgendaEmail fails (when email is provided).
    it('should fail if sendAgendaEmail fails when email is provided', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent);
        upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert);
        const emailSendError = { message: 'SMTP server down' };
        sendAgendaEmailSpy.mockResolvedValue({ success: false, error: emailSendError });
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt, defaultCreateAgendaParams.email, defaultCreateAgendaParams.name);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('email sending failure');
            expect(result.error.details).toEqual(emailSendError);
        }
    });
    // Test Case 6: Successful agenda creation, no email to send.
    it('should succeed if all helpers succeed and no email is provided', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent);
        upsertEventsPostPlannerSpy.mockResolvedValue(mockSuccessfulUpsert);
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt, undefined, undefined // No email, no name
        );
        expect(result).toEqual({ success: true });
        expect(sendAgendaEmailSpy).not.toHaveBeenCalled();
    });
    // Test Case 7: upsertEventsPostPlanner fails.
    it('should fail if upsertEventsPostPlanner fails', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy.mockResolvedValue(mockSuccessfulGlobalCalendar);
        createGoogleEventSpy.mockResolvedValue(mockSuccessfulCreateGoogleEvent);
        const upsertError = { message: 'Database constraint violation' };
        upsertEventsPostPlannerSpy.mockResolvedValue({ success: false, error: upsertError });
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('database event upsert failure');
            expect(result.error.details).toEqual(upsertError);
        }
        expect(sendAgendaEmailSpy).not.toHaveBeenCalled(); // Email sending is typically after DB upsert
    });
    it('should fail if getGlobalCalendar does not return primaryCalendarId', async () => {
        callOpenAISpy.mockResolvedValue(mockSuccessfulOpenAI);
        getGlobalCalendarSpy.mockResolvedValue({ success: true, data: { id: 'globalCalId' } }); // No primaryCalendarId
        const result = await createAgenda(defaultCreateAgendaParams.userId, defaultCreateAgendaParams.clientType, defaultCreateAgendaParams.userTimezone, defaultCreateAgendaParams.userDate, defaultCreateAgendaParams.prompt);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('global calendar retrieval failure');
        }
        expect(createGoogleEventSpy).not.toHaveBeenCalled();
    });
});
// --- Tests for Email Wrapper Functions ---
import { sendAgendaEmail, sendSummaryEmail, emailTaskBreakDown, sendGenericTaskEmail, sendMeetingRequestTemplate, } from './api-helper';
import { sendEmail } from '@/_utils/email/email';
// Mock the sendEmail utility
jest.mock('@/_utils/email/email', () => ({
    sendEmail: jest.fn(),
}));
const mockedSendEmail = sendEmail;
describe('Email Wrapper Functions', () => {
    let consoleLogSpy;
    beforeEach(() => {
        jest.clearAllMocks();
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    });
    afterEach(() => {
        consoleLogSpy.mockRestore();
    });
    // --- sendAgendaEmail ---
    describe('sendAgendaEmail', () => {
        const params = { to: 'test@example.com', name: 'Test User', title: 'Meeting Title', body: 'Agenda body' };
        it('should return success:true and call sendEmail with correct params for agenda', async () => {
            mockedSendEmail.mockResolvedValueOnce(undefined); // Assuming sendEmail is async and resolves on success
            const result = await sendAgendaEmail(params.to, params.name, params.title, params.body);
            expect(result).toEqual({ success: true });
            expect(mockedSendEmail).toHaveBeenCalledWith({
                template: 'agenda',
                locals: { name: params.name, title: params.title, body: params.body, to: params.to },
                subject: `Your Meeting Agenda: ${params.title}`,
                to: params.to,
            });
        });
        it('should return success:false on sendEmail failure for agenda', async () => {
            const errorMsg = 'SMTP Error for agenda';
            mockedSendEmail.mockImplementationOnce(() => { throw new Error(errorMsg); });
            const result = await sendAgendaEmail(params.to, params.name, params.title, params.body);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('Failed to send agenda email.');
                expect(result.error.details).toBe(errorMsg);
            }
            expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Error sending agenda email'), errorMsg);
        });
    });
    // --- sendSummaryEmail ---
    describe('sendSummaryEmail', () => {
        const params = { to: 'user@example.com', name: 'Summary User', title: 'Post-Meeting Summary', summary: 'Summary content' };
        it('should return success:true and call sendEmail with correct params for summary', async () => {
            mockedSendEmail.mockResolvedValueOnce(undefined);
            const result = await sendSummaryEmail(params.to, params.name, params.title, params.summary);
            expect(result).toEqual({ success: true });
            expect(mockedSendEmail).toHaveBeenCalledWith({
                template: 'summary',
                locals: { name: params.name, title: params.title, summary: params.summary, to: params.to },
                subject: `Your Meeting Summary: ${params.title}`,
                to: params.to,
            });
        });
        it('should return success:false on sendEmail failure for summary', async () => {
            const errorMsg = 'Failed sending summary';
            mockedSendEmail.mockImplementationOnce(() => { throw new Error(errorMsg); });
            const result = await sendSummaryEmail(params.to, params.name, params.title, params.summary);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('Failed to send summary email.');
                expect(result.error.details).toBe(errorMsg);
            }
        });
    });
    // --- emailTaskBreakDown ---
    describe('emailTaskBreakDown', () => {
        const params = { to: 'tasks@example.com', name: 'Task User', title: 'Project Tasks', tasks: 'List of tasks' };
        it('should return success:true and call sendEmail with correct params for task breakdown', async () => {
            mockedSendEmail.mockResolvedValueOnce(undefined);
            const result = await emailTaskBreakDown(params.to, params.name, params.title, params.tasks);
            expect(result).toEqual({ success: true });
            expect(mockedSendEmail).toHaveBeenCalledWith({
                template: 'task_breakdown',
                locals: { name: params.name, title: params.title, tasks: params.tasks, to: params.to },
                subject: `Your Task Breakdown for: ${params.title}`,
                to: params.to,
            });
        });
        it('should return success:false on sendEmail failure for task breakdown', async () => {
            const errorMsg = 'Task email failed';
            mockedSendEmail.mockImplementationOnce(() => { throw new Error(errorMsg); });
            const result = await emailTaskBreakDown(params.to, params.name, params.title, params.tasks);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('Failed to send task breakdown email.');
                expect(result.error.details).toBe(errorMsg);
            }
        });
    });
    // --- sendGenericTaskEmail ---
    describe('sendGenericTaskEmail', () => {
        const params = { to: 'generic@example.com', name: 'Generic User', title: 'Generic Task Notification', body: 'Details about the task.' };
        it('should return success:true and call sendEmail with correct params for generic task', async () => {
            mockedSendEmail.mockResolvedValueOnce(undefined);
            const result = await sendGenericTaskEmail(params.to, params.name, params.title, params.body);
            expect(result).toEqual({ success: true });
            expect(mockedSendEmail).toHaveBeenCalledWith({
                template: 'generic_task',
                locals: { name: params.name, title: params.title, body: params.body, to: params.to },
                subject: params.title,
                to: params.to,
            });
        });
        it('should return success:false on sendEmail failure for generic task', async () => {
            const errorMsg = 'Generic send failure';
            mockedSendEmail.mockImplementationOnce(() => { throw new Error(errorMsg); });
            const result = await sendGenericTaskEmail(params.to, params.name, params.title, params.body);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('Failed to send generic task email.');
                expect(result.error.details).toBe(errorMsg);
            }
        });
    });
    // --- sendMeetingRequestTemplate ---
    describe('sendMeetingRequestTemplate', () => {
        const params = {
            to: 'invite@example.com', name: 'Invitee Name', title: 'Meeting Invite',
            body: 'Please join us.', yesLink: 'http://yes.link', noLink: 'http://no.link'
        };
        it('should return success:true and call sendEmail with correct params for meeting request', async () => {
            mockedSendEmail.mockResolvedValueOnce(undefined);
            const result = await sendMeetingRequestTemplate(params.to, params.name, params.title, params.body, params.yesLink, params.noLink);
            expect(result).toEqual({ success: true });
            expect(mockedSendEmail).toHaveBeenCalledWith({
                template: 'meeting_request',
                locals: { name: params.name, title: params.title, body: params.body, yesLink: params.yesLink, noLink: params.noLink, to: params.to },
                subject: `Meeting Request: ${params.title}`,
                to: params.to,
            });
        });
        it('should return success:false on sendEmail failure for meeting request', async () => {
            const errorMsg = 'Meeting request dispatch error';
            mockedSendEmail.mockImplementationOnce(() => { throw new Error(errorMsg); });
            const result = await sendMeetingRequestTemplate(params.to, params.name, params.title, params.body, params.yesLink, params.noLink);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toBe('Failed to send meeting request email.');
                expect(result.error.details).toBe(errorMsg);
            }
        });
    });
});
describe('callOpenAI', () => {
    let consoleLogSpy;
    beforeEach(() => {
        jest.clearAllMocks();
        // Spy on console.log and suppress output during tests, but allow checking calls
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    });
    afterEach(() => {
        consoleLogSpy.mockRestore();
    });
    const systemMessage = "Test system message";
    const userMessage = "Test user message";
    // Test Case 1: Successful API call.
    it('should return success true and content on successful API call', async () => {
        const mockApiResponse = { choices: [{ message: { content: "Test response" } }] };
        mockCreate.mockResolvedValue(mockApiResponse);
        const result = await callOpenAI(systemMessage, userMessage);
        expect(OpenAI).toHaveBeenCalledTimes(1);
        expect(mockCreate).toHaveBeenCalledWith({
            model: 'gpt-4-1106-preview', // or gpt-3.5-turbo-1106 based on implementation
            messages: [
                { role: 'system', content: systemMessage },
                { role: 'user', content: userMessage },
            ],
        });
        expect(result).toEqual({ success: true, content: "Test response" });
    });
    // Test Case 2: OpenAI API error (e.g., HTTP 400).
    it('should return structured error on OpenAI API error', async () => {
        const apiError = {
            response: {
                status: 400,
                data: "Invalid request data",
            },
        };
        mockCreate.mockRejectedValue(apiError);
        const result = await callOpenAI(systemMessage, userMessage);
        expect(result).toEqual({
            success: false,
            error: {
                type: 'OPENAI_API_ERROR',
                status: 400,
                data: "Invalid request data",
                message: 'OpenAI API request failed',
            },
        });
        expect(consoleLogSpy).toHaveBeenCalledWith('OpenAI API Error Status:', 400);
        expect(consoleLogSpy).toHaveBeenCalledWith('OpenAI API Error Data:', "Invalid request data");
    });
    // Test Case 3: Other request error (e.g., network issue).
    it('should return structured error on other request errors', async () => {
        const networkError = new Error("Network connection failed");
        mockCreate.mockRejectedValue(networkError);
        const result = await callOpenAI(systemMessage, userMessage);
        expect(result).toEqual({
            success: false,
            error: {
                type: 'OPENAI_REQUEST_ERROR',
                message: "Network connection failed",
            },
        });
        expect(consoleLogSpy).toHaveBeenCalledWith('Error calling OpenAI:', "Network connection failed");
    });
    // Test Case 4: Call with exampleInput and exampleOutput.
    it('should include example messages when exampleInput and exampleOutput are provided', async () => {
        const exampleInput = "Example user input";
        const exampleOutput = "Example assistant response";
        const mockApiResponse = { choices: [{ message: { content: "Test response following examples" } }] };
        mockCreate.mockResolvedValue(mockApiResponse);
        const result = await callOpenAI(systemMessage, userMessage, exampleInput, exampleOutput);
        expect(mockCreate).toHaveBeenCalledWith({
            model: 'gpt-4-1106-preview', // or gpt-3.5-turbo-1106
            messages: [
                { role: 'system', content: systemMessage },
                { role: 'user', content: exampleInput },
                { role: 'assistant', content: exampleOutput },
                { role: 'user', content: userMessage },
            ],
        });
        expect(result).toEqual({ success: true, content: "Test response following examples" });
    });
    // Test for default model gpt-3.5-turbo-1106 if no model specified
    it('should use gpt-3.5-turbo-1106 if no model is specified and message length is okay', async () => {
        const mockApiResponse = { choices: [{ message: { content: "Test response from 3.5" } }] };
        mockCreate.mockResolvedValue(mockApiResponse);
        // Assuming the function defaults to gpt-3.5-turbo-1106 if model param is undefined
        await callOpenAI(systemMessage, userMessage, undefined, undefined, undefined);
        expect(mockCreate).toHaveBeenCalledWith(expect.objectContaining({
            model: 'gpt-3.5-turbo-1106'
        }));
    });
    // Test for model gpt-4-1106-preview if specified
    it('should use gpt-4-1106-preview if specified', async () => {
        const mockApiResponse = { choices: [{ message: { content: "Test response from 4" } }] };
        mockCreate.mockResolvedValue(mockApiResponse);
        await callOpenAI(systemMessage, userMessage, undefined, undefined, 'gpt-4-1106-preview');
        expect(mockCreate).toHaveBeenCalledWith(expect.objectContaining({
            model: 'gpt-4-1106-preview'
        }));
    });
});
// --- Tests for Google Auth Helper Functions ---
import { getCalendarIntegration, refreshGoogleToken, updateCalendarIntegration, getGoogleAPIToken, // This is the one we intend to test (Final version)
// CalendarIntegrationType, // Not used directly in tests, but good for context
// GoogleTokenResponseType, // Same as above
 } from './api-helper';
import got from 'got';
import dayjs from 'dayjs';
// Mock 'got'
jest.mock('got');
const mockedGot = got;
describe('getCalendarIntegration', () => {
    beforeEach(() => {
        jest.clearAllMocks();
        // Reset process.env variables if they are modified by tests, or set defaults
        process.env.HASURA_ENDPOINT_URL = 'http://hasura.test';
        process.env.HASURA_ADMIN_SECRET = 'secret';
    });
    it('should return calendar integration data on successful fetch', async () => {
        const mockData = { Calendar_Integration: [{ id: 'int_123', userId: 'user_abc', resource: 'google_calendar' }] };
        mockedGot.post.mockResolvedValueOnce({ body: { data: mockData } });
        const result = await getCalendarIntegration('user_abc', 'google_calendar');
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data).toEqual(mockData.Calendar_Integration[0]);
        }
        expect(mockedGot.post).toHaveBeenCalledTimes(1);
    });
    it('should return success false if no integration is found', async () => {
        const mockData = { Calendar_Integration: [] }; // Empty array
        mockedGot.post.mockResolvedValueOnce({ body: { data: mockData } });
        const result = await getCalendarIntegration('user_xyz', 'unknown_resource');
        expect(result.success).toBe(true); // The function returns success:true even if data is undefined
        if (result.success) {
            expect(result.data).toBeUndefined();
        }
    });
    it('should return success false on Hasura error', async () => {
        const mockError = { errors: [{ message: "DB connection error" }] };
        mockedGot.post.mockResolvedValueOnce({ body: mockError });
        const result = await getCalendarIntegration('user_abc', 'google_calendar');
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Hasura query error');
            expect(result.error.details).toEqual(mockError.errors);
        }
    });
    it('should return success false on got.post rejection', async () => {
        mockedGot.post.mockRejectedValueOnce(new Error('Network failure'));
        const result = await getCalendarIntegration('user_abc', 'google_calendar');
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Network failure');
        }
    });
});
// --- Tests for upsertEventsPostPlanner ---
import { upsertEventsPostPlanner } from './api-helper';
// 'got' is already mocked from previous Google Auth tests.
describe('upsertEventsPostPlanner', () => {
    beforeEach(() => {
        // Clear mocks including got.post if it's not cleared globally or in a higher describe
        mockedGot.post.mockClear();
        // Ensure ENV vars for Hasura are set if not globally
        process.env.HASURA_ENDPOINT_URL = 'http://hasura.test';
        process.env.HASURA_ADMIN_SECRET = 'secret';
    });
    const sampleEventsInput = [
        { calendarId: 'cal1', userId: 'user1', summary: 'Event 1', startDateTime: '2024-01-01T10:00:00Z', endDateTime: '2024-01-01T11:00:00Z', timezone: 'UTC', id: 'event_id_1' },
        { calendarId: 'cal1', userId: 'user1', summary: 'Event 2', startDateTime: '2024-01-02T10:00:00Z', endDateTime: '2024-01-02T11:00:00Z', timezone: 'UTC', id: 'event_id_2' },
        { calendarId: 'cal1', userId: 'user1', summary: 'Event 1', startDateTime: '2024-01-01T10:00:00Z', endDateTime: '2024-01-01T11:00:00Z', timezone: 'UTC', id: 'event_id_1' }, // Duplicate by id
    ];
    const uniqueEventsForMock = [
        { calendarId: 'cal1', userId: 'user1', summary: 'Event 1', startDateTime: '2024-01-01T10:00:00Z', endDateTime: '2024-01-01T11:00:00Z', timezone: 'UTC', id: 'event_id_1', provider: 'google_calendar', status: 'confirmed' },
        { calendarId: 'cal1', userId: 'user1', summary: 'Event 2', startDateTime: '2024-01-02T10:00:00Z', endDateTime: '2024-01-02T11:00:00Z', timezone: 'UTC', id: 'event_id_2', provider: 'google_calendar', status: 'confirmed' },
    ];
    // Test Case 1: Successful upsert of one or more unique events.
    it('should successfully upsert unique events', async () => {
        const mockHasuraResponse = { data: { insert_Event: { affected_rows: 2, returning: [{ id: 'event_id_1' }, { id: 'event_id_2' }] } } };
        mockedGot.post.mockResolvedValueOnce({ body: mockHasuraResponse });
        const result = await upsertEventsPostPlanner(sampleEventsInput);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data).toEqual(mockHasuraResponse.data.insert_Event);
        }
        expect(mockedGot.post).toHaveBeenCalledTimes(1);
        expect(mockedGot.post).toHaveBeenCalledWith(process.env.HASURA_ENDPOINT_URL, expect.objectContaining({
            json: expect.objectContaining({
                variables: { objects: uniqueEventsForMock }, // Check if unique events are passed
            }),
        }));
    });
    // Test Case 2: Hasura returns an error in the response body.
    it('should return failure if Hasura response contains errors', async () => {
        const hasuraError = { errors: [{ message: 'Constraint violation' }] };
        mockedGot.post.mockResolvedValueOnce({ body: hasuraError });
        const result = await upsertEventsPostPlanner(sampleEventsInput.slice(0, 1)); // Use a non-empty array
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Hasura API error during event upsert.');
            expect(result.error.details).toEqual(hasuraError.errors);
        }
    });
    it('should return failure if Hasura response has unexpected structure (no data.insert_Event)', async () => {
        const malformedResponse = { data: {} }; // Missing insert_Event
        mockedGot.post.mockResolvedValueOnce({ body: malformedResponse });
        const result = await upsertEventsPostPlanner(sampleEventsInput.slice(0, 1));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Unexpected response structure from Hasura during event upsert.');
        }
    });
    // Test Case 3: got.post itself throws a network error.
    it('should return failure if got.post throws a network error', async () => {
        const networkErrorMessage = 'Connection timed out';
        mockedGot.post.mockRejectedValueOnce(new Error(networkErrorMessage));
        const result = await upsertEventsPostPlanner(sampleEventsInput.slice(0, 1));
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toBe('Network error during event upsert.');
            expect(result.error.details).toBe(networkErrorMessage);
        }
    });
    // Test Case 4: Input events array is empty.
    it('should return success with 0 affected_rows if input events array is empty', async () => {
        const result = await upsertEventsPostPlanner([]);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data).toEqual({ affected_rows: 0, returning: [] });
        }
        expect(mockedGot.post).not.toHaveBeenCalled();
    });
    // Test Case 5: Input events array becomes empty after _.uniqBy (e.g. contains only null/undefined).
    it('should return success with 0 affected_rows if events array becomes empty after filtering', async () => {
        // _.uniqBy(events.filter(e => e), 'id'); -> if events = [null, undefined], filter(e=>e) results in []
        const result = await upsertEventsPostPlanner([null, undefined]); // Cast as any to bypass EventInput type for test
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data).toEqual({ affected_rows: 0, returning: [] });
        }
        expect(mockedGot.post).not.toHaveBeenCalled();
    });
});
// --- Tests for Hasura Read Operation Functions ---
import { getGlobalCalendar, listEventsForDate, listEventsForUserGivenDates, getUserPreferences } from './api-helper';
// 'got' is already mocked from previous tests.
// mockedGot variable is available.
describe('Hasura Read Functions', () => {
    beforeEach(() => {
        mockedGot.post.mockClear();
        process.env.HASURA_ENDPOINT_URL = 'http://hasura.test';
        process.env.HASURA_ADMIN_SECRET = 'secret';
    });
    // --- getGlobalCalendar ---
    describe('getGlobalCalendar', () => {
        const userId = 'user_gcal_test';
        it('should return global calendar data on successful fetch', async () => {
            const mockCalendarData = { id: 'gcal_1', userId, primaryCalendarId: 'primary@example.com' };
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Calendar: [mockCalendarData] } } });
            const result = await getGlobalCalendar(userId);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual(mockCalendarData);
            expect(mockedGot.post).toHaveBeenCalledWith(process.env.HASURA_ENDPOINT_URL, expect.objectContaining({
                json: expect.objectContaining({
                    query: expect.stringContaining('GetGlobalCalendar'),
                    variables: { userId },
                }),
            }));
        });
        it('should return success:true, data:undefined if no global calendar found', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Calendar: [] } } });
            const result = await getGlobalCalendar(userId);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toBeUndefined();
        });
        it('should return failure on Hasura error for getGlobalCalendar', async () => {
            const hasuraErrors = [{ message: 'Permission denied on Calendar' }];
            mockedGot.post.mockResolvedValueOnce({ body: { errors: hasuraErrors } });
            const result = await getGlobalCalendar(userId);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toContain('Hasura API error during getGlobalCalendar');
                expect(result.error.details).toEqual(hasuraErrors);
            }
        });
        it('should return failure on network error for getGlobalCalendar', async () => {
            const networkErrorMsg = 'Network connection failed';
            mockedGot.post.mockRejectedValueOnce(new Error(networkErrorMsg));
            const result = await getGlobalCalendar(userId);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toContain('Network error during getGlobalCalendar');
                expect(result.error.details).toBe(networkErrorMsg);
            }
        });
        it('should return failure on unexpected response structure for getGlobalCalendar', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: {} } }); // Missing Calendar key
            const result = await getGlobalCalendar(userId);
            expect(result.success).toBe(false);
            if (!result.success) {
                expect(result.error.message).toContain('Unexpected response structure during getGlobalCalendar');
            }
        });
    });
    // --- listEventsForDate ---
    describe('listEventsForDate', () => {
        const userId = 'user_events_test';
        const startDate = '2024-03-01T00:00:00Z';
        const endDate = '2024-03-01T23:59:59Z';
        const timezone = 'America/New_York';
        it('should return events on successful fetch', async () => {
            const mockEvents = [{ id: 'evt_1', summary: 'Event 1' }, { id: 'evt_2', summary: 'Event 2' }];
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Event: mockEvents } } });
            const result = await listEventsForDate(userId, startDate, endDate, timezone);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual(mockEvents);
            expect(mockedGot.post).toHaveBeenCalledWith(process.env.HASURA_ENDPOINT_URL, expect.objectContaining({
                json: expect.objectContaining({
                    query: expect.stringContaining('ListEventsForDate'),
                    variables: { userId, startDate, endDate },
                }),
            }));
        });
        it('should return success:true, data:[] if no events found', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Event: [] } } });
            const result = await listEventsForDate(userId, startDate, endDate, timezone);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual([]);
        });
        it('should also return success:true, data:[] if Event key is null', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Event: null } } });
            const result = await listEventsForDate(userId, startDate, endDate, timezone);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual([]);
        });
        it('should return failure on Hasura error for listEventsForDate', async () => {
            const hasuraErrors = [{ message: 'Error fetching events' }];
            mockedGot.post.mockResolvedValueOnce({ body: { errors: hasuraErrors } });
            const result = await listEventsForDate(userId, startDate, endDate, timezone);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.details).toEqual(hasuraErrors);
        });
        it('should return failure on network error for listEventsForDate', async () => {
            mockedGot.post.mockRejectedValueOnce(new Error('Connection issue'));
            const result = await listEventsForDate(userId, startDate, endDate, timezone);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.details).toBe('Connection issue');
        });
        it('should return failure on unexpected response for listEventsForDate', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: {} } }); // Missing Event key
            const result = await listEventsForDate(userId, startDate, endDate, timezone);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Unexpected response structure');
        });
    });
    // --- listEventsForUserGivenDates --- (Similar to listEventsForDate, can be more concise)
    describe('listEventsForUserGivenDates', () => {
        const userId = 'user_lgd_test';
        const senderStartDate = '2024-03-02T00:00:00Z';
        const senderEndDate = '2024-03-02T23:59:59Z';
        it('should return events successfully', async () => {
            const mockEvents = [{ id: 'evt_lgd_1', summary: 'LGD Event' }];
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Event: mockEvents } } });
            const result = await listEventsForUserGivenDates(userId, senderStartDate, senderEndDate);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual(mockEvents);
            expect(mockedGot.post).toHaveBeenCalledWith(process.env.HASURA_ENDPOINT_URL, expect.objectContaining({
                json: expect.objectContaining({
                    query: expect.stringContaining('ListEventsForUserGivenDates'),
                    variables: { userId, startDate: senderStartDate, endDate: senderEndDate },
                }),
            }));
        });
        it('should return success:true, data:[] if no events found for listEventsForUserGivenDates', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: { Event: [] } } });
            const result = await listEventsForUserGivenDates(userId, senderStartDate, senderEndDate);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual([]);
        });
        it('should return failure on Hasura error for listEventsForUserGivenDates', async () => {
            const hasuraErrors = [{ message: 'DB error on LGD' }];
            mockedGot.post.mockResolvedValueOnce({ body: { errors: hasuraErrors } });
            const result = await listEventsForUserGivenDates(userId, senderStartDate, senderEndDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.details).toEqual(hasuraErrors);
        });
        it('should return failure on network error for listEventsForUserGivenDates', async () => {
            mockedGot.post.mockRejectedValueOnce(new Error('Net fail LGD'));
            const result = await listEventsForUserGivenDates(userId, senderStartDate, senderEndDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.details).toBe('Net fail LGD');
        });
        it('should return failure on unexpected response for listEventsForUserGivenDates', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: {} } }); // Missing Event key
            const result = await listEventsForUserGivenDates(userId, senderStartDate, senderEndDate);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Unexpected response structure');
        });
    });
    // --- getUserPreferences ---
    describe('getUserPreferences', () => {
        const userId = 'user_prefs_test';
        it('should return user preferences on successful fetch', async () => {
            const mockPrefs = { id: 'pref_1', userId, somePreference: 'dark_mode' };
            mockedGot.post.mockResolvedValueOnce({ body: { data: { User_Preferences: [mockPrefs] } } });
            const result = await getUserPreferences(userId);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toEqual(mockPrefs);
            expect(mockedGot.post).toHaveBeenCalledWith(process.env.HASURA_ENDPOINT_URL, expect.objectContaining({
                json: expect.objectContaining({
                    query: expect.stringContaining('GetUserPreferences'),
                    variables: { userId },
                }),
            }));
        });
        it('should return success:true, data:undefined if no preferences found', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: { User_Preferences: [] } } });
            const result = await getUserPreferences(userId);
            expect(result.success).toBe(true);
            if (result.success)
                expect(result.data).toBeUndefined();
        });
        it('should return failure on Hasura error for getUserPreferences', async () => {
            const hasuraErrors = [{ message: 'Prefs table error' }];
            mockedGot.post.mockResolvedValueOnce({ body: { errors: hasuraErrors } });
            const result = await getUserPreferences(userId);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.details).toEqual(hasuraErrors);
        });
        it('should return failure on network error for getUserPreferences', async () => {
            mockedGot.post.mockRejectedValueOnce(new Error('Prefs net fail'));
            const result = await getUserPreferences(userId);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.details).toBe('Prefs net fail');
        });
        it('should return failure on unexpected response for getUserPreferences', async () => {
            mockedGot.post.mockResolvedValueOnce({ body: { data: {} } }); // Missing User_Preferences key
            const result = await getUserPreferences(userId);
            expect(result.success).toBe(false);
            if (!result.success)
                expect(result.error.message).toContain('Unexpected response structure');
        });
    });
});
describe('refreshGoogleToken', () => {
    beforeEach(() => {
        process.env.GOOGLE_CLIENT_ID_WEB = 'web_client_id';
        process.env.GOOGLE_CLIENT_SECRET_WEB = 'web_client_secret';
        process.env.GOOGLE_CLIENT_ID_IOS = 'ios_client_id';
        process.env.GOOGLE_CLIENT_SECRET_IOS = 'ios_client_secret';
    });
    it('should return new token data on successful refresh for web', async () => {
        const mockTokenData = { access_token: 'new_access_token', expires_in: 3600 };
        mockedGot.post.mockResolvedValueOnce({ body: mockTokenData });
        const result = await refreshGoogleToken('old_refresh_token', 'web');
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data).toEqual(mockTokenData);
        }
        expect(mockedGot.post).toHaveBeenCalledWith('https://oauth2.googleapis.com/token', expect.any(Object));
    });
    it('should return success false if client ID/secret not configured', async () => {
        delete process.env.GOOGLE_CLIENT_ID_WEB; // Remove one config
        const result = await refreshGoogleToken('refresh_token', 'web');
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Google client ID or secret not configured');
        }
    });
    it('should return success false on got.post rejection', async () => {
        mockedGot.post.mockRejectedValueOnce(new Error('API limit reached'));
        const result = await refreshGoogleToken('old_refresh_token', 'web');
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('API limit reached');
        }
    });
});
describe('updateCalendarIntegration', () => {
    it('should return success true on successful update', async () => {
        mockedGot.post.mockResolvedValueOnce({ body: { data: { update_Calendar_Integration_by_pk: { id: 'ci_123' } } } });
        const result = await updateCalendarIntegration('ci_123', 'new_token_val', dayjs().toISOString(), 'new_refresh_val', true);
        expect(result.success).toBe(true);
        expect(mockedGot.post).toHaveBeenCalledTimes(1);
    });
    it('should return success false if ID not found or no data returned', async () => {
        mockedGot.post.mockResolvedValueOnce({ body: { data: { update_Calendar_Integration_by_pk: null } } });
        const result = await updateCalendarIntegration('ci_unknown', 'token', dayjs().toISOString());
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('No data returned or ID not found');
        }
    });
    it('should return success false on got.post rejection', async () => {
        mockedGot.post.mockRejectedValueOnce(new Error('DB write failed'));
        const result = await updateCalendarIntegration('ci_123', 'new_token_val', dayjs().toISOString());
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('DB write failed');
        }
    });
});
describe('getGoogleAPIToken', () => {
    const userId = 'test_user';
    const resource = 'google_calendar';
    const validToken = 'valid_access_token';
    const expiredToken = 'expired_access_token';
    const refreshToken = 'valid_refresh_token';
    const newAccessToken = 'newly_refreshed_access_token';
    const futureTime = dayjs().add(1, 'hour').toISOString();
    const pastTime = dayjs().subtract(1, 'hour').toISOString();
    beforeEach(() => {
        jest.useFakeTimers(); // Use fake timers
        jest.setSystemTime(new Date('2023-01-01T12:00:00Z')); // Set a fixed system time
    });
    afterEach(() => {
        jest.useRealTimers(); // Restore real timers
    });
    // Mocks for getCalendarIntegration, refreshGoogleToken, updateCalendarIntegration will be done per test
    // by spying on the module's own exports and providing mock implementations.
    // This is tricky if they are in the same module and not passed as params.
    // For simplicity, we'll continue mocking got.post for the underlying functions.
    it('Success - Valid Token: should return existing valid token', async () => {
        const mockIntegration = {
            id: 'ci_123', userId, resource, clientType: 'web',
            token: validToken, expiresAt: futureTime, refreshToken, syncEnabled: true,
        };
        mockedGot.post.mockImplementation(async (url) => {
            if (url === process.env.HASURA_ENDPOINT_URL) { // getCalendarIntegration call
                return { body: { data: { Calendar_Integration: [mockIntegration] } } };
            }
            return {};
        });
        const result = await getGoogleAPIToken(userId, resource);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.token).toBe(validToken);
        }
        expect(mockedGot.post).toHaveBeenCalledTimes(1); // Only getCalendarIntegration
    });
    it('Success - Expired Token, Successful Refresh: should refresh and return new token', async () => {
        const mockIntegrationExpired = {
            id: 'ci_123', userId, resource, clientType: 'web',
            token: expiredToken, expiresAt: pastTime, refreshToken, syncEnabled: true,
        };
        const mockRefreshResponse = { access_token: newAccessToken, expires_in: 3600 };
        const mockUpdateResponse = { data: { update_Calendar_Integration_by_pk: { id: 'ci_123' } } };
        mockedGot.post.mockImplementation(async (url, options) => {
            if (url === process.env.HASURA_ENDPOINT_URL) {
                const body = options?.json;
                if (body.query.includes('GetCalendarIntegration')) { // getCalendarIntegration call
                    return { body: { data: { Calendar_Integration: [mockIntegrationExpired] } } };
                }
                if (body.query.includes('UpdateCalendarIntegration')) { // updateCalendarIntegration call
                    return { body: mockUpdateResponse };
                }
            }
            if (url === 'https://oauth2.googleapis.com/token') { // refreshGoogleToken call
                return { body: mockRefreshResponse };
            }
            return {};
        });
        const result = await getGoogleAPIToken(userId, resource);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.token).toBe(newAccessToken);
        }
        expect(mockedGot.post).toHaveBeenCalledTimes(3); // getCalendarIntegration, refreshGoogleToken, updateCalendarIntegration
    });
    it('Failure - Expired Token, Refresh Fails: should try refresh, fail, and disable sync', async () => {
        const mockIntegrationExpired = {
            id: 'ci_123', userId, resource, clientType: 'web',
            token: expiredToken, expiresAt: pastTime, refreshToken, syncEnabled: true,
        };
        const mockUpdateResponse = { data: { update_Calendar_Integration_by_pk: { id: 'ci_123' } } }; // For disabling sync
        mockedGot.post.mockImplementation(async (url, options) => {
            if (url === process.env.HASURA_ENDPOINT_URL) {
                const body = options?.json;
                if (body.query.includes('GetCalendarIntegration')) {
                    return { body: { data: { Calendar_Integration: [mockIntegrationExpired] } } };
                }
                if (body.query.includes('UpdateCalendarIntegration')) { // For disabling sync
                    // Check if it's the disable sync call
                    expect(body.variables.syncEnabled).toBe(false);
                    return { body: mockUpdateResponse };
                }
            }
            if (url === 'https://oauth2.googleapis.com/token') {
                throw new Error('Refresh failed'); // Simulate refresh failure
            }
            return {};
        });
        const result = await getGoogleAPIToken(userId, resource);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Token refresh failed');
        }
        // getCalendarIntegration, refresh (fails), update (to disable sync)
        expect(mockedGot.post).toHaveBeenCalledTimes(3);
    });
    it('Failure - getCalendarIntegration Fails: should propagate the error', async () => {
        mockedGot.post.mockImplementation(async (url) => {
            if (url === process.env.HASURA_ENDPOINT_URL) {
                throw new Error('DB error'); // getCalendarIntegration fails
            }
            return {};
        });
        const result = await getGoogleAPIToken(userId, resource);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Could not get calendar integration');
            expect(result.error.details?.message).toContain('DB error');
        }
    });
    it('Failure - No Refresh Token available when needed: should fail and disable sync', async () => {
        const mockIntegrationNoRefreshToken = {
            id: 'ci_789', userId, resource, clientType: 'web',
            token: expiredToken, expiresAt: pastTime, refreshToken: null, // No refresh token
            syncEnabled: true,
        };
        const mockUpdateResponse = { data: { update_Calendar_Integration_by_pk: { id: 'ci_789' } } };
        mockedGot.post.mockImplementation(async (url, options) => {
            if (url === process.env.HASURA_ENDPOINT_URL) {
                const body = options?.json;
                if (body.query.includes('GetCalendarIntegration')) {
                    return { body: { data: { Calendar_Integration: [mockIntegrationNoRefreshToken] } } };
                }
                if (body.query.includes('UpdateCalendarIntegration')) { // For disabling sync
                    expect(body.variables.syncEnabled).toBe(false);
                    return { body: mockUpdateResponse };
                }
            }
            return {};
        });
        const result = await getGoogleAPIToken(userId, resource);
        expect(result.success).toBe(false);
        if (!result.success) {
            expect(result.error.message).toContain('Refresh needed but no refresh token available');
        }
        expect(mockedGot.post).toHaveBeenCalledTimes(2); // getCalendarIntegration, updateCalendarIntegration (to disable)
    });
    it('Failure - Integration ID missing after refresh (should not happen if initial integration had ID): should return error', async () => {
        // This tests a more hypothetical scenario where 'id' might be lost or was never there for an update.
        const mockIntegrationExpiredNoIdInitially = {
            id: null, // No ID to start with, or it's undefined
            userId, resource, clientType: 'web',
            token: expiredToken, expiresAt: pastTime, refreshToken, syncEnabled: true,
        };
        const mockRefreshResponse = { access_token: newAccessToken, expires_in: 3600 };
        mockedGot.post.mockImplementation(async (url, options) => {
            if (url === process.env.HASURA_ENDPOINT_URL) {
                const body = options?.json;
                if (body.query.includes('GetCalendarIntegration')) {
                    // Simulate integration data that lacks an ID but has enough to trigger a refresh attempt
                    return { body: { data: { Calendar_Integration: [{ ...mockIntegrationExpiredNoIdInitially, id: undefined }] } } };
                }
            }
            if (url === 'https://oauth2.googleapis.com/token') {
                return { body: mockRefreshResponse };
            }
            return {};
        });
        const result = await getGoogleAPIToken(userId, resource);
        expect(result.success).toBe(false);
        if (!result.success) {
            // Based on the refactored code, if integration.id is null/undefined before update, it returns this message:
            expect(result.error.message).toContain('Integration ID missing after refresh');
        }
        // getCalendarIntegration, refreshGoogleToken. updateCalendarIntegration is not called due to missing id.
        expect(mockedGot.post).toHaveBeenCalledTimes(2);
    });
});
// --- Tests for createGoogleEvent ---
import { createGoogleEvent } from './api-helper';
import { google } from 'googleapis'; // For accessing the mocked google.calendar().events.insert
import { v4 as uuidv4 } from 'uuid';
// Mock uuid
jest.mock('uuid', () => ({
    v4: jest.fn(),
}));
// Access the mock for google.calendar().events.insert
// This was set up in the initial mock of 'googleapis' from previous steps for callOpenAI tests,
// but we need a clear way to reference it. Assuming the googleapis mock is like:
// jest.mock('googleapis', () => {
//   const mockInsert = jest.fn();
//   return {
//     google: { calendar: jest.fn(() => ({ events: { insert: mockInsert } })) },
//     __mockEventsInsert: mockInsert, // Helper to access mockInsert
//   };
// });
// If not, we need to ensure the mock for googleapis exposes events.insert correctly.
// For now, let's assume the googleapis mock in the test file has a way to access `events.insert`.
// If the original googleapis mock was simpler, we might need to refine it.
// Let's assume `google.calendar().events.insert` is already a jest.fn() due to the global mock.
const mockGoogleEventsInsert = google.calendar('v3').events.insert;
describe('createGoogleEvent', () => {
    let getGoogleAPITokenSpy;
    const consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    beforeEach(() => {
        jest.clearAllMocks();
        getGoogleAPITokenSpy = jest.spyOn(apiHelperModule, 'getGoogleAPIToken');
        uuidv4.mockReturnValue('mock-uuid-1234'); // Predictable UUID
    });
    afterEach(() => {
        getGoogleAPITokenSpy.mockRestore();
        consoleLogSpy.mockRestore();
    });
    const basicEventDetails = {
        userId: 'user_test_id',
        calendarId: 'calendar_test_id',
        clientType: 'web',
        summary: 'Test Event Summary',
        startDateTime: '2024-03-10T10:00:00Z',
        endDateTime: '2024-03-10T11:00:00Z',
        timezone: 'America/New_York',
    };
    // Test Case 1: Successful basic event creation.
    it('should create an event successfully and return structured data', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_auth_token' });
        const mockGoogleEventResponse = {
            data: {
                id: 'google_event_id_123',
                summary: basicEventDetails.summary,
                // ... other event fields
            },
        };
        mockGoogleEventsInsert.mockResolvedValue(mockGoogleEventResponse);
        const result = await createGoogleEvent(basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType, basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime, basicEventDetails.timezone);
        expect(result.success).toBe(true);
        if (result.success) {
            expect(result.data.googleEventId).toBe('google_event_id_123');
            expect(result.data.calendarId).toBe(basicEventDetails.calendarId);
            expect(result.data.id).toBe(`google_event_id_123#${basicEventDetails.calendarId}`);
            expect(result.data.generatedId).toBe('mock-uuid-1234'); // Used for conference request
            expect(result.data.generatedEventId).toBe('mock-uuid-1234'.split('_')[0]);
        }
        expect(getGoogleAPITokenSpy).toHaveBeenCalledWith(basicEventDetails.userId, 'google_calendar');
        expect(mockGoogleEventsInsert).toHaveBeenCalledWith(
        // First argument: event creation parameters
        expect.objectContaining({
            calendarId: basicEventDetails.calendarId,
            conferenceDataVersion: 0, // As no conference solution was passed
            requestBody: expect.objectContaining({
                summary: basicEventDetails.summary,
                start: {
                    dateTime: basicEventDetails.startDateTime,
                    timeZone: basicEventDetails.timezone,
                },
                end: {
                    dateTime: basicEventDetails.endDateTime,
                    timeZone: basicEventDetails.timezone,
                },
            }),
        }), 
        // Second argument: request options, including timeout
        expect.objectContaining({
            timeout: 20000,
        }));
        // Original check for requestBody content for more specific validation if needed below,
        // but the above structure is more accurate for the actual call signature with options.
        /*
        expect(mockGoogleEventsInsert).toHaveBeenCalledWith({ // This was the old check, now part of the first arg above
          calendarId: basicEventDetails.calendarId,
          conferenceDataVersion: 0,
          requestBody: {
            summary: basicEventDetails.summary,
            description: undefined, // Not passed
            start: {
              dateTime: basicEventDetails.startDateTime,
              timeZone: basicEventDetails.timezone,
            },
            end: {
              dateTime: basicEventDetails.endDateTime,
              timeZone: basicEventDetails.timezone,
            },
            attendees: undefined, // Not passed
            reminders: { useDefault: true },
            // conferenceData would be undefined here
          },
        });
      });
    
      it('should create an event with conference data if specified', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_auth_token' });
        const mockGoogleEventResponse = { data: { id: 'google_event_conf_456' }};
        mockGoogleEventsInsert.mockResolvedValue(mockGoogleEventResponse);
        (uuidv4 as jest.Mock).mockReturnValue('conf-request-uuid');
    
    
        await createGoogleEvent(
          basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType,
          basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime,
          basicEventDetails.timezone, 'Test Description', [{email: 'test@example.com'}], 'eventHangout'
        );
    
        expect(mockGoogleEventsInsert).toHaveBeenCalledWith(expect.objectContaining({
            conferenceDataVersion: 1,
            requestBody: expect.objectContaining({
                conferenceData: {
                    createRequest: {
                        requestId: 'conf-request-uuid',
                        conferenceSolutionKey: { type: 'eventHangout' },
                    },
                },
                attendees: [{email: 'test@example.com'}],
                description: 'Test Description'
            })
        }));
      });
    
    
      // Test Case 2: getGoogleAPIToken fails.
      it('should return failure if getGoogleAPIToken fails', async () => {
        const tokenError = { message: 'Token fetch failed' };
        getGoogleAPITokenSpy.mockResolvedValue({ success: false, error: tokenError });
    
        const result = await createGoogleEvent(
          basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType,
          basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime,
          basicEventDetails.timezone
        );
    
        expect(result.success).toBe(false);
        if (!result.success) {
          expect(result.error.message).toContain('token acquisition failure');
          expect(result.error.details).toEqual(tokenError);
        }
        expect(mockGoogleEventsInsert).not.toHaveBeenCalled();
      });
    
      // Test Case 3: google.calendar().events.insert fails.
      it('should return failure if google.calendar.events.insert fails', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_auth_token' });
        const apiError = { code: 503, message: 'Service Unavailable' };
        // Simulate how googleapis library might throw an error (often has a 'response' or 'errors' property)
        const googleApiError = new Error('Service Unavailable');
        (googleApiError as any).code = 503;
        (googleApiError as any).errors = [{ message: 'Service Unavailable' }]; // Common pattern for googleapis errors
    
        mockGoogleEventsInsert.mockRejectedValue(googleApiError);
    
        const result = await createGoogleEvent(
          basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType,
          basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime,
          basicEventDetails.timezone
        );
    
        expect(result.success).toBe(false);
        if (!result.success) {
          expect(result.error.message).toContain('Failed to create Google Calendar event via API');
          // The details might vary based on how the actual error is structured by the googleapis library
          expect(result.error.details).toEqual( (googleApiError as any).errors );
        }
      });
       it('should return failure if google.calendar.events.insert does not return an event ID', async () => {
        getGoogleAPITokenSpy.mockResolvedValue({ success: true, token: 'dummy_auth_token' });
        const mockGoogleEventResponseNoId = {
          data: { summary: basicEventDetails.summary /* no id */ 
    });
});
mockGoogleEventsInsert.mockResolvedValue(mockGoogleEventResponseNoId);
const result = await createGoogleEvent(basicEventDetails.userId, basicEventDetails.calendarId, basicEventDetails.clientType, basicEventDetails.summary, basicEventDetails.startDateTime, basicEventDetails.endDateTime, basicEventDetails.timezone);
expect(result.success).toBe(false);
if (!result.success) {
    expect(result.error.message).toBe('Google Calendar API did not return an event ID.');
    expect(result.error.details).toEqual(mockGoogleEventResponseNoId.data);
}
;
;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLWhlbHBlci50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXBpLWhlbHBlci50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxjQUFjLENBQUMsQ0FBQyxxREFBcUQ7QUFDaEcsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBRTVCLHlCQUF5QjtBQUN6QixNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRTtRQUN2QyxPQUFPO1lBQ0wsSUFBSSxFQUFFO2dCQUNKLFdBQVcsRUFBRTtvQkFDWCxNQUFNLEVBQUUsVUFBVTtpQkFDbkI7YUFDRjtTQUNGLENBQUM7SUFDSixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDO0FBRUgsc0RBQXNEO0FBQ3RELE9BQU8sRUFDSCxvQkFBb0IsRUFDcEIsbUNBQW1DLEVBQ25DLDZCQUE2QixFQUNoQyxNQUFNLGNBQWMsQ0FBQztBQUN0Qix3R0FBd0c7QUFDeEcsb0VBQW9FO0FBRXBFLFFBQVEsQ0FBQyxtQ0FBbUMsRUFBRSxHQUFHLEVBQUU7SUFDL0MsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUM7SUFFckMsU0FBUyxDQUFDLEdBQUcsRUFBRTtRQUNYLHlFQUF5RTtRQUN6RSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDdkQsQ0FBQyxDQUFDLENBQUM7SUFFSCxRQUFRLENBQUMsR0FBRyxFQUFFO1FBQ1YsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLEdBQUcsYUFBYSxDQUFDLENB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Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dFQWlHd0Q7SUFBQyxDQUFDLENBQUMsQ0FBQTtBQUMzRCxDQUFDLENBQUEsQ0FBQztBQUNGLHNCQUFzQixDQUFDLGlCQUFpQixDQUFDLDJCQUEyQixDQUFDLENBQUM7QUFFdEUsTUFBTSxNQUFNLEdBQUcsTUFBTSxpQkFBaUIsQ0FDcEMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLGlCQUFpQixDQUFDLFVBQVUsRUFBRSxpQkFBaUIsQ0FBQyxVQUFVLEVBQ3BGLGlCQUFpQixDQUFDLE9BQU8sRUFBRSxpQkFBaUIsQ0FBQyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsV0FBVyxFQUN6RixpQkFBaUIsQ0FBQyxRQUFRLENBQzNCLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3BCLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxpREFBaUQsQ0FBQyxDQUFDO0lBQ3JGLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQywyQkFBMkIsQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUN6RSxDQUFDO0FBQ0QsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjYWxsT3BlbkFJIH0gZnJvbSAnLi9hcGktaGVscGVyJzsgLy8gQXNzdW1pbmcgY2FsbE9wZW5BSSBpcyBleHBvcnRlZCBmcm9tIGFwaS1oZWxwZXIudHNcbmltcG9ydCBPcGVuQUkgZnJvbSAnb3BlbmFpJztcblxuLy8gTW9jayB0aGUgT3BlbkFJIGNsaWVudFxuY29uc3QgbW9ja0NyZWF0ZSA9IGplc3QuZm4oKTtcbmplc3QubW9jaygnb3BlbmFpJywgKCkgPT4ge1xuICByZXR1cm4gamVzdC5mbigpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXQ6IHtcbiAgICAgICAgY29tcGxldGlvbnM6IHtcbiAgICAgICAgICBjcmVhdGU6IG1vY2tDcmVhdGUsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH07XG4gIH0pO1xufSk7XG5cbi8vIC0tLSBUZXN0cyBmb3IgQXZhaWxhYmlsaXR5IEdlbmVyYXRpb24gRnVuY3Rpb25zIC0tLVxuaW1wb3J0IHtcbiAgICBnZW5lcmF0ZUF2YWlsYWJpbGl0eSxcbiAgICBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzZm9yVGltZVdpbmRvdyxcbiAgICBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzRm9yRGF0ZVxufSBmcm9tICcuL2FwaS1oZWxwZXInO1xuLy8gU3BpZXMgZm9yIGFwaUhlbHBlck1vZHVsZSBmdW5jdGlvbnMgKGdldFVzZXJQcmVmZXJlbmNlcywgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzKSB3aWxsIGJlIHNldCB1cC5cbi8vIGRheWpzIGlzIHVzZWQgZXh0ZW5zaXZlbHk7IGplc3QudXNlRmFrZVRpbWVycygpIHdpbGwgYmUgZW1wbG95ZWQuXG5cbmRlc2NyaWJlKCdBdmFpbGFiaWxpdHkgR2VuZXJhdGlvbiBGdW5jdGlvbnMnLCAoKSA9PiB7XG4gICAgY29uc3Qgb3JpZ2luYWxHdWVzcyA9IGRheWpzLnR6Lmd1ZXNzO1xuXG4gICAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAgICAgLy8gTW9jayBkYXlqcy50ei5ndWVzcyB0byBlbnN1cmUgdGVzdHMgYXJlIGNvbnNpc3RlbnQgYWNyb3NzIGVudmlyb25tZW50c1xuICAgICAgICBkYXlqcy50ei5ndWVzcyA9IGplc3QuZm4oKCkgPT4gJ0FtZXJpY2EvTmV3X1lvcmsnKTtcbiAgICB9KTtcblxuICAgIGFmdGVyQWxsKCgpID0+IHtcbiAgICAgICAgZGF5anMudHouZ3Vlc3MgPSBvcmlnaW5hbEd1ZXNzOyAvLyBSZXN0b3JlIG9yaWdpbmFsIGd1ZXNzIGZ1bmN0aW9uXG4gICAgfSk7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgIGplc3QudXNlRmFrZVRpbWVycygpOyAvLyBFbmFibGUgZmFrZSB0aW1lcnMgZm9yIGVhY2ggdGVzdFxuICAgICAgICAvLyBTZXQgYSBjb25zaXN0ZW50IHN5c3RlbSB0aW1lIGZvciBhbGwgdGVzdHMgaW4gdGhpcyBkZXNjcmliZSBibG9jayBpZiBuZWVkZWQsIGUuZy4sXG4gICAgICAgIC8vIGplc3Quc2V0U3lzdGVtVGltZShuZXcgRGF0ZSgnMjAyNC0wOC0wMVQwMDowMDowMFonKSk7XG4gICAgICAgIC8vIEhvd2V2ZXIsIHNwZWNpZmljIHRpbWVzIHdpbGwgYmUgc2V0IGluIHRlc3RzIGZvciBtb3JlIGNvbnRyb2wuXG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LnVzZVJlYWxUaW1lcnMoKTsgLy8gUmVzdG9yZSByZWFsIHRpbWVyc1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2dlbmVyYXRlQXZhaWxhYmxlU2xvdHNGb3JEYXRlJywgKCkgPT4ge1xuICAgICAgICBjb25zdCBiYXNlRGF0ZSA9ICcyMDI0LTA4LTE1JzsgLy8gVGh1cnNkYXlcbiAgICAgICAgY29uc3Qgc2VuZGVyVGltZXpvbmUgPSAnQW1lcmljYS9OZXdfWW9yayc7IC8vIFVzZXIncyBvd24gVFogd2hlcmUgd29yayBob3VycyBhcmUgZGVmaW5lZFxuICAgICAgICBjb25zdCByZWNlaXZlclRpbWV6b25lID0gJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnOyAvLyBUWiBmb3Igd2hpY2ggc2xvdHMgYXJlIGJlaW5nIGdlbmVyYXRlZCBmb3IgZGlzcGxheVxuXG4gICAgICAgIGNvbnN0IHNlbmRlclByZWZlcmVuY2VzQmFzZSA9IHtcbiAgICAgICAgICAgIGlkOiAncHJlZjEnLCB1c2VySWQ6ICd1c2VyMScsXG4gICAgICAgICAgICB3b3JrSG91cnNTdGFydFRpbWU6ICcwOTowMCcsIC8vIDkgQU0gaW4gc2VuZGVyVGltZXpvbmVcbiAgICAgICAgICAgIHdvcmtIb3Vyc0VuZFRpbWU6ICcxNzowMCcsICAgLy8gNSBQTSBpbiBzZW5kZXJUaW1lem9uZVxuICAgICAgICAgICAgd29ya0RheXM6IFsxLCAyLCAzLCA0LCA1XSwgLy8gTW9uLUZyaVxuICAgICAgICAgICAgc2xvdER1cmF0aW9uOiAzMCwgICAgICAgICAgLy8gbWludXRlc1xuICAgICAgICAgICAgYnVmZmVyQmV0d2Vlbk1lZXRpbmdzOiAxNSwgLy8gbWludXRlc1xuICAgICAgICAgICAgdGltZXpvbmU6IHNlbmRlclRpbWV6b25lLFxuICAgICAgICB9O1xuXG4gICAgICAgIGl0KCdzaG91bGQgZ2VuZXJhdGUgYmFzaWMgc2xvdHMgZm9yIGEgZnVsbCBkYXkgd2l0aCBubyBleGlzdGluZyBldmVudHMnLCAoKSA9PiB7XG4gICAgICAgICAgICBqZXN0LnNldFN5c3RlbVRpbWUobmV3IERhdGUoYCR7YmFzZURhdGV9VDAwOjAwOjAwWmApKTsgLy8gSXJyZWxldmFudCBoZXJlLCBidXQgZ29vZCBwcmFjdGljZVxuICAgICAgICAgICAgY29uc3Qgc2xvdHMgPSBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzRm9yRGF0ZShiYXNlRGF0ZSwgc2VuZGVyUHJlZmVyZW5jZXNCYXNlLCBbXSwgcmVjZWl2ZXJUaW1lem9uZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIEV4cGVjdGVkOiA5OjAwLCA5OjQ1LCAxMDozMCwgMTE6MTUsIDEyOjAwLCAxMjo0NSAoc2tpcCBsdW5jaCBpZiBhbnkpLCAxOjMwLCAyOjE1LCAzOjAwLCAzOjQ1LCA0OjMwIChlbmRzIDU6MDApXG4gICAgICAgICAgICAvLyBUb3RhbCAxMSBzbG90cyAoOTowMC05OjMwLCA5OjQ1LTEwOjE1IC4uLiA0OjMwLTU6MDApXG4gICAgICAgICAgICBleHBlY3Qoc2xvdHMubGVuZ3RoKS50b0JlKDExKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IHNsb3QgKDk6MDAgQU0gTlkgLT4gSVNPIHN0cmluZylcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0U2xvdFN0YXJ0RXhwZWN0ZWQgPSBkYXlqcy50eihgJHtiYXNlRGF0ZX0gMDk6MDBgLCAnWVlZWS1NTS1ERCBISDptbScsIHNlbmRlclRpbWV6b25lKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgZXhwZWN0KHNsb3RzWzBdLnN0YXJ0RGF0ZSkudG9CZShmaXJzdFNsb3RTdGFydEV4cGVjdGVkKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBleGNsdWRlIGV4aXN0aW5nIGV2ZW50cyAobm90QXZhaWxhYmxlU2xvdHNJbkV2ZW50VGltZXpvbmUpJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBbIC8vIFRoZXNlIHRpbWVzIGFyZSBpbiByZWNlaXZlclRpbWV6b25lIChMQSlcbiAgICAgICAgICAgICAgICB7IHN0YXJ0RGF0ZTogZGF5anMudHooYCR7YmFzZURhdGV9IDEwOjAwYCwgJ1lZWVktTU0tREQgSEg6bW0nLCByZWNlaXZlclRpbWV6b25lKS50b0lTT1N0cmluZygpLCBlbmREYXRlOiBkYXlqcy50eihgJHtiYXNlRGF0ZX0gMTA6MzBgLCAnWVlZWS1NTS1ERCBISDptbScsIHJlY2VpdmVyVGltZXpvbmUpLnRvSVNPU3RyaW5nKCkgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIDk6MDAgQU0gTlkgaXMgNjowMCBBTSBMQS4gNTowMCBQTSBOWSBpcyAyOjAwIFBNIExBLlxuICAgICAgICAgICAgLy8gU2VuZGVyIHdvcmsgaG91cnMgaW4gTEEgdGltZTogNiBBTSAtIDIgUE0uXG4gICAgICAgICAgICAvLyBJZiByZWNlaXZlciBpcyBMQSwgYW5kIHNlbmRlciBpcyBOWSwgc2xvdHMgYXJlIGdlbmVyYXRlZCBiYXNlZCBvbiBOWSB3b3JrIGhvdXJzLCB0aGVuIGRpc3BsYXllZCBpbiBMQSB0aW1lLlxuICAgICAgICAgICAgLy8gVGhlIG5vdEF2YWlsYWJsZVNsb3RzIGFyZSBhbHJlYWR5IGluIGV2ZW50J3MgdGFyZ2V0IHRpbWV6b25lIChyZWNlaXZlclRpbWV6b25lKS5cblxuICAgICAgICAgICAgLy8gUmVjYWxjdWxhdGUgZXhwZWN0ZWQgc2xvdHMgYmFzZWQgb24gaG93IGBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzRm9yRGF0ZWAgY29udmVydHMgZm9yIGNvbXBhcmlzb25cbiAgICAgICAgICAgIC8vIFNlbmRlcidzIDlBTSBOWSBpcyA2QU0gTEEuIFNlbmRlcidzIDVQTSBOWSBpcyAyUE0gTEEuXG4gICAgICAgICAgICAvLyBTbG90IDEgKE5ZKTogOTowMC05OjMwIC0+IExBOiA2OjAwLTY6MzAgKE9LKVxuICAgICAgICAgICAgLy8gU2xvdCAyIChOWSk6IDk6NDUtMTA6MTUgLT4gTEE6IDY6NDUtNzoxNSAoT0spXG4gICAgICAgICAgICAvLyAuLi5cbiAgICAgICAgICAgIC8vIExldCdzIGFzc3VtZSBvbmUgb2YgdGhlIGdlbmVyYXRlZCBzbG90cyAoY29udmVydGVkIHRvIExBIHRpbWUpIHdvdWxkIGJlIDEwOjAwIExBIC0gMTA6MzAgTEEuIFRoaXMgb25lIHNob3VsZCBiZSBleGNsdWRlZC5cbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBjb2RlIGNvbXBhcmVzIGN1cnJlbnRTbG90U3RhcnRJblJlY2VpdmVyVHogd2l0aCBidXN5U3RhcnQoYWxyZWFkeSBpbiByZWNlaXZlclR6KVxuXG4gICAgICAgICAgICBjb25zdCBzbG90cyA9IGdlbmVyYXRlQXZhaWxhYmxlU2xvdHNGb3JEYXRlKGJhc2VEYXRlLCBzZW5kZXJQcmVmZXJlbmNlc0Jhc2UsIGV4aXN0aW5nRXZlbnRzLCByZWNlaXZlclRpbWV6b25lLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgLy8gT3JpZ2luYWwgMTEgc2xvdHMuIE9uZSAzMC1taW4gc2xvdCAoMTA6MDAtMTA6MzAgTEEpIHJlbW92ZWQuXG4gICAgICAgICAgICAvLyBUaGUgc2xvdCB0aGF0IHdvdWxkIGJlIDEwOjAwLTEwOjMwIExBIGNvcnJlc3BvbmRzIHRvIDE6MDAtMTozMCBQTSBOWS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgY29tcGxleC4gTGV0J3Mgc2ltcGxpZnk6IGlmIGEgc2xvdCBnZW5lcmF0ZWQgYmFzZWQgb24gTlkgd29yayBob3Vycywgd2hlbiBjb252ZXJ0ZWQgdG8gTEEgdGltZSxcbiAgICAgICAgICAgIC8vIG92ZXJsYXBzIHdpdGggYW4gZXhpc3RpbmcgTEEgZXZlbnQsIGl0J3MgZXhjbHVkZWQuXG4gICAgICAgICAgICAvLyAxOjAwIFBNIE5ZIGlzIDEwOjAwIEFNIExBLiBTbyB0aGUgMTowMCBQTSAtIDE6MzAgUE0gTlkgc2xvdCBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgICAgICAgIC8vIE9yaWdpbmFsIHNsb3RzOiA5OjAwLCA5OjQ1LCAxMDozMCwgMTE6MTUsIDEyOjAwLCAxMjo0NSwgKjE6MzAgKE5ZKSosIDI6MTUsIDM6MDAsIDM6NDUsIDQ6MzBcbiAgICAgICAgICAgIC8vIFRoZSAxOjMwIFBNIE5ZIHNsb3QgKDEwOjMwIEFNIExBKSBzaG91bGQgYmUgZmluZS4gVGhlIDEyOjQ1IFBNIE5ZICg5OjQ1IEFNIExBKSBzbG90IHNob3VsZCBiZSBmaW5lLlxuICAgICAgICAgICAgLy8gVGhlIGNvbmZsaWN0aW5nIHNsb3QgaXMgdGhlIG9uZSB0aGF0ICppcyogMTA6MDAtMTA6MzAgQU0gTEEuIFRoaXMgaXMgMTowMCBQTSAtIDE6MzAgUE0gTlkuXG4gICAgICAgICAgICAvLyBTbywgMTAgc2xvdHMgc2hvdWxkIHJlbWFpbi5cbiAgICAgICAgICAgIGV4cGVjdChzbG90cy5sZW5ndGgpLnRvQmUoMTApO1xuICAgICAgICAgICAgY29uc3QgdGVuQW1MYUNvbmZsaWN0SVNPID0gZGF5anMudHooYCR7YmFzZURhdGV9IDEwOjAwYCwgJ1lZWVktTU0tREQgSEg6bW0nLCByZWNlaXZlclRpbWV6b25lKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgZXhwZWN0KHNsb3RzLmZpbmQocyA9PiBkYXlqcyhzLnN0YXJ0RGF0ZSkudHoocmVjZWl2ZXJUaW1lem9uZSkudG9JU09TdHJpbmcoKSA9PT0gdGVuQW1MYUNvbmZsaWN0SVNPKSkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJlc3BlY3QgaXNGaXJzdERheSB3aW5kb3dTdGFydFRpbWUnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBXaW5kb3cgc3RhcnRzIGF0IDE6MDAgUE0gTEEgdGltZSBvbiB0aGUgZmlyc3QgZGF5LiBTZW5kZXIgaXMgTlkuXG4gICAgICAgICAgICAvLyAxOjAwIFBNIExBIGlzIDQ6MDAgUE0gTlkuIFNlbmRlciB3b3JrcyA5IEFNIC0gNSBQTSBOWS5cbiAgICAgICAgICAgIC8vIFNvLCBhdmFpbGFibGUgc2xvdHMgZm9yIHRoaXMgZGF5IHNob3VsZCBvbmx5IGJlIGZyb20gNDowMCBQTSBOWSBvbndhcmRzLlxuICAgICAgICAgICAgLy8gNDowMC00OjMwLCA0OjQ1LTU6MTUgKG9vcHMsIGJ1ZmZlciBtZWFucyA0OjMwIGlzIGxhc3QpIC0+IFNvLCA0OjAwLTQ6MzAgUE0gTllcbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gZ2VuZXJhdGVBdmFpbGFibGVTbG90c0ZvckRhdGUoYmFzZURhdGUsIHNlbmRlclByZWZlcmVuY2VzQmFzZSwgW10sIHJlY2VpdmVyVGltZXpvbmUsIHRydWUsIGZhbHNlLCAnMTM6MDAnKTtcbiAgICAgICAgICAgIGV4cGVjdChzbG90cy5sZW5ndGgpLnRvQmUoMik7IC8vIDQ6MDAtNDozMCwgNDo0NS01OjE1IChOWSB0aW1lKSBpcyB3cm9uZywgYnVmZmVyIGlzIDE1LiA0OjAwLTQ6MzAsIHRoZW4gNDozMCsxNSszMCA9IDU6MTUuIFNvIG9ubHkgNDowMC00OjMwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gNDowMCB0byA0OjMwLiBuZXh0IGlzIDQ6MzAgKyAxNSBidWZmZXIgPSA0OjQ1LiA0OjQ1ICsgMzAgPSA1OjE1LiA1OjE1IGlzIE5PVCA8PSA1OjAwIGRheUVuZC4gU28gb25seSBvbmUgc2xvdC5cbiAgICAgICAgICAgIGV4cGVjdChzbG90cy5sZW5ndGgpLnRvQmUoMSk7XG4gICAgICAgICAgICBleHBlY3Qoc2xvdHNbMF0uc3RhcnREYXRlKS50b0JlKGRheWpzLnR6KGAke2Jhc2VEYXRlfSAxNjowMGAsICdZWVlZLU1NLUREIEhIOm1tJywgc2VuZGVyVGltZXpvbmUpLnRvSVNPU3RyaW5nKCkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJlc3BlY3QgaXNMYXN0RGF5IHdpbmRvd0VuZFRpbWUnLCAoKSA9PiB7XG4gICAgICAgICAgICAvLyBXaW5kb3cgZW5kcyBhdCAxMDowMCBBTSBMQSB0aW1lLiBTZW5kZXIgaXMgTlkuXG4gICAgICAgICAgICAvLyAxMDowMCBBTSBMQSBpcyAxOjAwIFBNIE5ZLiBTZW5kZXIgd29ya3MgOSBBTSAtIDUgUE0gTlkuXG4gICAgICAgICAgICAvLyBTbG90cyBzaG91bGQgYmUgZnJvbSA5OjAwIEFNIE5ZIHVwIHRvIDE6MDAgUE0gTlkuXG4gICAgICAgICAgICAvLyA5OjAwLCA5OjQ1LCAxMDozMCwgMTE6MTUsIDEyOjAwLCAxMjo0NSAoZW5kcyAxOjE1IFBNIC0gdG9vIGxhdGUpXG4gICAgICAgICAgICAvLyA5OjAwLTk6MzAsIDk6NDUtMTA6MTUsIDEwOjMwLTExOjAwLCAxMToxNS0xMTo0NSwgMTI6MDAtMTI6MzAuICg1IHNsb3RzKVxuICAgICAgICAgICAgLy8gTmV4dCBvbmUgc3RhcnRzIDEyOjMwICsgMTUgYnVmZmVyID0gMTI6NDUuIDEyOjQ1KzMwID0gMToxNS4gMToxNSBpcyBOT1QgPD0gMTowMC5cbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gZ2VuZXJhdGVBdmFpbGFibGVTbG90c0ZvckRhdGUoYmFzZURhdGUsIHNlbmRlclByZWZlcmVuY2VzQmFzZSwgW10sIHJlY2VpdmVyVGltZXpvbmUsIGZhbHNlLCB0cnVlLCB1bmRlZmluZWQsICcxMDowMCcpO1xuICAgICAgICAgICAgZXhwZWN0KHNsb3RzLmxlbmd0aCkudG9CZSg1KTtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RTbG90RW5kRXhwZWN0ZWQgPSBkYXlqcy50eihgJHtiYXNlRGF0ZX0gMTI6MzBgLCAnWVlZWS1NTS1ERCBISDptbScsIHNlbmRlclRpbWV6b25lKS5hZGQoc2VuZGVyUHJlZmVyZW5jZXNCYXNlLnNsb3REdXJhdGlvbiwgJ21pbnV0ZXMnKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgIC8vIGxhc3Qgc2xvdCBpcyAxMjowMCAtIDEyOjMwIE5ZXG4gICAgICAgICAgICBleHBlY3Qoc2xvdHNbc2xvdHMubGVuZ3RoIC0gMV0uZW5kRGF0ZSkudG9CZShkYXlqcy50eihgJHtiYXNlRGF0ZX0gMTI6MzBgLCAnWVlZWS1NTS1ERCBISDptbScsIHNlbmRlclRpbWV6b25lKS50b0lTT1N0cmluZygpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZW1wdHkgYXJyYXkgaWYgd2luZG93IGlzIG91dHNpZGUgd29yayBob3VycycsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNsb3RzID0gZ2VuZXJhdGVBdmFpbGFibGVTbG90c0ZvckRhdGUoYmFzZURhdGUsIHNlbmRlclByZWZlcmVuY2VzQmFzZSwgW10sIHJlY2VpdmVyVGltZXpvbmUsIHRydWUsIHRydWUsICcxODowMCcsICcxOTowMCcpOyAvLyA2IFBNIC0gNyBQTSBMQSAoOSBQTSAtIDEwIFBNIE5ZKVxuICAgICAgICAgICAgZXhwZWN0KHNsb3RzKS50b0VxdWFsKFtdKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2VuZXJhdGVBdmFpbGFibGVTbG90c2ZvclRpbWVXaW5kb3cnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlbmRlclByZWZzID0geyBpZDoncDEnLCB1c2VySWQ6J3UxJywgd29ya0hvdXJzU3RhcnRUaW1lOiAnMDk6MDAnLCB3b3JrSG91cnNFbmRUaW1lOiAnMTI6MDAnLCB3b3JrRGF5czogWzEsMiwzLDQsNV0sIHNsb3REdXJhdGlvbjogNjAsIGJ1ZmZlckJldHdlZW5NZWV0aW5nczogMCwgdGltZXpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyB9O1xuXG4gICAgICAgIGl0KCdzaG91bGQgY2FsbCBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzRm9yRGF0ZSBmb3IgZWFjaCBkYXkgaW4gYSBtdWx0aS1kYXkgd2luZG93JywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRm9yIHRoaXMgdGVzdCwgd2UgZG9uJ3QgbmVlZCB0byBtb2NrIGdlbmVyYXRlQXZhaWxhYmxlU2xvdHNGb3JEYXRlIGl0c2VsZiwgYnV0IHJhdGhlciBjaGVjayBpdHMgdXNhZ2UuXG4gICAgICAgICAgICAvLyBIb3dldmVyLCB0byBjb250cm9sIGl0cyBvdXRwdXQgZm9yIGFnZ3JlZ2F0aW9uLCBtb2NraW5nIGl0IGlzIGJldHRlci5cbiAgICAgICAgICAgIGNvbnN0IG1vY2tEYWlseVNsb3RzID0gW3tzdGFydERhdGU6ICdzbG90MV9zdGFydCcsIGVuZERhdGU6ICdzbG90MV9lbmQnfV07XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzRm9yRGF0ZVNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2VuZXJhdGVBdmFpbGFibGVTbG90c0ZvckRhdGUnKS5tb2NrUmV0dXJuVmFsdWUobW9ja0RhaWx5U2xvdHMpO1xuXG4gICAgICAgICAgICBjb25zdCBzdGFydERhdGUgPSAnMjAyNC0wOC0xOSc7IC8vIE1vbmRheVxuICAgICAgICAgICAgY29uc3QgZW5kRGF0ZSA9ICcyMDI0LTA4LTIwJzsgICAvLyBUdWVzZGF5XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzZm9yVGltZVdpbmRvdyhzdGFydERhdGUsIGVuZERhdGUsIHNlbmRlclByZWZzLCBbXSwgJ0FtZXJpY2EvTmV3X1lvcmsnKTtcblxuICAgICAgICAgICAgZXhwZWN0KGdlbmVyYXRlQXZhaWxhYmxlU2xvdHNGb3JEYXRlU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7IC8vIE1vbiwgVHVlXG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmF2YWlsYWJsZVNsb3RzLmxlbmd0aCkudG9CZSgyICogbW9ja0RhaWx5U2xvdHMubGVuZ3RoKTsgLy8gQWdncmVnYXRlZFxuICAgICAgICAgICAgZ2VuZXJhdGVBdmFpbGFibGVTbG90c0ZvckRhdGVTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnZ2VuZXJhdGVBdmFpbGFiaWxpdHknLCAoKSA9PiB7XG4gICAgICAgIGxldCBsaXN0RXZlbnRzU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgICAgICBsZXQgZ2V0VXNlclByZWZzU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgICAgICAvLyBnZW5lcmF0ZUF2YWlsYWJsZVNsb3RzZm9yVGltZVdpbmRvdyBpcyBub3Qgc3BpZWQgYXMgaXQncyBtb3N0bHkgb3JjaGVzdHJhdGluZyB0aGUgZGF0ZSBpdGVyYXRpb24uXG4gICAgICAgIC8vIEl0cyBjb3JlIGxvZ2ljIGlzIGluIGdlbmVyYXRlQXZhaWxhYmxlU2xvdHNGb3JEYXRlIHdoaWNoIGlzIHRlc3RlZCBhYm92ZS5cblxuICAgICAgICBjb25zdCBiYXNlUGFyYW1zID0ge1xuICAgICAgICAgICAgdXNlcklkOiAndXNlcl9hdmFpbF90ZXN0JyxcbiAgICAgICAgICAgIGF2YWlsYWJpbGl0eVNjYW5TdGFydERhdGU6ICcyMDI0LTA4LTE5JywgLy8gTW9uZGF5XG4gICAgICAgICAgICBhdmFpbGFiaWxpdHlTY2FuRW5kRGF0ZTogJzIwMjQtMDgtMjAnLCAgIC8vIFR1ZXNkYXlcbiAgICAgICAgICAgIHJlY2VpdmVyR2VuZXJhdGVkVGltZXpvbmU6ICdBbWVyaWNhL0xvc19BbmdlbGVzJyxcbiAgICAgICAgICAgIC8vIGNsaWVudFR5cGU6ICd3ZWInIC8vIE5vdCB1c2VkIGJ5IGN1cnJlbnQgZ2VuZXJhdGVBdmFpbGFiaWxpdHkgc2lnbmF0dXJlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1vY2tVc2VyUHJlZnMgPSB7IGlkOidwcmVmMScsIHVzZXJJZDogYmFzZVBhcmFtcy51c2VySWQsIHdvcmtIb3Vyc1N0YXJ0VGltZTogJzA5OjAwJywgd29ya0hvdXJzRW5kVGltZTogJzE3OjAwJywgd29ya0RheXM6IFsxLDIsMyw0LDVdLCBzbG90RHVyYXRpb246IDMwLCBidWZmZXJCZXR3ZWVuTWVldGluZ3M6IDE1LCB0aW1lem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnIH07XG5cbiAgICAgICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBsaXN0RXZlbnRzU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXMnKTtcbiAgICAgICAgICAgIGdldFVzZXJQcmVmc1NweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0VXNlclByZWZlcmVuY2VzJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3M6dHJ1ZSB3aXRoIHNsb3RzIHdoZW4gYWxsIGhlbHBlcnMgc3VjY2VlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGdldFVzZXJQcmVmc1NweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tVc2VyUHJlZnMgfSk7XG4gICAgICAgICAgICBsaXN0RXZlbnRzU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogW10gfSk7IC8vIE5vIGV4aXN0aW5nIGV2ZW50c1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZUF2YWlsYWJpbGl0eShiYXNlUGFyYW1zLnVzZXJJZCwgYmFzZVBhcmFtcy5hdmFpbGFiaWxpdHlTY2FuU3RhcnREYXRlLCBiYXNlUGFyYW1zLmF2YWlsYWJpbGl0eVNjYW5FbmREYXRlLCBiYXNlUGFyYW1zLnJlY2VpdmVyR2VuZXJhdGVkVGltZXpvbmUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlSW5zdGFuY2VPZihBcnJheSk7XG4gICAgICAgICAgICAvLyBFeHBlY3Qgc29tZSBzbG90cyAoMTEgc2xvdHMgcGVyIGRheSBmb3IgMiBkYXlzID0gMjIgc2xvdHMpXG4gICAgICAgICAgICAvLyBUaGlzIHJlbGllcyBvbiB0aGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIG9mIGdlbmVyYXRlQXZhaWxhYmxlU2xvdHNGb3JEYXRlLlxuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhPy5sZW5ndGgpLnRvQmUoMjIpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIGlmIGdldFVzZXJQcmVmZXJlbmNlcyBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZWZzRXJyb3IgPSB7IG1lc3NhZ2U6IFwiREIgZXJyb3IgcHJlZnNcIiB9O1xuICAgICAgICAgICAgZ2V0VXNlclByZWZzU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBwcmVmc0Vycm9yIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVBdmFpbGFiaWxpdHkoYmFzZVBhcmFtcy51c2VySWQsIGJhc2VQYXJhbXMuYXZhaWxhYmlsaXR5U2NhblN0YXJ0RGF0ZSwgYmFzZVBhcmFtcy5hdmFpbGFiaWxpdHlTY2FuRW5kRGF0ZSwgYmFzZVBhcmFtcy5yZWNlaXZlckdlbmVyYXRlZFRpbWV6b25lKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIGdldCB1c2VyIHByZWZlcmVuY2VzJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKHByZWZzRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIGlmIGdldFVzZXJQcmVmZXJlbmNlcyByZXR1cm5zIG5vIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBnZXRVc2VyUHJlZnNTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZW5lcmF0ZUF2YWlsYWJpbGl0eShiYXNlUGFyYW1zLnVzZXJJZCwgYmFzZVBhcmFtcy5hdmFpbGFiaWxpdHlTY2FuU3RhcnREYXRlLCBiYXNlUGFyYW1zLmF2YWlsYWJpbGl0eVNjYW5FbmREYXRlLCBiYXNlUGFyYW1zLnJlY2VpdmVyR2VuZXJhdGVkVGltZXpvbmUpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnVXNlciBwcmVmZXJlbmNlcyBub3QgZm91bmQsIGNhbm5vdCBnZW5lcmF0ZSBhdmFpbGFiaWxpdHkuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgaWYgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgZ2V0VXNlclByZWZzU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja1VzZXJQcmVmcyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50c0Vycm9yID0geyBtZXNzYWdlOiBcIkRCIGVycm9yIGV2ZW50cyBsaXN0XCIgfTtcbiAgICAgICAgICAgIGxpc3RFdmVudHNTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGV2ZW50c0Vycm9yIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VuZXJhdGVBdmFpbGFiaWxpdHkoYmFzZVBhcmFtcy51c2VySWQsIGJhc2VQYXJhbXMuYXZhaWxhYmlsaXR5U2NhblN0YXJ0RGF0ZSwgYmFzZVBhcmFtcy5hdmFpbGFiaWxpdHlTY2FuRW5kRGF0ZSwgYmFzZVBhcmFtcy5yZWNlaXZlckdlbmVyYXRlZFRpbWV6b25lKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIGxpc3QgZXhpc3RpbmcgZXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGV2ZW50c0Vycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBzdWNjZWVkIGV2ZW4gaWYgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzIHJldHVybnMgZW1wdHkgYXJyYXknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBnZXRVc2VyUHJlZnNTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrVXNlclByZWZzIH0pO1xuICAgICAgICAgICAgbGlzdEV2ZW50c1NweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IFtdIH0pOyAvLyBObyBleGlzdGluZyBldmVudHNcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdlbmVyYXRlQXZhaWxhYmlsaXR5KGJhc2VQYXJhbXMudXNlcklkLCBiYXNlUGFyYW1zLmF2YWlsYWJpbGl0eVNjYW5TdGFydERhdGUsIGJhc2VQYXJhbXMuYXZhaWxhYmlsaXR5U2NhbkVuZERhdGUsIGJhc2VQYXJhbXMucmVjZWl2ZXJHZW5lcmF0ZWRUaW1lem9uZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmVJbnN0YW5jZU9mKEFycmF5KTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZGF0YT8ubGVuZ3RoKS50b0JlKDIyKTsgLy8gRnVsbCBhdmFpbGFiaWxpdHlcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuLy8gLS0tIFVuaXQgVGVzdHMgZm9yIGNyZWF0ZUdvb2dsZUV2ZW50IChSZWZhY3RvcmVkKSAtLS1cbi8vIE5vdGU6IFRoZXNlIHRlc3RzIHdpbGwgbmVlZCBhZGp1c3RtZW50IGJhc2VkIG9uIHRoZSBuZXcgc2lnbmF0dXJlIG9mIGNyZWF0ZUdvb2dsZUV2ZW50XG4vLyB3aGljaCBub3cgdGFrZXMgYW4gZXZlbnRPcHRpb25zIG9iamVjdC5cblxuLy8gQXNzdW1pbmcgZ29vZ2xlLmNhbGVuZGFyKCkuZXZlbnRzLmluc2VydCBpcyBhbHJlYWR5IG1vY2tlZCB2aWEgdGhlIGdsb2JhbCBnb29nbGVhcGlzIG1vY2suXG4vLyBjb25zdCBtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0ID0gKGdvb2dsZS5jYWxlbmRhcigndjMnKSBhcyBhbnkpLmV2ZW50cy5pbnNlcnQgYXMgamVzdC5Nb2NrO1xuLy8gVGhpcyB3YXMgZGVmaW5lZCBpbiBhIHByZXZpb3VzIHN0ZXAgZm9yIGNyZWF0ZUdvb2dsZUV2ZW50IHRlc3RzLCBlbnN1cmUgaXQncyBzdGlsbCB2YWxpZC9hY2Nlc3NpYmxlLlxuXG5kZXNjcmliZSgnY3JlYXRlR29vZ2xlRXZlbnQgKFJlZmFjdG9yZWQgd2l0aCBDcmVhdGVHb29nbGVFdmVudE9wdGlvbnMpJywgKCkgPT4ge1xuICAgIGxldCBnZXRHb29nbGVBUElUb2tlblNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBjb25zdCBjb25zb2xlTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgICBjb25zdCBtb2NrR2VuZXJhdGVkSWQgPSAnbW9jay11dWlkLWZvci1jb25mZXJlbmNlJztcblxuICAgIC8vIFJlLWFjY2Vzc2luZyB0aGUgbW9jayBmb3IgZ29vZ2xlLmNhbGVuZGFyKCkuZXZlbnRzLmluc2VydFxuICAgIC8vIFRoaXMgcmVsaWVzIG9uIHRoZSBnbG9iYWwgbW9jayBzdHJ1Y3R1cmUgZm9yICdnb29nbGVhcGlzJ1xuICAgIGxldCBtb2NrRXZlbnRzSW5zZXJ0OiBqZXN0Lk1vY2s7XG4gICAgYmVmb3JlQWxsKCgpID0+IHtcbiAgICAgICAgLy8gRW5zdXJlIHRoZSBnb29nbGVhcGlzIG1vY2sgaXMgc2V0IHVwIHRvIHByb3ZpZGUgYSBtb2NrIGZvciBldmVudHMuaW5zZXJ0XG4gICAgICAgIC8vIFRoaXMgbWlnaHQgbmVlZCB0byBiZSBtb3JlIHJvYnVzdCBkZXBlbmRpbmcgb24gaG93IHRoZSBnbG9iYWwgbW9jayBpcyBzdHJ1Y3R1cmVkLlxuICAgICAgICAvLyBJZiB0aGUgZ2xvYmFsIG1vY2sgaXM6IGplc3QubW9jaygnZ29vZ2xlYXBpcycsICgpID0+ICh7IGdvb2dsZTogeyBjYWxlbmRhcjogamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7IGV2ZW50czogeyBpbnNlcnQ6IGplc3QuZm4oKSB9IH0pIH0gfSkpO1xuICAgICAgICAvLyB0aGVuIHRoaXMgYWNjZXNzIHNob3VsZCB3b3JrLlxuICAgICAgICBtb2NrRXZlbnRzSW5zZXJ0ID0gKGdvb2dsZS5jYWxlbmRhcigndjMnKSBhcyBhbnkpLmV2ZW50cy5pbnNlcnQ7XG4gICAgfSk7XG5cblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5TcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2dldEdvb2dsZUFQSVRva2VuJyk7XG4gICAgICAgICh1dWlkdjQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUobW9ja0dlbmVyYXRlZElkKTsgLy8gQ29uc2lzdGVudCBVVUlEIGZvciB0ZXN0c1xuICAgICAgICBtb2NrRXZlbnRzSW5zZXJ0Lm1vY2tDbGVhcigpOyAvLyBDbGVhciBjYWxsIGhpc3RvcnkgZm9yIGV2ZW50cy5pbnNlcnRcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGdldEdvb2dsZUFQSVRva2VuU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGJhc2VQYXJhbXMgPSB7XG4gICAgICAgIHVzZXJJZDogJ3VzZXJfZ2NhbF90ZXN0JyxcbiAgICAgICAgY2FsZW5kYXJJZDogJ3ByaW1hcnknLFxuICAgICAgICBjbGllbnRUeXBlOiAnd2ViJyBhcyAnd2ViJyxcbiAgICB9O1xuXG4gICAgY29uc3Qgc2FtcGxlRXZlbnRPcHRpb25zOiBhcGlIZWxwZXJNb2R1bGUuQ3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zID0geyAvLyBBc3N1bWluZyBDcmVhdGVHb29nbGVFdmVudE9wdGlvbnMgaXMgZXhwb3J0ZWQgb3IgdXNlIGFwaUhlbHBlck1vZHVsZS5cbiAgICAgICAgc3VtbWFyeTogJ1Rlc3QgRXZlbnQgZnJvbSBPcHRpb25zJyxcbiAgICAgICAgZGVzY3JpcHRpb246ICdFdmVudCBjcmVhdGVkIHdpdGggb3B0aW9ucyBvYmplY3QuJyxcbiAgICAgICAgc3RhcnREYXRlVGltZTogJzIwMjQtMDktMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgZW5kRGF0ZVRpbWU6ICcyMDI0LTA5LTAxVDExOjAwOjAwWicsXG4gICAgICAgIHRpbWV6b25lOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gICAgICAgIGF0dGVuZGVlczogW3sgZW1haWw6ICdhdHRlbmRlZUBleGFtcGxlLmNvbScgfV0sXG4gICAgICAgIGNvbmZlcmVuY2VEYXRhOiB7IHR5cGU6ICdoYW5nb3V0c01lZXQnIH0sIC8vIFNpbXBsaWZpZWQgZm9yIHRlc3QsIHJlYWwgb25lIG5lZWRzIGNyZWF0ZVJlcXVlc3RcbiAgICAgICAgc3RhdHVzOiAnY29uZmlybWVkJyxcbiAgICB9O1xuICAgICBjb25zdCBzYW1wbGVBbGxEYXlFdmVudE9wdGlvbnM6IGFwaUhlbHBlck1vZHVsZS5DcmVhdGVHb29nbGVFdmVudE9wdGlvbnMgPSB7XG4gICAgICAgIHN1bW1hcnk6ICdBbGwgRGF5IEV2ZW50IFRlc3QnLFxuICAgICAgICBzdGFydERhdGU6ICcyMDI0LTA5LTAyJywgLy8gWVlZWS1NTS1ERFxuICAgICAgICBlbmREYXRlOiAnMjAyNC0wOS0wMycsICAgLy8gWVlZWS1NTS1ERCAoR29vZ2xlIENhbGVuZGFyIGVuZCBkYXRlIGZvciBhbGwtZGF5IGlzIGV4Y2x1c2l2ZSlcbiAgICAgICAgdGltZXpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJywgLy8gU3RpbGwgbmVlZGVkIGZvciBjb250ZXh0LCB0aG91Z2ggR0NhbCBBUEkgdXNlcyBkYXRlIG9ubHlcbiAgICAgICAgZGVzY3JpcHRpb246ICdUaGlzIGlzIGFuIGFsbC1kYXkgZXZlbnQuJ1xuICAgIH07XG5cblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGEgdGltZWQgZXZlbnQgc3VjY2Vzc2Z1bGx5IHVzaW5nIGV2ZW50T3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5TcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCB0b2tlbjogJ2R1bW15X3Rva2VuJyB9KTtcbiAgICAgICAgY29uc3QgbW9ja0FwaVJlc3BvbnNlID0geyBkYXRhOiB7IGlkOiAnZ2NhbF9ldmVudF9vcHRpb25zXzEyMycsIHN1bW1hcnk6IHNhbXBsZUV2ZW50T3B0aW9ucy5zdW1tYXJ5IH0gfTtcbiAgICAgICAgbW9ja0V2ZW50c0luc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXBpUmVzcG9uc2UpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaUhlbHBlck1vZHVsZS5jcmVhdGVHb29nbGVFdmVudChcbiAgICAgICAgICAgIGJhc2VQYXJhbXMudXNlcklkLCBiYXNlUGFyYW1zLmNhbGVuZGFySWQsIGJhc2VQYXJhbXMuY2xpZW50VHlwZSxcbiAgICAgICAgICAgIHNhbXBsZUV2ZW50T3B0aW9ucyxcbiAgICAgICAgICAgIC8vIE9wdGlvbnMgdGhhdCBhcmUgc3RpbGwgc2VwYXJhdGUgcGFyYW1zOlxuICAgICAgICAgICAgLy8gdW5kZWZpbmVkLCAvLyBnZW5lcmF0ZWRJZCAod2lsbCBiZSBhdXRvLWdlbmVyYXRlZCBpZiBjb25mZXJlbmNlRGF0YS5jcmVhdGVSZXF1ZXN0IGlzIHVzZWQpXG4gICAgICAgICAgICAvLyAxIC8vIGNvbmZlcmVuY2VEYXRhVmVyc2lvblxuICAgICAgICApO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmRhdGEuZ29vZ2xlRXZlbnRJZCkudG9CZSgnZ2NhbF9ldmVudF9vcHRpb25zXzEyMycpO1xuICAgICAgICB9XG4gICAgICAgIGV4cGVjdChtb2NrRXZlbnRzSW5zZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICBjYWxlbmRhcklkOiBiYXNlUGFyYW1zLmNhbGVuZGFySWQsXG4gICAgICAgICAgICByZXF1ZXN0Qm9keTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICAgIHN1bW1hcnk6IHNhbXBsZUV2ZW50T3B0aW9ucy5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzYW1wbGVFdmVudE9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHsgZGF0ZVRpbWU6IHNhbXBsZUV2ZW50T3B0aW9ucy5zdGFydERhdGVUaW1lLCB0aW1lWm9uZTogc2FtcGxlRXZlbnRPcHRpb25zLnRpbWV6b25lIH0sXG4gICAgICAgICAgICAgICAgZW5kOiB7IGRhdGVUaW1lOiBzYW1wbGVFdmVudE9wdGlvbnMuZW5kRGF0ZVRpbWUsIHRpbWVab25lOiBzYW1wbGVFdmVudE9wdGlvbnMudGltZXpvbmUgfSxcbiAgICAgICAgICAgICAgICBhdHRlbmRlZXM6IHNhbXBsZUV2ZW50T3B0aW9ucy5hdHRlbmRlZXMsXG4gICAgICAgICAgICAgICAgLy8gY29uZmVyZW5jZURhdGEgc2hvdWxkIGJlIGJ1aWx0IGJhc2VkIG9uIG9wdGlvbnMuY29uZmVyZW5jZURhdGEgYW5kIGdlbmVyYXRlZElkXG4gICAgICAgICAgICAgICAgLy8gVGhlIHJlZmFjdG9yZWQgY3JlYXRlR29vZ2xlRXZlbnQgbm93IHVzZXMgdXVpZHY0KCkgaW50ZXJuYWxseSBmb3IgcmVxdWVzdElkIGlmIGNvbmZlcmVuY2VEYXRhLmNyZWF0ZVJlcXVlc3QgaXMgdG8gYmUgYnVpbHRcbiAgICAgICAgICAgICAgICAvLyBTbyBpZiBzYW1wbGVFdmVudE9wdGlvbnMuY29uZmVyZW5jZURhdGEgPSB7IHR5cGU6ICdoYW5nb3V0c01lZXQnIH0sIHRoZW4gY3JlYXRlUmVxdWVzdCBzaG91bGQgYmUgYnVpbHQuXG4gICAgICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgc2FtcGxlRXZlbnRPcHRpb25zLmNvbmZlcmVuY2VEYXRhID0geyB0eXBlOiAnaGFuZ291dHNNZWV0JyB9IG1pZ2h0IG5vdCB0cmlnZ2VyIGNyZWF0ZVJlcXVlc3QgaW4gdGhlIHJlZmFjdG9yZWQgY29kZS5cbiAgICAgICAgICAgICAgICAvLyBMZXQncyBhZGp1c3Qgc2FtcGxlRXZlbnRPcHRpb25zIGZvciBjb25mZXJlbmNlIHRlc3QuXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBzYW1wbGVFdmVudE9wdGlvbnMuc3RhdHVzLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvLyBjb25mZXJlbmNlRGF0YVZlcnNpb246IDEsIC8vIFRoaXMgc2hvdWxkIGJlIHNldCBpZiBjb25mZXJlbmNlRGF0YSBpcyBpbiByZXF1ZXN0Qm9keVxuICAgICAgICB9KSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGNyZWF0ZSBhbiBhbGwtZGF5IGV2ZW50IHN1Y2Nlc3NmdWxseSB1c2luZyBldmVudE9wdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdldEdvb2dsZUFQSVRva2VuU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgdG9rZW46ICdkdW1teV90b2tlbicgfSk7XG4gICAgICAgIGNvbnN0IG1vY2tBcGlSZXNwb25zZSA9IHsgZGF0YTogeyBpZDogJ2djYWxfYWxsZGF5XzQ1NicsIHN1bW1hcnk6IHNhbXBsZUFsbERheUV2ZW50T3B0aW9ucy5zdW1tYXJ5IH0gfTtcbiAgICAgICAgbW9ja0V2ZW50c0luc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXBpUmVzcG9uc2UpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaUhlbHBlck1vZHVsZS5jcmVhdGVHb29nbGVFdmVudChcbiAgICAgICAgICAgIGJhc2VQYXJhbXMudXNlcklkLCBiYXNlUGFyYW1zLmNhbGVuZGFySWQsIGJhc2VQYXJhbXMuY2xpZW50VHlwZSxcbiAgICAgICAgICAgIHNhbXBsZUFsbERheUV2ZW50T3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGV4cGVjdChtb2NrRXZlbnRzSW5zZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICByZXF1ZXN0Qm9keTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICAgIHN1bW1hcnk6IHNhbXBsZUFsbERheUV2ZW50T3B0aW9ucy5zdW1tYXJ5LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzYW1wbGVBbGxEYXlFdmVudE9wdGlvbnMuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhcnQ6IHsgZGF0ZTogJzIwMjQtMDktMDInLCB0aW1lWm9uZTogc2FtcGxlQWxsRGF5RXZlbnRPcHRpb25zLnRpbWV6b25lIH0sIC8vIGRhdGUgZmllbGQgZm9yIGFsbC1kYXlcbiAgICAgICAgICAgICAgICBlbmQ6IHsgZGF0ZTogJzIwMjQtMDktMDMnLCB0aW1lWm9uZTogc2FtcGxlQWxsRGF5RXZlbnRPcHRpb25zLnRpbWV6b25lIH0sICAgLy8gZGF0ZSBmaWVsZCBmb3IgYWxsLWRheVxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgY29ycmVjdGx5IGJ1aWxkIGNvbmZlcmVuY2VEYXRhIGlmIGNyZWF0ZVJlcXVlc3QgZGV0YWlscyBhcmUgcHJvdmlkZWQgaW4gb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5TcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCB0b2tlbjogJ2R1bW15X3Rva2VuJyB9KTtcbiAgICAgICAgY29uc3QgbW9ja0FwaVJlc3BvbnNlID0geyBkYXRhOiB7IGlkOiAnZ2NhbF9jb25mXzc4OScgfSB9O1xuICAgICAgICBtb2NrRXZlbnRzSW5zZXJ0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tBcGlSZXNwb25zZSk7XG5cbiAgICAgICAgY29uc3Qgb3B0aW9uc1dpdGhDb25mZXJlbmNlOiBhcGlIZWxwZXJNb2R1bGUuQ3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zID0ge1xuICAgICAgICAgICAgLi4uc2FtcGxlRXZlbnRPcHRpb25zLFxuICAgICAgICAgICAgY29uZmVyZW5jZURhdGE6IHsgLy8gVGhpcyBzdHJ1Y3R1cmUgd2lsbCBtYWtlIGNyZWF0ZUdvb2dsZUV2ZW50IGJ1aWxkIHRoZSBjcmVhdGVSZXF1ZXN0XG4gICAgICAgICAgICAgICAgY3JlYXRlUmVxdWVzdDoge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6ICdzaG91bGQtYmUtb3ZlcnJpZGRlbi1ieS1nZW5lcmF0ZWRJZC1vci1wYXJhbScsIC8vIFdpbGwgYmUgb3ZlcnJpZGRlbiBieSBnZW5lcmF0ZWRJZCBwYXJhbSBvciBpbnRlcm5hbCB1dWlkdjRcbiAgICAgICAgICAgICAgICAgICAgY29uZmVyZW5jZVNvbHV0aW9uS2V5OiB7IHR5cGU6ICdoYW5nb3V0c01lZXQnIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFBhc3MgYSBzcGVjaWZpYyBnZW5lcmF0ZWRJZCB0byB0ZXN0IGl0IGJlaW5nIHVzZWRcbiAgICAgICAgY29uc3Qgc3BlY2lmaWNHZW5lcmF0ZWRJZCA9IFwic3BlY2lmaWMtY29uZi11dWlkXCI7XG5cbiAgICAgICAgYXdhaXQgYXBpSGVscGVyTW9kdWxlLmNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgICAgICAgYmFzZVBhcmFtcy51c2VySWQsIGJhc2VQYXJhbXMuY2FsZW5kYXJJZCwgYmFzZVBhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgICAgICAgb3B0aW9uc1dpdGhDb25mZXJlbmNlLFxuICAgICAgICAgICAgc3BlY2lmaWNHZW5lcmF0ZWRJZCwgLy8gUGFzcyB0aGUgc3BlY2lmaWMgZ2VuZXJhdGVkSWQgaGVyZVxuICAgICAgICAgICAgMSAvLyBjb25mZXJlbmNlRGF0YVZlcnNpb25cbiAgICAgICAgKTtcblxuICAgICAgICBleHBlY3QobW9ja0V2ZW50c0luc2VydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgY29uZmVyZW5jZURhdGFWZXJzaW9uOiAxLFxuICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgICAgICBjb25mZXJlbmNlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjcmVhdGVSZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHNwZWNpZmljR2VuZXJhdGVkSWQsIC8vIENoZWNrIGlmIHRoaXMgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmVyZW5jZVNvbHV0aW9uS2V5OiB7IHR5cGU6ICdoYW5nb3V0c01lZXQnIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gVGVzdCB3aXRoIGludGVybmFsIHV1aWR2NFxuICAgICAgICAodXVpZHY0IGFzIGplc3QuTW9jaykubW9ja1JldHVyblZhbHVlT25jZShcImludGVybmFsLXV1aWQtZm9yLWNvbmZcIik7XG4gICAgICAgICBhd2FpdCBhcGlIZWxwZXJNb2R1bGUuY3JlYXRlR29vZ2xlRXZlbnQoXG4gICAgICAgICAgICBiYXNlUGFyYW1zLnVzZXJJZCwgYmFzZVBhcmFtcy5jYWxlbmRhcklkLCBiYXNlUGFyYW1zLmNsaWVudFR5cGUsXG4gICAgICAgICAgICBvcHRpb25zV2l0aENvbmZlcmVuY2UsXG4gICAgICAgICAgICB1bmRlZmluZWQsIC8vIE5vIHNwZWNpZmljIGdlbmVyYXRlZElkLCBzbyBpbnRlcm5hbCB1dWlkdjQgc2hvdWxkIGJlIHVzZWRcbiAgICAgICAgICAgIDFcbiAgICAgICAgKTtcbiAgICAgICAgIGV4cGVjdChtb2NrRXZlbnRzSW5zZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICByZXF1ZXN0Qm9keTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICAgIGNvbmZlcmVuY2VEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlcXVlc3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogXCJpbnRlcm5hbC11dWlkLWZvci1jb25mXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mZXJlbmNlU29sdXRpb25LZXk6IHsgdHlwZTogJ2hhbmdvdXRzTWVldCcgfSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pKTtcblxuICAgIH0pO1xuXG5cbiAgICAvLyBUZXN0cyBmb3IgZmFpbHVyZSBjYXNlcyAoZ2V0R29vZ2xlQVBJVG9rZW4gZmFpbHMsIEdDYWwgQVBJIGZhaWxzKSBjYW4gYmUgYWRhcHRlZCBmcm9tIGV4aXN0aW5nIGNyZWF0ZUdvb2dsZUV2ZW50IHRlc3RzLlxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgaWYgZ2V0R29vZ2xlQVBJVG9rZW4gZmFpbHMgKG9wdGlvbnMgdmVyc2lvbiknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuRXJyb3IgPSB7IG1lc3NhZ2U6ICdUb2tlbiBmZXRjaCBmYWlsZWQgZm9yIG9wdGlvbnMnIH07XG4gICAgICAgIGdldEdvb2dsZUFQSVRva2VuU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiB0b2tlbkVycm9yIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGlIZWxwZXJNb2R1bGUuY3JlYXRlR29vZ2xlRXZlbnQoYmFzZVBhcmFtcy51c2VySWQsIGJhc2VQYXJhbXMuY2FsZW5kYXJJZCwgYmFzZVBhcmFtcy5jbGllbnRUeXBlLCBzYW1wbGVFdmVudE9wdGlvbnMpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignVG9rZW4gYWNxdWlzaXRpb24gZmFpbHVyZScpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKHRva2VuRXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIGlmIEdvb2dsZSBDYWxlbmRhciBBUEkgaW5zZXJ0IGZhaWxzIChvcHRpb25zIHZlcnNpb24pJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfdG9rZW4nIH0pO1xuICAgICAgICBjb25zdCBhcGlFcnJvciA9IG5ldyBFcnJvcihcIkdvb2dsZSBBUEkgRXJyb3JcIik7XG4gICAgICAgIChhcGlFcnJvciBhcyBhbnkpLmNvZGUgPSA1MDA7IC8vIFNpbXVsYXRlIEdvb2dsZSBBUEkgZXJyb3Igc3RydWN0dXJlXG4gICAgICAgIG1vY2tFdmVudHNJbnNlcnQubW9ja1JlamVjdGVkVmFsdWUoYXBpRXJyb3IpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhcGlIZWxwZXJNb2R1bGUuY3JlYXRlR29vZ2xlRXZlbnQoYmFzZVBhcmFtcy51c2VySWQsIGJhc2VQYXJhbXMuY2FsZW5kYXJJZCwgYmFzZVBhcmFtcy5jbGllbnRUeXBlLCBzYW1wbGVFdmVudE9wdGlvbnMpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignR29vZ2xlIENhbGVuZGFyIEFQSSBlcnJvciBkdXJpbmcgZXZlbnQgY3JlYXRpb24nKTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5cblxuLy8gVE9ETzogVXBkYXRlIHRlc3RzIGZvciBjcmVhdGVBZ2VuZGEsIGJyZWFrRG93blRhc2ssIGhvd1RvVGFzaywgYW5kIGNyZWF0ZURheVNjaGVkdWxlXG4vLyB0byBlbnN1cmUgdGhleSBjb3JyZWN0bHkgcHJlcGFyZSBhbmQgcGFzcyB0aGUgQ3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zIG9iamVjdFxuLy8gdG8gdGhlIHNwaWVkIGNyZWF0ZUdvb2dsZUV2ZW50LiBUaGlzIHdpbGwgaW52b2x2ZTpcbi8vIDEuIElkZW50aWZ5aW5nIHdoZXJlIHRoZXNlIG9yY2hlc3RyYXRvcnMgY2FsbCBjcmVhdGVHb29nbGVFdmVudC5cbi8vIDIuIEluIHRoZSB0ZXN0cyBmb3IgdGhlc2Ugb3JjaGVzdHJhdG9ycywgd2hlbiBjcmVhdGVHb29nbGVFdmVudFNweSBpcyBjYWxsZWQsXG4vLyAgICBhc3NlcnQgdGhhdCB0aGUgYXJndW1lbnQgY29ycmVzcG9uZGluZyB0byAnZXZlbnRPcHRpb25zJyBpcyBhbiBvYmplY3Rcbi8vICAgIHRoYXQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgQ3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zIHN0cnVjdHVyZSBiYXNlZCBvbiB0aGUgb3JjaGVzdHJhdG9yJ3MgaW5wdXRzLlxuLy8gRXhhbXBsZSBmb3IgY3JlYXRlQWdlbmRhIHRlc3Q6XG4vLyBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuLy8gICBleHBlY3QuYW55KFN0cmluZyksIC8vIHVzZXJJZFxuLy8gICBleHBlY3QuYW55KFN0cmluZyksIC8vIGNhbGVuZGFySWRcbi8vICAgZXhwZWN0LmFueShTdHJpbmcpLCAvLyBjbGllbnRUeXBlXG4vLyAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgLy8gVGhpcyBpcyB0aGUgZXZlbnRPcHRpb25zXG4vLyAgICAgc3VtbWFyeTogXCJHZW5lcmF0ZWQgQWdlbmRhIEV2ZW50XCIsXG4vLyAgICAgZGVzY3JpcHRpb246IG1vY2tTdWNjZXNzZnVsT3BlbkFJLmNvbnRlbnQsIC8vIGZyb20gY3JlYXRlQWdlbmRhJ3Mgc2NvcGVcbi8vICAgICBzdGFydERhdGVUaW1lOiBleHBlY3QuYW55KFN0cmluZyksIC8vIENoZWNrIHNwZWNpZmljIGRhdGUvdGltZSBpZiBuZWNlc3Nhcnlcbi8vICAgICBlbmREYXRlVGltZTogZXhwZWN0LmFueShTdHJpbmcpLFxuLy8gICAgIHRpbWV6b25lOiBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJUaW1lem9uZVxuLy8gICB9KSxcbi8vICAgdW5kZWZpbmVkLCAvLyBnZW5lcmF0ZWRJZCBmb3IgY29uZmVyZW5jZSAobGlrZWx5IHVuZGVmaW5lZCBmb3Igc2ltcGxlIGFnZW5kYSBpdGVtKVxuLy8gICAwIC8vIGNvbmZlcmVuY2VEYXRhVmVyc2lvblxuLy8gKTtcbi8vIFRoaXMgaXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlIGRldGFpbGVkIHdvcmsgcmVxdWlyZWQgaW4gc3Vic2VxdWVudCBzdGVwcyBpZiB0aGlzIHdlcmUgaW50ZXJhY3RpdmUuXG4vLyBGb3Igbm93LCB0aGlzIGZpbGUgZm9jdXNlcyBvbiB0ZXN0aW5nIGNyZWF0ZUdvb2dsZUV2ZW50IGl0c2VsZiB3aXRoIGl0cyBuZXcgc2lnbmF0dXJlLlxuXG4vLyAtLS0gVXBkYXRpbmcgT3JjaGVzdHJhdG9yIEZ1bmN0aW9uIFRlc3RzIGZvciBDcmVhdGVHb29nbGVFdmVudE9wdGlvbnMgLS0tXG5cbi8vIE5vdGU6IFRoZSAnYXBpSGVscGVyTW9kdWxlJyBpcyB1c2VkIGZvciBzcHlpbmcsIGFzIHRoZXNlIGZ1bmN0aW9ucyBhcmUgaW4gdGhlIHNhbWUgbW9kdWxlLlxuLy8gVGhlIGFjdHVhbCBzcGllcyAoZS5nLiwgY3JlYXRlR29vZ2xlRXZlbnRTcHkpIGFyZSBkZWZpbmVkIHdpdGhpbiBlYWNoIG9yY2hlc3RyYXRvcidzIGRlc2NyaWJlIGJsb2NrLlxuXG5kZXNjcmliZSgnY3JlYXRlQWdlbmRhICh3aXRoIHJlZmFjdG9yZWQgY3JlYXRlR29vZ2xlRXZlbnQpJywgKCkgPT4ge1xuICAgIC8vIEFzc3VtaW5nIHNwaWVzIChjYWxsT3BlbkFJU3B5LCBnZXRHbG9iYWxDYWxlbmRhclNweSwgY3JlYXRlR29vZ2xlRXZlbnRTcHksIGV0Yy4pXG4gICAgLy8gYW5kIGRlZmF1bHQgcGFyYW1zIChkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zKSBhcmUgZGVmaW5lZCBhcyBpbiBwcmV2aW91cyBjcmVhdGVBZ2VuZGEgdGVzdHMuXG4gICAgLy8gT25seSBzaG93aW5nIHRoZSByZWxldmFudCBwYXJ0IG9mIGEgdGVzdCBjYXNlIHRoYXQgY2FsbHMgY3JlYXRlR29vZ2xlRXZlbnQuXG5cbiAgICAvLyBNaW5pbWFsIHNldHVwIGZvciBzcGllcyBuZWVkZWQgYnkgY3JlYXRlQWdlbmRhIGJlZm9yZSBjcmVhdGVHb29nbGVFdmVudCBpcyBjYWxsZWRcbiAgICBsZXQgY2FsbE9wZW5BSVNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgZ2V0R2xvYmFsQ2FsZW5kYXJTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IGNyZWF0ZUdvb2dsZUV2ZW50U3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgc2VuZEFnZW5kYUVtYWlsU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGNvbnN0IGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG4gICAgIGNvbnN0IGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMgPSB7XG4gICAgICAgIHVzZXJJZDogJ3VzZXIxMjMnLFxuICAgICAgICBjbGllbnRUeXBlOiAnd2ViJyBhcyAnd2ViJyxcbiAgICAgICAgdXNlclRpbWV6b25lOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gICAgICAgIHVzZXJEYXRlOiAnMjAyNC0wMy0xNScsXG4gICAgICAgIHByb21wdDogJ0NyZWF0ZSBhbiBhZ2VuZGEgZm9yIGEgcHJvZHVjdCBzdHJhdGVneSBtZWV0aW5nLicsXG4gICAgICAgIGVtYWlsOiAndGVzdEBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICAgIH07XG4gICAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxPcGVuQUkgPSB7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdHZW5lcmF0ZWQgQWdlbmRhIERldGFpbHMnIH07XG4gICAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhciA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBpZDogJ2dsb2JhbENhbElkJywgcHJpbWFyeUNhbGVuZGFySWQ6ICdwcmltYXJ5Q2FsMTIzJyB9IH07XG4gICAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxDcmVhdGVHb29nbGVFdmVudCA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBpZDogJ2dFdmVudDEyMyNwcmltYXJ5Q2FsMTIzJywgZ29vZ2xlRXZlbnRJZDogJ2dFdmVudDEyMycsIGdlbmVyYXRlZElkOiAndXVpZDEnLCBjYWxlbmRhcklkOiAncHJpbWFyeUNhbDEyMycgfSB9O1xuICAgIGNvbnN0IG1vY2tTdWNjZXNzZnVsVXBzZXJ0ID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGFmZmVjdGVkX3Jvd3M6IDEsIHJldHVybmluZzogW3sgaWQ6ICdkYkV2ZW50SWQ0NTYnIH1dIH0gfTtcbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bEVtYWlsID0geyBzdWNjZXNzOiB0cnVlIH07XG5cblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgY2FsbE9wZW5BSVNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnY2FsbE9wZW5BSScpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsT3BlbkFJKTtcbiAgICAgICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2dldEdsb2JhbENhbGVuZGFyJykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcik7XG4gICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdjcmVhdGVHb29nbGVFdmVudCcpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnQpO1xuICAgICAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAndXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXInKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bFVwc2VydCk7XG4gICAgICAgIHNlbmRBZ2VuZGFFbWFpbFNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnc2VuZEFnZW5kYUVtYWlsJykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxFbWFpbCk7XG4gICAgICAgICAvLyBnZXRHb29nbGVBUElUb2tlbiBpcyBjYWxsZWQgYnkgY3JlYXRlR29vZ2xlRXZlbnQsIHNvIGVuc3VyZSBpdCdzIHNwaWVkIGlmIG5lZWRlZCBmb3Igb3RoZXIgdGVzdHMsXG4gICAgICAgIC8vIGJ1dCBmb3IgdGVzdGluZyBjcmVhdGVBZ2VuZGEncyBjYWxsIHRvIGNyZWF0ZUdvb2dsZUV2ZW50LCBjcmVhdGVHb29nbGVFdmVudCBpdHNlbGYgaXMgc3BpZWQuXG4gICAgICAgIGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0R29vZ2xlQVBJVG9rZW4nKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7c3VjY2VzczogdHJ1ZSwgdG9rZW46IFwiZHVtbXktdG9rZW5cIn0pO1xuXG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgamVzdC5yZXN0b3JlQWxsTW9ja3MoKTsgLy8gUmVzdG9yZSBhbGwgbW9ja3MgYWZ0ZXIgZWFjaCB0ZXN0XG4gICAgICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuXG4gICAgaXQoJ2NyZWF0ZUFnZW5kYSBzaG91bGQgY2FsbCBjcmVhdGVHb29nbGVFdmVudCB3aXRoIENyZWF0ZUdvb2dsZUV2ZW50T3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgYXdhaXQgYXBpSGVscGVyTW9kdWxlLmNyZWF0ZUFnZW5kYShcbiAgICAgICAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlcklkLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmNsaWVudFR5cGUsXG4gICAgICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJUaW1lem9uZSwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyRGF0ZSxcbiAgICAgICAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMucHJvbXB0LCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmVtYWlsLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLm5hbWVcbiAgICAgICAgKTtcblxuICAgICAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VySWQsXG4gICAgICAgICAgICBtb2NrU3VjY2Vzc2Z1bEdsb2JhbENhbGVuZGFyLmRhdGEucHJpbWFyeUNhbGVuZGFySWQsXG4gICAgICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmNsaWVudFR5cGUsXG4gICAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IC8vIFRoaXMgaXMgdGhlIGV2ZW50T3B0aW9ucyBjaGVja1xuICAgICAgICAgICAgICAgIHN1bW1hcnk6IFwiR2VuZXJhdGVkIEFnZW5kYSBFdmVudFwiLCAvLyBBcyBwZXIgY3JlYXRlQWdlbmRhJ3Mgc2ltcGxpZmllZCBsb2dpY1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtb2NrU3VjY2Vzc2Z1bE9wZW5BSS5jb250ZW50LFxuICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZVRpbWU6IGRheWpzLnR6KGAke2RlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlckRhdGV9VDA5OjAwOjAwYCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyVGltZXpvbmUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgZW5kRGF0ZVRpbWU6IGRheWpzLnR6KGAke2RlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlckRhdGV9VDEwOjAwOjAwYCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyVGltZXpvbmUpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgdGltZXpvbmU6IGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlclRpbWV6b25lXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC8vIERlZmF1bHQgdmFsdWVzIGZvciBnZW5lcmF0ZWRJZCwgY29uZmVyZW5jZURhdGFWZXJzaW9uLCBldGMuLCBpZiBub3Qgc3BlY2lmaWVkIGJ5IGNyZWF0ZUFnZW5kYVxuICAgICAgICAgICAgIHVuZGVmaW5lZCwgLy8gZ2VuZXJhdGVkSWQgKGZvciBjb25mZXJlbmNlLCBsaWtlbHkgdW5kZWZpbmVkIGhlcmUpXG4gICAgICAgICAgICAgMCAvLyBjb25mZXJlbmNlRGF0YVZlcnNpb24gKGRlZmF1bHQgaWYgbm8gY29uZmVyZW5jZSlcbiAgICAgICAgKTtcbiAgICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnY3JlYXRlRGF5U2NoZWR1bGUgKHdpdGggcmVmYWN0b3JlZCBjcmVhdGVHb29nbGVFdmVudCknLCAoKSA9PiB7XG4gICAgLy8gQXNzdW1pbmcgc3BpZXMgYW5kIGRlZmF1bHRQYXJhbXMgYXJlIHNldCB1cCBhcyBpbiBwcmV2aW91cyBjcmVhdGVEYXlTY2hlZHVsZSB0ZXN0c1xuICAgIGxldCBsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXNTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IGNhbGxPcGVuQUlTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IGdldEdsb2JhbENhbGVuZGFyU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBjcmVhdGVHb29nbGVFdmVudFNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IHNlbmRHZW5lcmljVGFza0VtYWlsU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGNvbnN0IGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG4gICAgY29uc3QgZGVmYXVsdERheVNjaGVkdWxlUGFyYW1zID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyX3NjaGVkdWxlX3Rlc3QnLFxuICAgICAgICBjbGllbnRUeXBlOiAnd2ViJyBhcyAnd2ViJyxcbiAgICAgICAgdXNlckRhdGU6ICcyMDI0LTA4LTE1JyxcbiAgICAgICAgdXNlclRpbWV6b25lOiAnQW1lcmljYS9EZW52ZXInLFxuICAgICAgICBwcm9tcHQ6ICdQbGFuIG15IGRheS4nLFxuICAgICAgICBpc0FsbERheTogZmFsc2UsXG4gICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdTY2hlZHVsZSBVc2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG1vY2tQYXJzZWRUYXNrc05vbkFsbERheSA9IFtcbiAgICAgICAgeyBzdGFydF90aW1lOiBcIjEwOjAwIEFNXCIsIGVuZF90aW1lOiBcIjExOjAwIEFNXCIsIHRhc2s6IFwiVGFzayAxXCIsIGRlc2NyaXB0aW9uOiBcIkRlc2MgMVwiIH0sXG4gICAgICAgIHsgc3RhcnRfdGltZTogXCIyOjAwIFBNXCIsIGVuZF90aW1lOiBcIjM6MDAgUE1cIiwgdGFzazogXCJUYXNrIDJcIiwgZGVzY3JpcHRpb246IFwiRGVzYyAyXCIgfVxuICAgIF07XG4gICAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhciA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBpZDogJ2RiQ2FsSWQxMjMnLCBwcmltYXJ5Q2FsZW5kYXJJZDogJ3ByaW1hcnlHQ2FsSWQ0NTYnIH0gfTtcblxuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgICAgICBsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXNTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2xpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcycpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogW10gfSk7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NhbGxPcGVuQUknKTsgLy8gU3BlY2lmaWMgbW9jayBwZXIgdGVzdFxuICAgICAgICBnZXRHbG9iYWxDYWxlbmRhclNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0R2xvYmFsQ2FsZW5kYXInKS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bEdsb2JhbENhbGVuZGFyKTtcbiAgICAgICAgY3JlYXRlR29vZ2xlRXZlbnRTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NyZWF0ZUdvb2dsZUV2ZW50JykubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGlkOiAnZzEnLCBnb29nbGVFdmVudElkOiAnZzEnLCBnZW5lcmF0ZWRJZDogJ3UxJywgY2FsZW5kYXJJZDogJ3AxJyB9fSk7XG4gICAgICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICd1cHNlcnRFdmVudHNQb3N0UGxhbm5lcicpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBhZmZlY3RlZF9yb3dzOiAxLCByZXR1cm5pbmc6IFtdIH0gfSk7XG4gICAgICAgIHNlbmRHZW5lcmljVGFza0VtYWlsU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdzZW5kR2VuZXJpY1Rhc2tFbWFpbCcpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdnZXRHb29nbGVBUElUb2tlbicpLm1vY2tSZXNvbHZlZFZhbHVlKHtzdWNjZXNzOiB0cnVlLCB0b2tlbjogXCJkdW1teS10b2tlblwifSk7XG4gICAgfSk7XG4gICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gICAgICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuXG4gICAgaXQoJ2NyZWF0ZURheVNjaGVkdWxlIG5vbi1hbGwtZGF5IHNob3VsZCBjYWxsIGNyZWF0ZUdvb2dsZUV2ZW50IHdpdGggQ3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zIGZvciBlYWNoIHRhc2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtb2NrUGFyc2VkVGFza3NOb25BbGxEYXkpIH0pO1xuXG4gICAgICAgIGF3YWl0IGFwaUhlbHBlck1vZHVsZS5jcmVhdGVEYXlTY2hlZHVsZSguLi5PYmplY3QudmFsdWVzKGRlZmF1bHREYXlTY2hlZHVsZVBhcmFtcykpO1xuXG4gICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKG1vY2tQYXJzZWRUYXNrc05vbkFsbERheS5sZW5ndGgpO1xuICAgICAgICBtb2NrUGFyc2VkVGFza3NOb25BbGxEYXkuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU3RhcnREYXRlVGltZSA9IGRheWpzLnR6KGAke2RlZmF1bHREYXlTY2hlZHVsZVBhcmFtcy51c2VyRGF0ZX0gJHt0YXNrLnN0YXJ0X3RpbWV9YCwgJ1lZWVktTU0tREQgaDptbSBBJywgZGVmYXVsdERheVNjaGVkdWxlUGFyYW1zLnVzZXJUaW1lem9uZSkudG9JU09TdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkRW5kRGF0ZVRpbWUgPSBkYXlqcy50eihgJHtkZWZhdWx0RGF5U2NoZWR1bGVQYXJhbXMudXNlckRhdGV9ICR7dGFzay5lbmRfdGltZX1gLCAnWVlZWS1NTS1ERCBoOm1tIEEnLCBkZWZhdWx0RGF5U2NoZWR1bGVQYXJhbXMudXNlclRpbWV6b25lKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgZXhwZWN0KGNyZWF0ZUdvb2dsZUV2ZW50U3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGF5U2NoZWR1bGVQYXJhbXMudXNlcklkLFxuICAgICAgICAgICAgICAgIG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIuZGF0YS5wcmltYXJ5Q2FsZW5kYXJJZCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0RGF5U2NoZWR1bGVQYXJhbXMuY2xpZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IHRhc2sudGFzayxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHRhc2suZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZVRpbWU6IGV4cGVjdGVkU3RhcnREYXRlVGltZSxcbiAgICAgICAgICAgICAgICAgICAgZW5kRGF0ZVRpbWU6IGV4cGVjdGVkRW5kRGF0ZVRpbWUsXG4gICAgICAgICAgICAgICAgICAgIHRpbWV6b25lOiBkZWZhdWx0RGF5U2NoZWR1bGVQYXJhbXMudXNlclRpbWV6b25lXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdW5kZWZpbmVkLCAvLyBnZW5lcmF0ZWRJZCBmb3IgY29uZmVyZW5jZVxuICAgICAgICAgICAgICAgIDAgLy8gY29uZmVyZW5jZURhdGFWZXJzaW9uXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdjcmVhdGVEYXlTY2hlZHVsZSBhbGwtZGF5IHNob3VsZCBjYWxsIGNyZWF0ZUdvb2dsZUV2ZW50IHdpdGggQ3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zIGZvciBhIHNpbmdsZSBldmVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgbW9ja1BhcnNlZFRhc2tzQWxsRGF5ID0gW3sgdGFzazogXCJUYXNrIEFcIiwgZGVzY3JpcHRpb246IFwiRGVzYyBBXCJ9LCB7IHRhc2s6IFwiVGFzayBCXCIsIGRlc2NyaXB0aW9uOiBcIkRlc2MgQlwifV07XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtb2NrUGFyc2VkVGFza3NBbGxEYXkpIH0pO1xuICAgICAgICBjb25zdCBhbGxEYXlQYXJhbXMgPSB7IC4uLmRlZmF1bHREYXlTY2hlZHVsZVBhcmFtcywgaXNBbGxEYXk6IHRydWUgfTtcblxuICAgICAgICBhd2FpdCBhcGlIZWxwZXJNb2R1bGUuY3JlYXRlRGF5U2NoZWR1bGUoLi4uT2JqZWN0LnZhbHVlcyhhbGxEYXlQYXJhbXMpKTtcblxuICAgICAgICBjb25zdCBleHBlY3RlZEFsbERheVN0YXJ0RGF0ZSA9IGRheWpzLnR6KGFsbERheVBhcmFtcy51c2VyRGF0ZSwgYWxsRGF5UGFyYW1zLnVzZXJUaW1lem9uZSkuc3RhcnRPZignZGF5JykuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkQWxsRGF5RW5kRGF0ZSA9IGRheWpzLnR6KGFsbERheVBhcmFtcy51c2VyRGF0ZSwgYWxsRGF5UGFyYW1zLnVzZXJUaW1lem9uZSkuYWRkKDEsICdkYXknKS5zdGFydE9mKCdkYXknKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWREZXNjcmlwdGlvbiA9IG1vY2tQYXJzZWRUYXNrc0FsbERheS5tYXAodCA9PiBgJHt0LnRhc2t9JHt0LmRlc2NyaXB0aW9uID8gYDpcXG4ke3QuZGVzY3JpcHRpb259YCA6ICcnfWApLmpvaW4oJ1xcblxcbi0tLVxcblxcbicpO1xuXG4gICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgYWxsRGF5UGFyYW1zLnVzZXJJZCxcbiAgICAgICAgICAgIG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIuZGF0YS5wcmltYXJ5Q2FsZW5kYXJJZCxcbiAgICAgICAgICAgIGFsbERheVBhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICAgIHN1bW1hcnk6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdEYXkgU2NoZWR1bGU6JyksXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGV4cGVjdGVkRGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhcnREYXRlOiBleHBlY3RlZEFsbERheVN0YXJ0RGF0ZSxcbiAgICAgICAgICAgICAgICBlbmREYXRlOiBleHBlY3RlZEFsbERheUVuZERhdGUsXG4gICAgICAgICAgICAgICAgdGltZXpvbmU6IGFsbERheVBhcmFtcy51c2VyVGltZXpvbmVcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdW5kZWZpbmVkLCAwXG4gICAgICAgICk7XG4gICAgfSk7XG59KTtcblxuXG5kZXNjcmliZSgnYnJlYWtEb3duVGFzayBhbmQgaG93VG9UYXNrICh3aXRoIHJlZmFjdG9yZWQgY3JlYXRlR29vZ2xlRXZlbnQpJywgKCkgPT4ge1xuICAgIC8vIENvbW1vbiBzZXR1cCBmb3IgYnJlYWtEb3duVGFzayBhbmQgaG93VG9UYXNrXG4gICAgbGV0IGNhbGxPcGVuQUlTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IGdldEdsb2JhbENhbGVuZGFyU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBjcmVhdGVHb29nbGVFdmVudFNweTogamVzdC5TcHlJbnN0YW5jZTsgLy8gVGhpcyBpcyB0aGUgdGFyZ2V0IGZvciBhc3NlcnRpb24gY2hhbmdlXG4gICAgbGV0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGNvbnN0IGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG5cbiAgICBjb25zdCBkZWZhdWx0VGFza1BhcmFtcyA9IHtcbiAgICAgICAgdXNlcklkOiAndXNlcl90YXNrX3Rlc3QnLFxuICAgICAgICBjbGllbnRUeXBlOiAnd2ViJyBhcyAnd2ViJyxcbiAgICAgICAgdXNlclRpbWV6b25lOiAnQW1lcmljYS9Mb3NfQW5nZWxlcycsXG4gICAgICAgIHRhc2tUaXRsZTogJ1BsYW4gUTMgUm9hZG1hcCcsXG4gICAgICAgIHRhc2tEZXNjcmlwdGlvbjogJ0RldGFpbGVkIHBsYW5uaW5nIGZvciBRMy4nLFxuICAgICAgICBpc0FsbERheTogZmFsc2UsXG4gICAgICAgIHN0YXJ0RGF0ZTogJzIwMjQtMDctMDFUMTA6MDA6MDBaJyxcbiAgICAgICAgZW5kRGF0ZTogJzIwMjQtMDctMDFUMTE6MDA6MDBaJyxcbiAgICAgICAgZW1haWw6ICd1c2VyQGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rhc2sgVXNlcicsXG4gICAgfTtcbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bE9wZW5BSV9UYXNrID0geyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiAnVGFzayBkZXRhaWxzIGZyb20gQUknIH07XG4gICAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGlkOiAndGFza0NhbElkJywgcHJpbWFyeUNhbGVuZGFySWQ6ICdwcmltYXJ5VGFza0NhbCcgfSB9O1xuICAgICAvLyBjcmVhdGVHb29nbGVFdmVudCBpcyBzcGllZCwgc28gaXRzIGludGVybmFsIGdldEdvb2dsZUFQSVRva2VuIGNhbGwgZG9lc24ndCBuZWVkIHNlcGFyYXRlIHNweWluZyBoZXJlLlxuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgICAgICBjYWxsT3BlbkFJU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdjYWxsT3BlbkFJJykubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUlfVGFzayk7XG4gICAgICAgIGdldEdsb2JhbENhbGVuZGFyU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdnZXRHbG9iYWxDYWxlbmRhcicpLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXJfVGFzayk7XG4gICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdjcmVhdGVHb29nbGVFdmVudCcpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBpZDogJ2cxJywgZ29vZ2xlRXZlbnRJZDogJ2cxJywgZ2VuZXJhdGVkSWQ6J3UxJywgY2FsZW5kYXJJZDoncDEnIH19KTtcbiAgICAgICAgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ3Vwc2VydEV2ZW50c1Bvc3RQbGFubmVyJykubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGFmZmVjdGVkX3Jvd3M6MSwgcmV0dXJuaW5nOltdIH0gfSk7XG4gICAgICAgIGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0R29vZ2xlQVBJVG9rZW4nKS5tb2NrUmVzb2x2ZWRWYWx1ZSh7c3VjY2VzczogdHJ1ZSwgdG9rZW46IFwiZHVtbXktdG9rZW5cIn0pO1xuICAgIH0pO1xuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGplc3QucmVzdG9yZUFsbE1vY2tzKCk7XG4gICAgICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdicmVha0Rvd25UYXNrIChjaGVja2luZyBjcmVhdGVHb29nbGVFdmVudE9wdGlvbnMpJywgKCkgPT4ge1xuICAgICAgICBsZXQgZW1haWxUYXNrQnJlYWtEb3duU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgICAgICBiZWZvcmVFYWNoKCgpID0+IGVtYWlsVGFza0JyZWFrRG93blNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZW1haWxUYXNrQnJlYWtEb3duJykubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlIH0pKTtcbiAgICAgICAgYWZ0ZXJFYWNoKCgpID0+IGVtYWlsVGFza0JyZWFrRG93blNweS5tb2NrUmVzdG9yZSgpKTtcblxuICAgICAgICBpdCgnYnJlYWtEb3duVGFzayB0aW1lZCBldmVudCBzaG91bGQgY2FsbCBjcmVhdGVHb29nbGVFdmVudCB3aXRoIGNvcnJlY3Qgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGF3YWl0IGFwaUhlbHBlck1vZHVsZS5icmVha0Rvd25UYXNrKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJJZCwgZGVmYXVsdFRhc2tQYXJhbXMuY2xpZW50VHlwZSwgZGVmYXVsdFRhc2tQYXJhbXMudXNlclRpbWV6b25lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnRhc2tUaXRsZSwgZGVmYXVsdFRhc2tQYXJhbXMudGFza0Rlc2NyaXB0aW9uLCBmYWxzZSwgLy8gaXNBbGxEYXkgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy5lbWFpbCwgZGVmYXVsdFRhc2tQYXJhbXMubmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudXNlcklkLCBtb2NrU3VjY2Vzc2Z1bEdsb2JhbENhbGVuZGFyX1Rhc2suZGF0YS5wcmltYXJ5Q2FsZW5kYXJJZCwgZGVmYXVsdFRhc2tQYXJhbXMuY2xpZW50VHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnk6IGRlZmF1bHRUYXNrUGFyYW1zLnRhc2tUaXRsZSxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vY2tTdWNjZXNzZnVsT3BlbkFJX1Rhc2suY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlVGltZTogZGVmYXVsdFRhc2tQYXJhbXMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlVGltZTogZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmU6IGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJUaW1lem9uZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ2JyZWFrRG93blRhc2sgYWxsLWRheSBldmVudCBzaG91bGQgY2FsbCBjcmVhdGVHb29nbGVFdmVudCB3aXRoIGNvcnJlY3QgZGF0ZSBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxsRGF5U3RhcnREYXRlID0gZGF5anMoZGVmYXVsdFRhc2tQYXJhbXMuc3RhcnREYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbERheUVuZERhdGUgPSBkYXlqcyhkZWZhdWx0VGFza1BhcmFtcy5lbmREYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKTsgLy8gVGhlIGhlbHBlciBhZGRzIDEgZGF5IHRvIGVuZCBkYXRlIGZvciBHQ2FsXG5cbiAgICAgICAgICAgIGF3YWl0IGFwaUhlbHBlck1vZHVsZS5icmVha0Rvd25UYXNrKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJJZCwgZGVmYXVsdFRhc2tQYXJhbXMuY2xpZW50VHlwZSwgZGVmYXVsdFRhc2tQYXJhbXMudXNlclRpbWV6b25lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnRhc2tUaXRsZSwgZGVmYXVsdFRhc2tQYXJhbXMudGFza0Rlc2NyaXB0aW9uLCB0cnVlLCAvLyBpc0FsbERheSA9IHRydWVcbiAgICAgICAgICAgICAgICBhbGxEYXlTdGFydERhdGUsIGFsbERheUVuZERhdGUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMuZW1haWwsIGRlZmF1bHRUYXNrUGFyYW1zLm5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJJZCwgbW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrLmRhdGEucHJpbWFyeUNhbGVuZGFySWQsIGRlZmF1bHRUYXNrUGFyYW1zLmNsaWVudFR5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5OiBkZWZhdWx0VGFza1BhcmFtcy50YXNrVGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBtb2NrU3VjY2Vzc2Z1bE9wZW5BSV9UYXNrLmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RGF0ZTogYWxsRGF5U3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlOiBkYXlqcyhhbGxEYXlFbmREYXRlKS5hZGQoMSwgJ2RheScpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLCAvLyBjcmVhdGVFdmVudEhlbHBlciBhZGRzIDEgZGF5XG4gICAgICAgICAgICAgICAgICAgIHRpbWV6b25lOiBkZWZhdWx0VGFza1BhcmFtcy51c2VyVGltZXpvbmVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB1bmRlZmluZWQsIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2hvd1RvVGFzayAoY2hlY2tpbmcgY3JlYXRlR29vZ2xlRXZlbnRPcHRpb25zKScsICgpID0+IHtcbiAgICAgICAgbGV0IHNlbmRHZW5lcmljVGFza0VtYWlsU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgICAgICBiZWZvcmVFYWNoKCgpID0+IHNlbmRHZW5lcmljVGFza0VtYWlsU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdzZW5kR2VuZXJpY1Rhc2tFbWFpbCcpLm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KSk7XG4gICAgICAgIGFmdGVyRWFjaCgoKSA9PiBzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweS5tb2NrUmVzdG9yZSgpKTtcblxuICAgICAgICBpdCgnaG93VG9UYXNrIHRpbWVkIGV2ZW50IHNob3VsZCBjYWxsIGNyZWF0ZUdvb2dsZUV2ZW50IHdpdGggY29ycmVjdCBvcHRpb25zJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgYXBpSGVscGVyTW9kdWxlLmhvd1RvVGFzayhcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy51c2VySWQsIGRlZmF1bHRUYXNrUGFyYW1zLmNsaWVudFR5cGUsIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJUaW1lem9uZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy50YXNrVGl0bGUsIGZhbHNlLCAvLyBpc0FsbERheSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMuc3RhcnREYXRlLCBkZWZhdWx0VGFza1BhcmFtcy5lbmREYXRlLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLmVtYWlsLCBkZWZhdWx0VGFza1BhcmFtcy5uYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KGNyZWF0ZUdvb2dsZUV2ZW50U3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy51c2VySWQsIG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXJfVGFzay5kYXRhLnByaW1hcnlDYWxlbmRhcklkLCBkZWZhdWx0VGFza1BhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgICAgICAgICAgc3VtbWFyeTogYEhvdyB0bzogJHtkZWZhdWx0VGFza1BhcmFtcy50YXNrVGl0bGV9YCxcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IG1vY2tTdWNjZXNzZnVsT3BlbkFJX1Rhc2suY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnREYXRlVGltZTogZGVmYXVsdFRhc2tQYXJhbXMuc3RhcnREYXRlLFxuICAgICAgICAgICAgICAgICAgICBlbmREYXRlVGltZTogZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgdGltZXpvbmU6IGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJUaW1lem9uZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHVuZGVmaW5lZCwgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuLy8gLS0tIFRlc3RzIGZvciBjcmVhdGVEYXlTY2hlZHVsZSAtLS1cbmltcG9ydCB7IGNyZWF0ZURheVNjaGVkdWxlIH0gZnJvbSAnLi9hcGktaGVscGVyJztcbi8vIFNwaWVzIGZvciBhcGlIZWxwZXJNb2R1bGUgZnVuY3Rpb25zIHdpbGwgYmUgc2V0IHVwIGluIGRlc2NyaWJlIGJsb2NrLlxuLy8gT3RoZXIgbmVjZXNzYXJ5IG1vY2tzIGxpa2UgJ2dvdCcsICdnb29nbGVhcGlzJywgJ3V1aWQnLCAnc2VuZEVtYWlsJyBhcmUgYWxyZWFkeSBzZXQgdXAuXG5cbmRlc2NyaWJlKCdjcmVhdGVEYXlTY2hlZHVsZScsICgpID0+IHtcbiAgICBsZXQgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBjYWxsT3BlbkFJU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBnZXRHbG9iYWxDYWxlbmRhclNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgY3JlYXRlR29vZ2xlRXZlbnRTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweTogamVzdC5TcHlJbnN0YW5jZTsgLy8gUmVuYW1lZCBmcm9tIGVtYWlsRGFpbHlTY2hlZHVsZVxuICAgIGNvbnN0IGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG4gICAgY29uc3QgZGVmYXVsdFBhcmFtcyA9IHtcbiAgICAgICAgdXNlcklkOiAndXNlcl9zY2hlZHVsZV90ZXN0JyxcbiAgICAgICAgY2xpZW50VHlwZTogJ3dlYicgYXMgJ3dlYicsXG4gICAgICAgIHVzZXJEYXRlOiAnMjAyNC0wOC0xNScsXG4gICAgICAgIHVzZXJUaW1lem9uZTogJ0FtZXJpY2EvRGVudmVyJyxcbiAgICAgICAgcHJvbXB0OiAnUGxhbiBteSBkYXkgd2l0aCBmb2N1cyBvbiBwcm9qZWN0IFguJyxcbiAgICAgICAgaXNBbGxEYXk6IGZhbHNlLFxuICAgICAgICBlbWFpbDogJ3VzZXJAZXhhbXBsZS5jb20nLFxuICAgICAgICBuYW1lOiAnU2NoZWR1bGUgVXNlcicsXG4gICAgfTtcblxuICAgIGNvbnN0IG1vY2tFeGlzdGluZ0V2ZW50cyA9IFtcbiAgICAgICAgeyBpZDogJ2V4aXN0MScsIHN1bW1hcnk6ICdNb3JuaW5nIFN0YW5kdXAnLCBzdGFydERhdGVUaW1lOiAnMjAyNC0wOC0xNVQxNTowMDowMFonLCBlbmREYXRlVGltZTogJzIwMjQtMDgtMTVUMTU6MzA6MDBaJyB9IC8vIDkgQU0gRGVudmVyXG4gICAgXTtcbiAgICBjb25zdCBtb2NrUGFyc2VkVGFza3NOb25BbGxEYXkgPSBbXG4gICAgICAgIHsgc3RhcnRfdGltZTogXCIxMDowMCBBTVwiLCBlbmRfdGltZTogXCIxMTowMCBBTVwiLCB0YXNrOiBcIldvcmsgb24gUHJvamVjdCBYIHByb3Bvc2FsXCIsIGRlc2NyaXB0aW9uOiBcIkRyYWZ0IGluaXRpYWwgcHJvcG9zYWwuXCIgfSxcbiAgICAgICAgeyBzdGFydF90aW1lOiBcIjI6MDAgUE1cIiwgZW5kX3RpbWU6IFwiMzowMCBQTVwiLCB0YXNrOiBcIkZvbGxvdyB1cCBlbWFpbHNcIiwgZGVzY3JpcHRpb246IFwiQ2xpZW50IGNvbW11bmljYXRpb25zLlwiIH1cbiAgICBdO1xuICAgICBjb25zdCBtb2NrUGFyc2VkVGFza3NBbGxEYXkgPSBbIC8vIEZvciBhbGwtZGF5LCBzdHJ1Y3R1cmUgbWlnaHQgYmUgc2ltcGxlciBsaXN0IG9mIHRhc2tzIGlmIHRpbWVzIGFyZSBpZ25vcmVkXG4gICAgICAgIHsgdGFzazogXCJSZXZpZXcgUFJzXCIsIGRlc2NyaXB0aW9uOiBcIkNoZWNrIHRlYW0gcHVsbCByZXF1ZXN0cy5cIiB9LFxuICAgICAgICB7IHRhc2s6IFwiUGxhbiBuZXh0IHNwcmludFwiLCBkZXNjcmlwdGlvbjogXCJPdXRsaW5lIHRhc2tzIGZvciB1cGNvbWluZyBzcHJpbnQuXCIgfVxuICAgIF07XG5cbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bEdsb2JhbENhbGVuZGFyID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGlkOiAnZGJDYWxJZDEyMycsIHByaW1hcnlDYWxlbmRhcklkOiAncHJpbWFyeUdDYWxJZDQ1NicgfSB9O1xuICAgIGNvbnN0IG1vY2tTdWNjZXNzZnVsR0V2ZW50Q3JlYXRlID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGlkOiAnZ2NhbEV2ZW50SWQjcHJpbWFyeUdDYWxJZDQ1NicsIGdvb2dsZUV2ZW50SWQ6ICdnY2FsRXZlbnRJZCcsIGdlbmVyYXRlZElkOiAndXVpZEdlbmVyYXRlZCcgfSB9O1xuICAgIGNvbnN0IG1vY2tTdWNjZXNzZnVsVXBzZXJ0ID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGFmZmVjdGVkX3Jvd3M6IDEsIHJldHVybmluZzogW3tpZDogJ2RiRXZlbnQxJ31dIH0gfTtcbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bEVtYWlsID0geyBzdWNjZXNzOiB0cnVlIH07XG5cblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXMnKTtcbiAgICAgICAgY2FsbE9wZW5BSVNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnY2FsbE9wZW5BSScpO1xuICAgICAgICBnZXRHbG9iYWxDYWxlbmRhclNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0R2xvYmFsQ2FsZW5kYXInKTtcbiAgICAgICAgY3JlYXRlR29vZ2xlRXZlbnRTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NyZWF0ZUdvb2dsZUV2ZW50Jyk7XG4gICAgICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICd1cHNlcnRFdmVudHNQb3N0UGxhbm5lcicpO1xuICAgICAgICBzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnc2VuZEdlbmVyaWNUYXNrRW1haWwnKTsgLy8gVXBkYXRlZCBzcHkgbmFtZVxuXG4gICAgICAgIC8vIERlZmF1bHQgc3VjY2Vzc2Z1bCBtb2NrcyBmb3IgbW9zdCBjb21tb24gcGF0aFxuICAgICAgICBsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXNTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrRXhpc3RpbmdFdmVudHMgfSk7XG4gICAgICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIpO1xuICAgICAgICBjcmVhdGVHb29nbGVFdmVudFNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bEdFdmVudENyZWF0ZSk7XG4gICAgICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsVXBzZXJ0KTtcbiAgICAgICAgc2VuZEdlbmVyaWNUYXNrRW1haWxTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxFbWFpbCk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgY29uc29sZUxvZ1NweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gVGVzdCBDYXNlIDE6IFN1Y2Nlc3MgKG5vbi1hbGwtZGF5LCBtdWx0aXBsZSB0YXNrcyBwYXJzZWQgYW5kIGNyZWF0ZWQpLlxuICAgIGl0KCdzaG91bGQgc3VjY2VlZCBmb3Igbm9uLWFsbC1kYXkgc2NoZWR1bGUgd2l0aCBtdWx0aXBsZSB0YXNrcyBhbmQgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtb2NrUGFyc2VkVGFza3NOb25BbGxEYXkpIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVEYXlTY2hlZHVsZSguLi5PYmplY3QudmFsdWVzKGRlZmF1bHRQYXJhbXMpKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgIGV4cGVjdChsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXNTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgZXhwZWN0KGNhbGxPcGVuQUlTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgZXhwZWN0KGdldEdsb2JhbENhbGVuZGFyU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKG1vY2tQYXJzZWRUYXNrc05vbkFsbERheS5sZW5ndGgpO1xuICAgICAgICBleHBlY3QodXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgZXhwZWN0KHNlbmRHZW5lcmljVGFza0VtYWlsU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICAvLyBUZXN0IENhc2UgMjogU3VjY2VzcyAoYWxsLWRheSBzY2hlZHVsZSkuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZWVkIGZvciBhbGwtZGF5IHNjaGVkdWxlLCBjcmVhdGluZyBvbmUgc3VtbWFyeSBldmVudCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1vY2tQYXJzZWRUYXNrc0FsbERheSkgfSk7XG4gICAgICAgIGNvbnN0IHBhcmFtc0FsbERheSA9IHsgLi4uZGVmYXVsdFBhcmFtcywgaXNBbGxEYXk6IHRydWUgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlRGF5U2NoZWR1bGUoLi4uT2JqZWN0LnZhbHVlcyhwYXJhbXNBbGxEYXkpKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgZXhwZWN0KGNyZWF0ZUdvb2dsZUV2ZW50U3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7IC8vIE9ubHkgb25lIGV2ZW50IGZvciBhbGwtZGF5XG4gICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICBwYXJhbXNBbGxEYXkudXNlcklkLFxuICAgICAgICAgICAgbW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhci5kYXRhLnByaW1hcnlDYWxlbmRhcklkLFxuICAgICAgICAgICAgcGFyYW1zQWxsRGF5LmNsaWVudFR5cGUsXG4gICAgICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnRGF5IFNjaGVkdWxlOicpLCAvLyBTdW1tYXJ5IGZvciBhbGwtZGF5IGV2ZW50XG4gICAgICAgICAgICBkYXlqcy50eihwYXJhbXNBbGxEYXkudXNlckRhdGUsIHBhcmFtc0FsbERheS51c2VyVGltZXpvbmUpLnN0YXJ0T2YoJ2RheScpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLCAvLyBTdGFydCBkYXRlIGZvciBhbGwtZGF5XG4gICAgICAgICAgICBkYXlqcy50eihwYXJhbXNBbGxEYXkudXNlckRhdGUsIHBhcmFtc0FsbERheS51c2VyVGltZXpvbmUpLmFkZCgxLCAnZGF5Jykuc3RhcnRPZignZGF5JykuZm9ybWF0KCdZWVlZLU1NLUREJyksIC8vIEVuZCBkYXRlIGZvciBhbGwtZGF5XG4gICAgICAgICAgICBwYXJhbXNBbGxEYXkudXNlclRpbWV6b25lLFxuICAgICAgICAgICAgZXhwZWN0LmFueShTdHJpbmcpIC8vIERlc2NyaXB0aW9uIHdpbGwgYmUgY29uY2F0ZW5hdGlvbiBvZiB0YXNrc1xuICAgICAgICApO1xuICAgICAgICBleHBlY3QodXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgZXhwZWN0KHNlbmRHZW5lcmljVGFza0VtYWlsU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICAvLyBUZXN0IENhc2UgMzogY2FsbE9wZW5BSSBmYWlscy5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaWYgY2FsbE9wZW5BSSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgb3BlbkFJRXJyb3IgPSB7IG1lc3NhZ2U6IFwiQUkgc3lzdGVtIG9mZmxpbmVcIiB9O1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBvcGVuQUlFcnJvciB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlRGF5U2NoZWR1bGUoLi4uT2JqZWN0LnZhbHVlcyhkZWZhdWx0UGFyYW1zKSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIGlmKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0ZhaWxlZCB0byBnZW5lcmF0ZSBzY2hlZHVsZSB2aWEgT3BlbkFJLicpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKG9wZW5BSUVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGVzdCBDYXNlIDQ6IE9wZW5BSSByZXNwb25zZSBpcyBub3QgdmFsaWQgSlNPTi5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaWYgT3BlbkFJIHJlc3BvbnNlIGlzIG5vdCB2YWxpZCBKU09OJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBub25Kc29uUmVzcG9uc2UgPSBcIlRoaXMgaXMganVzdCBwbGFpbiB0ZXh0LlwiO1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogbm9uSnNvblJlc3BvbnNlIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVEYXlTY2hlZHVsZSguLi5PYmplY3QudmFsdWVzKGRlZmF1bHRQYXJhbXMpKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIHBhcnNlIHNjaGVkdWxlIGZyb20gT3BlbkFJIHJlc3BvbnNlIGFzIEpTT04uJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLnJhd1Jlc3BvbnNlKS50b0JlKG5vbkpzb25SZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRlc3QgQ2FzZSA1OiBPcGVuQUkgcmVzcG9uc2UgaXMgSlNPTiBidXQgbm90IGFuIGFycmF5LlxuICAgIGl0KCdzaG91bGQgZmFpbCBpZiBPcGVuQUkgcmVzcG9uc2UgaXMgSlNPTiBidXQgbm90IGFuIGFycmF5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBub25BcnJheUpzb25SZXNwb25zZSA9IEpTT04uc3RyaW5naWZ5KHsgdGFzazogXCJBIHNpbmdsZSBvYmplY3QsIG5vdCBhbiBhcnJheVwiIH0pO1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogbm9uQXJyYXlKc29uUmVzcG9uc2UgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZURheVNjaGVkdWxlKC4uLk9iamVjdC52YWx1ZXMoZGVmYXVsdFBhcmFtcykpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdPcGVuQUkgc2NoZWR1bGUgcmVzcG9uc2UgaXMgbm90IGEgdmFsaWQgYXJyYXkuJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLnBhcnNlZFJlc3BvbnNlKS50b0VxdWFsKEpTT04ucGFyc2Uobm9uQXJyYXlKc29uUmVzcG9uc2UpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGVzdCBDYXNlIDY6IE9uZSBvZiB0aGUgY3JlYXRlR29vZ2xlRXZlbnQgY2FsbHMgZmFpbHMgKGZvciBub24tYWxsLWRheSkuXG4gICAgaXQoJ3Nob3VsZCBmYWlsIGlmIGEgY3JlYXRlR29vZ2xlRXZlbnQgY2FsbCBmYWlscyBmb3Igbm9uLWFsbC1kYXkgc2NoZWR1bGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtb2NrUGFyc2VkVGFza3NOb25BbGxEYXkpIH0pO1xuICAgICAgICBjb25zdCBnRXZlbnRFcnJvciA9IHsgbWVzc2FnZTogXCJRdW90YSBleGNlZWRlZCBmb3IgR0NhbFwiIH07XG4gICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5XG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tTdWNjZXNzZnVsR0V2ZW50Q3JlYXRlKSAvLyBGaXJzdCB0YXNrIHN1Y2NlZWRzXG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBnRXZlbnRFcnJvciB9KTsgLy8gU2Vjb25kIHRhc2sgZmFpbHNcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVEYXlTY2hlZHVsZSguLi5PYmplY3QudmFsdWVzKGRlZmF1bHRQYXJhbXMpKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbihgRmFpbGVkIHRvIGNyZWF0ZSBHb29nbGUgQ2FsZW5kYXIgZXZlbnQgZm9yIHRhc2s6IFwiJHttb2NrUGFyc2VkVGFza3NOb25BbGxEYXlbMV0udGFza31cImApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGdFdmVudEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTsgLy8gQ2FsbGVkIGZvciBmaXJzdCBhbmQgZmFpbGluZyBzZWNvbmRcbiAgICAgICAgZXhwZWN0KHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpOyAvLyBTaG91bGQgc3RvcCBiZWZvcmUgdXBzZXJ0aW5nXG4gICAgfSk7XG5cbiAgICAvLyBUZXN0IENhc2UgNzogdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXIgZmFpbHMuXG4gICAgaXQoJ3Nob3VsZCBmYWlsIGlmIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogSlNPTi5zdHJpbmdpZnkobW9ja1BhcnNlZFRhc2tzTm9uQWxsRGF5KSB9KTtcbiAgICAgICAgY29uc3QgdXBzZXJ0RXJyb3IgPSB7IG1lc3NhZ2U6IFwiREIgY29ubmVjdGlvbiBlcnJvclwiIH07XG4gICAgICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiB1cHNlcnRFcnJvciB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVEYXlTY2hlZHVsZSguLi5PYmplY3QudmFsdWVzKGRlZmF1bHRQYXJhbXMpKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIHNhdmUgc2NoZWR1bGVkIGV2ZW50cyB0byBkYXRhYmFzZS4nKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9FcXVhbCh1cHNlcnRFcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRlc3QgQ2FzZSA4OiBlbWFpbERhaWx5U2NoZWR1bGUgZmFpbHMgKGlmIGVtYWlsIHByb3ZpZGVkKS5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaWYgc2VuZEdlbmVyaWNUYXNrRW1haWwgKGZvcm1lcmx5IGVtYWlsRGFpbHlTY2hlZHVsZSkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShtb2NrUGFyc2VkVGFza3NOb25BbGxEYXkpIH0pO1xuICAgICAgICBjb25zdCBlbWFpbEVycm9yID0geyBtZXNzYWdlOiBcIk1haWwgc2VydmVyIGRvd25cIiB9O1xuICAgICAgICBzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZW1haWxFcnJvciB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVEYXlTY2hlZHVsZSguLi5PYmplY3QudmFsdWVzKGRlZmF1bHRQYXJhbXMpKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIHNlbmQgZGFpbHkgc2NoZWR1bGUgZW1haWwuJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoZW1haWxFcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFRlc3QgQ2FzZSA5OiBObyBuZXcgdGFza3MgdG8gc2NoZWR1bGUgYWZ0ZXIgZmlsdGVyaW5nIChhbGwgb3ZlcmxhcCBleGlzdGluZyBldmVudHMpLlxuICAgIGl0KCdzaG91bGQgc3VjY2VlZCB3aXRoIG5vIGV2ZW50cyBjcmVhdGVkIGlmIGFsbCBwYXJzZWQgdGFza3Mgb3ZlcmxhcCBleGlzdGluZyBldmVudHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIE1ha2UgZXhpc3RpbmcgZXZlbnRzIG92ZXJsYXAgd2l0aCBib3RoIHBhcnNlZCB0YXNrc1xuICAgICAgICBjb25zdCBvdmVybGFwcGluZ0V4aXN0aW5nRXZlbnRzID0gW1xuICAgICAgICAgICAgeyBpZDogJ2V4aXN0MScsIHN1bW1hcnk6ICdPdmVybGFwIFRhc2sgMScsIHN0YXJ0RGF0ZVRpbWU6IGRheWpzLnR6KCcyMDI0LTA4LTE1IDA5OjMwIEFNJywgJ1lZWVktTU0tREQgaDptbSBBJywgZGVmYXVsdFBhcmFtcy51c2VyVGltZXpvbmUpLnRvSVNPU3RyaW5nKCksIGVuZERhdGVUaW1lOiBkYXlqcy50eignMjAyNC0wOC0xNSAxMTozMCBBTScsICdZWVlZLU1NLUREIGg6bW0gQScsIGRlZmF1bHRQYXJhbXMudXNlclRpbWV6b25lKS50b0lTT1N0cmluZygpIH0sXG4gICAgICAgICAgICB7IGlkOiAnZXhpc3QyJywgc3VtbWFyeTogJ092ZXJsYXAgVGFzayAyJywgc3RhcnREYXRlVGltZTogZGF5anMudHooJzIwMjQtMDgtMTUgMTozMCBQTScsICdZWVlZLU1NLUREIGg6bW0gQScsIGRlZmF1bHRQYXJhbXMudXNlclRpbWV6b25lKS50b0lTT1N0cmluZygpLCBlbmREYXRlVGltZTogZGF5anMudHooJzIwMjQtMDgtMTUgMzozMCBQTScsICdZWVlZLU1NLUREIGg6bW0gQScsIGRlZmF1bHRQYXJhbXMudXNlclRpbWV6b25lKS50b0lTT1N0cmluZygpIH1cbiAgICAgICAgXTtcbiAgICAgICAgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogb3ZlcmxhcHBpbmdFeGlzdGluZ0V2ZW50cyB9KTtcbiAgICAgICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1vY2tQYXJzZWRUYXNrc05vbkFsbERheSkgfSk7XG4gICAgICAgIHNlbmRHZW5lcmljVGFza0VtYWlsU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHtzdWNjZXNzOiB0cnVlfSk7IC8vIE1vY2sgZW1haWwgc3VjY2VzcyBmb3IgdGhpcyBwYXRoXG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlRGF5U2NoZWR1bGUoLi4uT2JqZWN0LnZhbHVlcyhkZWZhdWx0UGFyYW1zKSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTsgLy8gTm8gbmV3IG5vbi1vdmVybGFwcGluZyBldmVudHNcbiAgICAgICAgZXhwZWN0KHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXSk7IC8vIENhbGxlZCB3aXRoIGVtcHR5IGFycmF5XG4gICAgICAgIGV4cGVjdChzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICBkZWZhdWx0UGFyYW1zLmVtYWlsLFxuICAgICAgICAgICAgZGVmYXVsdFBhcmFtcy5uYW1lLFxuICAgICAgICAgICAgYFlvdXIgU2NoZWR1bGUgZm9yICR7ZGVmYXVsdFBhcmFtcy51c2VyRGF0ZX1gLFxuICAgICAgICAgICAgXCJZb3VyIGRheSBzY2hlZHVsZSB3YXMgcHJvY2Vzc2VkLiBBZnRlciBjaGVja2luZyBmb3Igb3ZlcmxhcHMgd2l0aCBleGlzdGluZyBldmVudHMsIG5vIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIHRvIHlvdXIgY2FsZW5kYXIuXCJcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2VlZCB3aXRoIG5vIGVtYWlsIGlmIG5vIG5ldyB0YXNrcyBwYXJzZWQgZnJvbSBPcGVuQUknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBKU09OLnN0cmluZ2lmeShbXSkgfSk7IC8vIE9wZW5BSSByZXR1cm5zIG5vIHRhc2tzXG4gICAgICAgIGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlc1NweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IFtdIH0pOyAvLyBObyBleGlzdGluZyBldmVudHNcblxuICAgICAgICBjb25zdCBwYXJhbXNOb0VtYWlsID0gey4uLmRlZmF1bHRQYXJhbXMsIGVtYWlsOiB1bmRlZmluZWQsIG5hbWU6IHVuZGVmaW5lZH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZURheVNjaGVkdWxlKC4uLk9iamVjdC52YWx1ZXMocGFyYW1zTm9FbWFpbCkpO1xuXG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIGV4cGVjdCh1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTsgLy8gTm90IGNhbGxlZCBiZWNhdXNlIGV2ZW50c1RvVXBzZXJ0IGlzIGVtcHR5XG4gICAgICAgIGV4cGVjdChzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcbn0pO1xuXG4vLyAtLS0gVGVzdHMgZm9yIG1lZXRpbmdSZXF1ZXN0IC0tLVxuaW1wb3J0IHsgbWVldGluZ1JlcXVlc3QgfSBmcm9tICcuL2FwaS1oZWxwZXInO1xuLy8gU3BpZXMgZm9yIGFwaUhlbHBlck1vZHVsZSBmdW5jdGlvbnMgd2lsbCBiZSBzZXQgdXAgaW4gZGVzY3JpYmUgYmxvY2suXG4vLyBnZW5lcmF0ZUF2YWlsYWJpbGl0eSBpcyBhbHNvIHBhcnQgb2YgYXBpSGVscGVyTW9kdWxlIG5vdyAoYXMgYSBwbGFjZWhvbGRlciB0byBiZSBzcGllZCB1cG9uKS5cblxuZGVzY3JpYmUoJ21lZXRpbmdSZXF1ZXN0JywgKCkgPT4ge1xuICAgIGxldCBnZW5lcmF0ZUF2YWlsYWJpbGl0eVNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgY2FsbE9wZW5BSVNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGVTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgY29uc3QgY29uc29sZUxvZ1NweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2xvZycpLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiB7fSk7XG5cbiAgICBjb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyX21yX3Rlc3QnLFxuICAgICAgICBjbGllbnRUeXBlOiAnd2ViJyBhcyAnd2ViJyxcbiAgICAgICAgdXNlclRpbWV6b25lOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gICAgICAgIHVzZXJEYXRlQ29udGV4dDogJ25leHQgd2VlaycsXG4gICAgICAgIGF0dGVuZGVlczogJ2JvYkBleGFtcGxlLmNvbSwgYWxpY2VAZXhhbXBsZS5jb20nLFxuICAgICAgICBzdWJqZWN0OiAnUHJvamVjdCBTeW5jJyxcbiAgICAgICAgcHJvbXB0OiAnTmVlZCB0byBkaXNjdXNzIFEzIGdvYWxzLicsXG4gICAgICAgIGR1cmF0aW9uTWludXRlczogMzAsXG4gICAgICAgIHNoYXJlQXZhaWxhYmlsaXR5OiB0cnVlLFxuICAgICAgICBhdmFpbGFiaWxpdHlVc2VyRGF0ZVN0YXJ0OiAnMjAyNC0wOC0wMScsXG4gICAgICAgIGF2YWlsYWJpbGl0eVVzZXJEYXRlRW5kOiAnMjAyNC0wOC0wMycsXG4gICAgICAgIGVtYWlsVG86ICdsZWFkQGV4YW1wbGUuY29tJyxcbiAgICAgICAgZW1haWxOYW1lOiAnUHJvamVjdCBMZWFkJyxcbiAgICAgICAgeWVzTGluazogJ2h0dHA6Ly9leGFtcGxlLmNvbS95ZXMnLFxuICAgICAgICBub0xpbms6ICdodHRwOi8vZXhhbXBsZS5jb20vbm8nLFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrQXZhaWxhYmlsaXR5U2xvdHMgPSBbXG4gICAgICAgIHsgc3RhcnREYXRlOiAnMjAyNC0wOC0wMVQxMDowMDowMFonLCBlbmREYXRlOiAnMjAyNC0wOC0wMVQxMTowMDowMFonIH0sXG4gICAgICAgIHsgc3RhcnREYXRlOiAnMjAyNC0wOC0wMVQxNDowMDowMFonLCBlbmREYXRlOiAnMjAyNC0wOC0wMVQxNTowMDowMFonIH0sXG4gICAgICAgIHsgc3RhcnREYXRlOiAnMjAyNC0wOC0wMlQwOTowMDowMFonLCBlbmREYXRlOiAnMjAyNC0wOC0wMlQxMDowMDowMFonIH0sXG4gICAgXTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgZ2VuZXJhdGVBdmFpbGFiaWxpdHlTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2dlbmVyYXRlQXZhaWxhYmlsaXR5Jyk7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NhbGxPcGVuQUknKTtcbiAgICAgICAgc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGVTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ3NlbmRNZWV0aW5nUmVxdWVzdFRlbXBsYXRlJyk7XG4gICAgfSk7XG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgY29uc29sZUxvZ1NweS5tb2NrUmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gVGVzdCBDYXNlIDE6IFN1Y2Nlc3Mgd2l0aCBhdmFpbGFiaWxpdHkgc2hhcmluZy5cbiAgICBpdCgnc2hvdWxkIHN1Y2NlZWQgd2l0aCBhdmFpbGFiaWxpdHkgc2hhcmluZyB3aGVuIGFsbCBoZWxwZXJzIHN1Y2NlZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlQXZhaWxhYmlsaXR5U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0F2YWlsYWJpbGl0eVNsb3RzIH0pO1xuICAgICAgICAvLyBNb2NraW5nIG11bHRpcGxlIGNhbGxzIHRvIGNhbGxPcGVuQUkgaW4gb3JkZXJcbiAgICAgICAgY2FsbE9wZW5BSVNweVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdTdW1tYXJ5IGZvciAyMDI0LTA4LTAxJyB9KSAvLyBEYWlseSBzdW1tYXJ5IGZvciAyMDI0LTA4LTAxXG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogJ1N1bW1hcnkgZm9yIDIwMjQtMDgtMDInIH0pIC8vIERhaWx5IHN1bW1hcnkgZm9yIDIwMjQtMDgtMDJcbiAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiAnRmluYWwgY29tYmluZWQgYXZhaWxhYmlsaXR5IHN1bW1hcnknIH0pIC8vIENvbWJpbmVkIHN1bW1hcnlcbiAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiAnRHJhZnRlZCBlbWFpbCBib2R5IHdpdGggYXZhaWxhYmlsaXR5JyB9KTsgLy8gRW1haWwgZHJhZnRcbiAgICAgICAgc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGVTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1lZXRpbmdSZXF1ZXN0KC4uLk9iamVjdC52YWx1ZXMoZGVmYXVsdFBhcmFtcykpO1xuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgZXhwZWN0KGdlbmVyYXRlQXZhaWxhYmlsaXR5U3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChjYWxsT3BlbkFJU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoNCk7IC8vIDIgZGFpbHkgKyAxIGNvbWJpbmVkICsgMSBlbWFpbCBkcmFmdFxuICAgICAgICBleHBlY3Qoc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIC8vIFRlc3QgQ2FzZSAyOiBTdWNjZXNzIHdpdGhvdXQgYXZhaWxhYmlsaXR5IHNoYXJpbmcuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZWVkIHdpdGhvdXQgYXZhaWxhYmlsaXR5IHNoYXJpbmcnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogJ0RyYWZ0ZWQgZW1haWwgYm9keSB3aXRob3V0IGF2YWlsYWJpbGl0eScgfSk7IC8vIEVtYWlsIGRyYWZ0XG4gICAgICAgIHNlbmRNZWV0aW5nUmVxdWVzdFRlbXBsYXRlU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSB9KTtcblxuICAgICAgICBjb25zdCBwYXJhbXNOb0F2YWlsYWJpbGl0eSA9IHsgLi4uZGVmYXVsdFBhcmFtcywgc2hhcmVBdmFpbGFiaWxpdHk6IGZhbHNlIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1lZXRpbmdSZXF1ZXN0KC4uLk9iamVjdC52YWx1ZXMocGFyYW1zTm9BdmFpbGFiaWxpdHkpKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgZXhwZWN0KGdlbmVyYXRlQXZhaWxhYmlsaXR5U3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICBleHBlY3QoY2FsbE9wZW5BSVNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpOyAvLyBPbmx5IGZvciBlbWFpbCBkcmFmdFxuICAgICAgICBleHBlY3Qoc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGVTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2VlZCB3aXRob3V0IGF2YWlsYWJpbGl0eSBzaGFyaW5nIGFuZCBubyBlbWFpbCByZWNpcGllbnQgKGRyYWZ0IG9ubHkpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdEcmFmdGVkIGVtYWlsIGJvZHksIG5vIHJlY2lwaWVudCcgfSk7XG5cbiAgICAgICAgY29uc3QgcGFyYW1zTm9SZWNpcGllbnQgPSB7IC4uLmRlZmF1bHRQYXJhbXMsIHNoYXJlQXZhaWxhYmlsaXR5OiBmYWxzZSwgZW1haWxUbzogdW5kZWZpbmVkLCBlbWFpbE5hbWU6IHVuZGVmaW5lZCwgeWVzTGluazogdW5kZWZpbmVkLCBub0xpbms6IHVuZGVmaW5lZCB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBtZWV0aW5nUmVxdWVzdCguLi5PYmplY3QudmFsdWVzKHBhcmFtc05vUmVjaXBpZW50KSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgICBleHBlY3QoZ2VuZXJhdGVBdmFpbGFiaWxpdHlTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICAgIGV4cGVjdChjYWxsT3BlbkFJU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChzZW5kTWVldGluZ1JlcXVlc3RUZW1wbGF0ZVNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTsgLy8gRW1haWwgbm90IHNlbnRcbiAgICB9KTtcblxuXG4gICAgLy8gVGVzdCBDYXNlIDM6IGdlbmVyYXRlQXZhaWxhYmlsaXR5IHJldHVybnMgc3VjY2VzczogZmFsc2UuXG4gICAgaXQoJ3Nob3VsZCBmYWlsIGlmIGdlbmVyYXRlQXZhaWxhYmlsaXR5IHJldHVybnMgc3VjY2VzczpmYWxzZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZ2VuQXZhaWxFcnJvciA9IHsgbWVzc2FnZTogJ0ZhaWxlZCB0byBjb25uZWN0IHRvIGNhbGVuZGFyIEFQSScgfTtcbiAgICAgICAgZ2VuZXJhdGVBdmFpbGFiaWxpdHlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGdlbkF2YWlsRXJyb3IgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1lZXRpbmdSZXF1ZXN0KC4uLk9iamVjdC52YWx1ZXMoZGVmYXVsdFBhcmFtcykpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIGdlbmVyYXRlIGF2YWlsYWJpbGl0eS4nKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9FcXVhbChnZW5BdmFpbEVycm9yKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gVGVzdCBDYXNlIDQ6IGdlbmVyYXRlQXZhaWxhYmlsaXR5IHJldHVybnMgc3VjY2VzczogdHJ1ZSwgZGF0YTogW10gKG5vIHNsb3RzKS5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaWYgZ2VuZXJhdGVBdmFpbGFiaWxpdHkgcmV0dXJucyBubyBzbG90cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2VuZXJhdGVBdmFpbGFiaWxpdHlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBbXSB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWVldGluZ1JlcXVlc3QoLi4uT2JqZWN0LnZhbHVlcyhkZWZhdWx0UGFyYW1zKSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIGlmKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdObyBhdmFpbGFiaWxpdHkgc2xvdHMgZm91bmQgdG8gc2hhcmUuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBpZiBhdmFpbGFiaWxpdHkgc3RhcnQvZW5kIGRhdGVzIGFyZSBtaXNzaW5nIHdoZW4gc2hhcmVBdmFpbGFiaWxpdHkgaXMgdHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zTWlzc2luZ0RhdGVzID0geyAuLi5kZWZhdWx0UGFyYW1zLCBhdmFpbGFiaWxpdHlVc2VyRGF0ZVN0YXJ0OiB1bmRlZmluZWQsIGF2YWlsYWJpbGl0eVVzZXJEYXRlRW5kOiB1bmRlZmluZWQgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWVldGluZ1JlcXVlc3QoLi4uT2JqZWN0LnZhbHVlcyhwYXJhbXNNaXNzaW5nRGF0ZXMpKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ0F2YWlsYWJpbGl0eSBzdGFydCBhbmQgZW5kIGRhdGVzIGFyZSByZXF1aXJlZCB3aGVuIHNoYXJlQXZhaWxhYmlsaXR5IGlzIHRydWUuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuXG4gICAgLy8gVGVzdCBDYXNlIDU6IEFueSBjYWxsT3BlbkFJIGNhbGwgZmFpbHMuXG4gICAgaXQoJ3Nob3VsZCBmYWlsIGlmIGZpcnN0IGNhbGxPcGVuQUkgKGRhaWx5IHN1bW1hcnkpIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZW5lcmF0ZUF2YWlsYWJpbGl0eVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tBdmFpbGFiaWxpdHlTbG90cyB9KTtcbiAgICAgICAgY29uc3Qgb3BlbkFJRXJyb3IgPSB7IG1lc3NhZ2U6IFwiQUkgZGFpbHkgc3VtbWFyeSBmYWlsZWRcIiB9O1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogb3BlbkFJRXJyb3IgfSk7IC8vIEZhaWwgZmlyc3QgZGFpbHkgc3VtbWFyeVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1lZXRpbmdSZXF1ZXN0KC4uLk9iamVjdC52YWx1ZXMoZGVmYXVsdFBhcmFtcykpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9NYXRjaCgvRmFpbGVkIHRvIHN1bW1hcml6ZSBhdmFpbGFiaWxpdHkgZm9yIGRhdGUvKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9FcXVhbChvcGVuQUlFcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBpZiBzZWNvbmQgY2FsbE9wZW5BSSAoY29tYmluZWQgc3VtbWFyeSkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlQXZhaWxhYmlsaXR5U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0F2YWlsYWJpbGl0eVNsb3RzIH0pO1xuICAgICAgICBjYWxsT3BlbkFJU3B5XG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogJ1N1bW1hcnkgZm9yIDIwMjQtMDgtMDEnIH0pXG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogJ1N1bW1hcnkgZm9yIDIwMjQtMDgtMDInIH0pXG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiB7bWVzc2FnZTogXCJBSSBjb21iaW5lZCBzdW1tYXJ5IGZhaWxlZFwifSB9KTsgLy8gRmFpbCBjb21iaW5lZFxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1lZXRpbmdSZXF1ZXN0KC4uLk9iamVjdC52YWx1ZXMoZGVmYXVsdFBhcmFtcykpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIGdlbmVyYXRlIGNvbWJpbmVkIGF2YWlsYWJpbGl0eSBzdW1tYXJ5LicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaWYgdGhpcmQgY2FsbE9wZW5BSSAoZW1haWwgZHJhZnQpIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZW5lcmF0ZUF2YWlsYWJpbGl0eVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tBdmFpbGFiaWxpdHlTbG90cyB9KTtcbiAgICAgICAgY2FsbE9wZW5BSVNweVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdTdW1tYXJ5IGZvciAyMDI0LTA4LTAxJyB9KVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdTdW1tYXJ5IGZvciAyMDI0LTA4LTAyJyB9KVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdGaW5hbCBjb21iaW5lZCBhdmFpbGFiaWxpdHkgc3VtbWFyeScgfSlcbiAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHttZXNzYWdlOiBcIkFJIGVtYWlsIGRyYWZ0IGZhaWxlZFwifSB9KTsgLy8gRmFpbCBlbWFpbCBkcmFmdFxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG1lZXRpbmdSZXF1ZXN0KC4uLk9iamVjdC52YWx1ZXMoZGVmYXVsdFBhcmFtcykpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIGRyYWZ0IG1lZXRpbmcgcmVxdWVzdCBlbWFpbCBib2R5LicpO1xuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIC8vIFRlc3QgQ2FzZSA2OiBzZW5kTWVldGluZ1JlcXVlc3RUZW1wbGF0ZSBmYWlscy5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaWYgc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdlbmVyYXRlQXZhaWxhYmlsaXR5U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogbW9ja0F2YWlsYWJpbGl0eVNsb3RzIH0pO1xuICAgICAgICBjYWxsT3BlbkFJU3B5XG4gICAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogJ0RhaWx5IHN1bW1hcnkgMScgfSlcbiAgICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiAnRGFpbHkgc3VtbWFyeSAyJyB9KVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdDb21iaW5lZCBzdW1tYXJ5JyB9KVxuICAgICAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdFbWFpbCBib2R5JyB9KTtcbiAgICAgICAgY29uc3QgZW1haWxFcnJvciA9IHsgbWVzc2FnZTogXCJTTVRQIGVycm9yXCIgfTtcbiAgICAgICAgc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGVTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVtYWlsRXJyb3IgfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbWVldGluZ1JlcXVlc3QoLi4uT2JqZWN0LnZhbHVlcyhkZWZhdWx0UGFyYW1zKSk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgIGlmKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdGYWlsZWQgdG8gc2VuZCBtZWV0aW5nIHJlcXVlc3QgZW1haWwuJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoZW1haWxFcnJvcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4vLyAtLS0gVGVzdHMgZm9yIE9yY2hlc3RyYXRvciBGdW5jdGlvbnM6IGNyZWF0ZVN1bW1hcnlPZlRpbWVQZXJpb2QsIGJyZWFrRG93blRhc2ssIGhvd1RvVGFzayAtLS1cbmltcG9ydCB7XG4gICAgY3JlYXRlU3VtbWFyeU9mVGltZVBlcmlvZCxcbiAgICBicmVha0Rvd25UYXNrLFxuICAgIGhvd1RvVGFza1xufSBmcm9tICcuL2FwaS1oZWxwZXInO1xuLy8gU3BpZXMgZm9yIGFwaUhlbHBlck1vZHVsZSBmdW5jdGlvbnMgd2lsbCBiZSBzZXQgdXAgaW4gZGVzY3JpYmUgYmxvY2tzIG9yIGJlZm9yZUVhY2guXG4vLyBPdGhlciBuZWNlc3NhcnkgbW9ja3MgbGlrZSAnZ290JywgJ2dvb2dsZWFwaXMnLCAndXVpZCcsICdzZW5kRW1haWwnIGFyZSBhbHJlYWR5IHNldCB1cC5cblxuZGVzY3JpYmUoJ2NyZWF0ZVN1bW1hcnlPZlRpbWVQZXJpb2QnLCAoKSA9PiB7XG4gICAgbGV0IGxpc3RFdmVudHNGb3JEYXRlU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBjYWxsT3BlbkFJU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBzZW5kU3VtbWFyeUVtYWlsU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGNvbnN0IGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG5cbiAgICBjb25zdCBkZWZhdWx0UGFyYW1zID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyX3N1bV90ZXN0JyxcbiAgICAgICAgc3RhcnREYXRlOiAnMjAyNC0wMy0wMScsXG4gICAgICAgIGVuZERhdGU6ICcyMDI0LTAzLTA3JyxcbiAgICAgICAgdGltZXpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyxcbiAgICAgICAgZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJyxcbiAgICAgICAgbmFtZTogJ1Rlc3QgVXNlcicsXG4gICAgfTtcblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICAgICAgbGlzdEV2ZW50c0ZvckRhdGVTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2xpc3RFdmVudHNGb3JEYXRlJyk7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NhbGxPcGVuQUknKTtcbiAgICAgICAgc2VuZFN1bW1hcnlFbWFpbFNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnc2VuZFN1bW1hcnlFbWFpbCcpO1xuICAgIH0pO1xuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgY3JlYXRlIHN1bW1hcnkgYW5kIHNlbmQgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tFdmVudHMgPSBbeyBpZDogJ2UxJywgc3VtbWFyeTogJ0V2ZW50IDEnLCBzdGFydERhdGVUaW1lOiAnMjAyNC0wMy0wMVQxMDowMDowMFonLCBlbmREYXRlVGltZTogJzIwMjQtMDMtMDFUMTE6MDA6MDBaJyB9XTtcbiAgICAgICAgbGlzdEV2ZW50c0ZvckRhdGVTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBtb2NrRXZlbnRzIH0pO1xuICAgICAgICBjb25zdCBzdW1tYXJ5VGV4dCA9ICdUaGlzIGlzIGEgZ3JlYXQgc3VtbWFyeS4nO1xuICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogc3VtbWFyeVRleHQgfSk7XG4gICAgICAgIHNlbmRTdW1tYXJ5RW1haWxTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZVN1bW1hcnlPZlRpbWVQZXJpb2QoZGVmYXVsdFBhcmFtcy51c2VySWQsIGRlZmF1bHRQYXJhbXMuc3RhcnREYXRlLCBkZWZhdWx0UGFyYW1zLmVuZERhdGUsIGRlZmF1bHRQYXJhbXMudGltZXpvbmUsIGRlZmF1bHRQYXJhbXMuZW1haWwsIGRlZmF1bHRQYXJhbXMubmFtZSk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgICBpZihyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlKHN1bW1hcnlUZXh0KTtcbiAgICAgICAgZXhwZWN0KGxpc3RFdmVudHNGb3JEYXRlU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChjYWxsT3BlbkFJU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChzZW5kU3VtbWFyeUVtYWlsU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSBjcmVhdGUgc3VtbWFyeSB3aXRob3V0IHNlbmRpbmcgZW1haWwgaWYgZW1haWwvbmFtZSBub3QgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1vY2tFdmVudHMgPSBbeyBpZDogJ2UxJywgc3VtbWFyeTogJ0V2ZW50IDEnIH1dO1xuICAgICAgICBsaXN0RXZlbnRzRm9yRGF0ZVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IG1vY2tFdmVudHMgfSk7XG4gICAgICAgIGNvbnN0IHN1bW1hcnlUZXh0ID0gJ1N1bW1hcnkgdGV4dCBoZXJlLic7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBzdW1tYXJ5VGV4dCB9KTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVTdW1tYXJ5T2ZUaW1lUGVyaW9kKGRlZmF1bHRQYXJhbXMudXNlcklkLCBkZWZhdWx0UGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFBhcmFtcy5lbmREYXRlLCBkZWZhdWx0UGFyYW1zLnRpbWV6b25lKTtcblxuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICAgIGlmKHJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmRhdGEpLnRvQmUoc3VtbWFyeVRleHQpO1xuICAgICAgICBleHBlY3Qoc2VuZFN1bW1hcnlFbWFpbFNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgaWYgbGlzdEV2ZW50c0ZvckRhdGUgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RFcnJvciA9IHsgbWVzc2FnZTogJ0RCIGVycm9yIGxpc3RpbmcgZXZlbnRzJyB9O1xuICAgICAgICBsaXN0RXZlbnRzRm9yRGF0ZVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogbGlzdEVycm9yIH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVTdW1tYXJ5T2ZUaW1lUGVyaW9kKGRlZmF1bHRQYXJhbXMudXNlcklkLCBkZWZhdWx0UGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFBhcmFtcy5lbmREYXRlLCBkZWZhdWx0UGFyYW1zLnRpbWV6b25lKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignZXZlbnQgbGlzdGluZyBmYWlsdXJlJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwobGlzdEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoY2FsbE9wZW5BSVNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHNwZWNpZmljIGZhaWx1cmUgaWYgbm8gZXZlbnRzIGFyZSBmb3VuZCBieSBsaXN0RXZlbnRzRm9yRGF0ZScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGlzdEV2ZW50c0ZvckRhdGVTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBbXSB9KTsgLy8gTm8gZXZlbnRzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZVN1bW1hcnlPZlRpbWVQZXJpb2QoZGVmYXVsdFBhcmFtcy51c2VySWQsIGRlZmF1bHRQYXJhbXMuc3RhcnREYXRlLCBkZWZhdWx0UGFyYW1zLmVuZERhdGUsIGRlZmF1bHRQYXJhbXMudGltZXpvbmUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnTm8gZXZlbnRzIGZvdW5kIHRvIHN1bW1hcml6ZS4nKTtcbiAgICAgICAgfVxuICAgICAgICBleHBlY3QoY2FsbE9wZW5BSVNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgaWYgY2FsbE9wZW5BSSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgbGlzdEV2ZW50c0ZvckRhdGVTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiBbeyBpZDogJ2UxJyB9XSB9KTtcbiAgICAgICAgY29uc3Qgb3BlbkFJRXJyb3IgPSB7IG1lc3NhZ2U6ICdBSSB1bmF2YWlsYWJsZScgfTtcbiAgICAgICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogb3BlbkFJRXJyb3IgfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZVN1bW1hcnlPZlRpbWVQZXJpb2QoZGVmYXVsdFBhcmFtcy51c2VySWQsIGRlZmF1bHRQYXJhbXMuc3RhcnREYXRlLCBkZWZhdWx0UGFyYW1zLmVuZERhdGUsIGRlZmF1bHRQYXJhbXMudGltZXpvbmUpO1xuICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdPcGVuQUkgY2FsbCBmYWlsdXJlJyk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwob3BlbkFJRXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIGlmIHNlbmRTdW1tYXJ5RW1haWwgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGxpc3RFdmVudHNGb3JEYXRlU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogW3sgaWQ6ICdlMScgfV0gfSk7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBcInN1bW1hcnlcIiB9KTtcbiAgICAgICAgY29uc3QgZW1haWxFcnJvciA9IHsgbWVzc2FnZTogXCJTTVRQIGRvd25cIiB9O1xuICAgICAgICBzZW5kU3VtbWFyeUVtYWlsU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlbWFpbEVycm9yfSk7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlU3VtbWFyeU9mVGltZVBlcmlvZChkZWZhdWx0UGFyYW1zLnVzZXJJZCwgZGVmYXVsdFBhcmFtcy5zdGFydERhdGUsIGRlZmF1bHRQYXJhbXMuZW5kRGF0ZSwgZGVmYXVsdFBhcmFtcy50aW1lem9uZSwgZGVmYXVsdFBhcmFtcy5lbWFpbCwgZGVmYXVsdFBhcmFtcy5uYW1lKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRmFpbGVkIHRvIHNlbmQgc3VtbWFyeSBlbWFpbCcpO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGVtYWlsRXJyb3IpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXRyeSBhbmQgc3VjY2VlZCBpZiBHb29nbGUgQ2FsZW5kYXIgQVBJIGluc2VydCBmYWlscyBpbml0aWFsbHkgdGhlbiBzdWNjZWVkcycsIGFzeW5jICgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfYXV0aF90b2tlbicgfSk7XG4gICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgRXJyb3IoXCJHb29nbGUgQVBJIEVycm9yIEF0dGVtcHQgMVwiKTtcbiAgICAoYXBpRXJyb3IgYXMgYW55KS5jb2RlID0gNTAwOyAvLyBSZXRyeWFibGUgZXJyb3JcbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bEFwaVJlc3BvbnNlID0geyBkYXRhOiB7IGlkOiAnZ2NhbF9ldmVudF9yZXRyeV9zdWNjZXNzJywgc3VtbWFyeTogYmFzaWNFdmVudERldGFpbHMuc3VtbWFyeSB9IH07XG5cbiAgICBtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0XG4gICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKGFwaUVycm9yKSAvLyBGYWlscyBmaXJzdCB0aW1lXG4gICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKG1vY2tTdWNjZXNzZnVsQXBpUmVzcG9uc2UpOyAvLyBTdWNjZWVkcyBzZWNvbmQgdGltZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlR29vZ2xlRXZlbnQoXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy51c2VySWQsIGJhc2ljRXZlbnREZXRhaWxzLmNhbGVuZGFySWQsIGJhc2ljRXZlbnREZXRhaWxzLmNsaWVudFR5cGUsXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy5zdW1tYXJ5LCBiYXNpY0V2ZW50RGV0YWlscy5zdGFydERhdGVUaW1lLCBiYXNpY0V2ZW50RGV0YWlscy5lbmREYXRlVGltZSxcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLnRpbWV6b25lXG4gICAgKTtcblxuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5nb29nbGVFdmVudElkKS50b0JlKCdnY2FsX2V2ZW50X3JldHJ5X3N1Y2Nlc3MnKTtcbiAgICB9XG4gICAgZXhwZWN0KG1vY2tHb29nbGVFdmVudHNJbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTsgLy8gQ2FsbGVkIHR3aWNlICgxIGluaXRpYWwgKyAxIHJldHJ5KVxuICAgIC8vIENoZWNrIGxvZ2dlci53YXJuIHdhcyBjYWxsZWQgZm9yIHRoZSByZXRyeVxuICAgIGNvbnN0IHsgbG9jYWxBcGlIZWxwZXJMb2dnZXIgfSA9IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpOyAvLyBBY2Nlc3MgYWN0dWFsIGxvZ2dlciBpZiB0ZXN0cyBhcmUgaW4gc2FtZSBtb2R1bGUsIG9yIG1vY2tcbiAgICBleHBlY3QobG9jYWxBcGlIZWxwZXJMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIFwiUmV0cnlpbmcgR29vZ2xlIGV2ZW50IGNyZWF0aW9uXCIsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIG9wZXJhdGlvbl9uYW1lOiBcIkdvb2dsZUNyZWF0ZUV2ZW50X29uUmV0cnlcIixcbiAgICAgICAgICAgIGF0dGVtcHQ6IDIsIC8vIG9uUmV0cnkgaXMgY2FsbGVkICpiZWZvcmUqIHRoZSBuZXh0IGF0dGVtcHQsIHNvIGF0dGVtcHQgMiBpcyB0aGUgb25lIGJlaW5nIHByZXBhcmVkXG4gICAgICAgICAgICBlcnJvcl9tZXNzYWdlOiBcIkdvb2dsZSBBUEkgRXJyb3IgQXR0ZW1wdCAxXCIsXG4gICAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBmYWlsIGFmdGVyIGFsbCByZXRyaWVzIGlmIEdvb2dsZSBDYWxlbmRhciBBUEkgaW5zZXJ0IGNvbnNpc3RlbnRseSBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfYXV0aF90b2tlbicgfSk7XG4gICAgY29uc3QgYXBpRXJyb3IxID0gbmV3IEVycm9yKFwiR29vZ2xlIEFQSSBFcnJvciBBdHRlbXB0IDFcIik7IChhcGlFcnJvcjEgYXMgYW55KS5jb2RlID0gNTAzO1xuICAgIGNvbnN0IGFwaUVycm9yMiA9IG5ldyBFcnJvcihcIkdvb2dsZSBBUEkgRXJyb3IgQXR0ZW1wdCAyXCIpOyAoYXBpRXJyb3IyIGFzIGFueSkuY29kZSA9IDUwMztcbiAgICBjb25zdCBhcGlFcnJvcjMgPSBuZXcgRXJyb3IoXCJHb29nbGUgQVBJIEVycm9yIEF0dGVtcHQgM1wiKTsgKGFwaUVycm9yMyBhcyBhbnkpLmNvZGUgPSA1MDM7XG4gICAgIC8vIGFzeW5jLXJldHJ5IGRlZmF1bHQgaXMgMyByZXRyaWVzLCBzbyA0IGNhbGxzIHRvdGFsICgxIGluaXRpYWwgKyAzIHJldHJpZXMpXG4gICAgIC8vIEhvd2V2ZXIsIHRoZSBjdXJyZW50IGNvbmZpZyBpbiBjcmVhdGVHb29nbGVFdmVudCBpcyByZXRyaWVzOiAzIChtZWFuaW5nIDEgaW5pdGlhbCArIHVwIHRvIDMgcmV0cmllcywgdG90YWwgNCBhdHRlbXB0cylcbiAgICAgLy8gTGV0J3MgYWRqdXN0IHRvIG1hdGNoIHRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uOiByZXRyaWVzOiAzIG1lYW5zIDEgaW5pdGlhbCArIDMgcmV0cmllcyAoNCB0b3RhbCBjYWxscykuXG4gICAgIC8vIFRoZSBwcm92aWRlZCBjb2RlIGhhcyByZXRyaWVzOiAzIGluIHRoZSByZXRyeSBvcHRpb25zLCB3aGljaCB0eXBpY2FsbHkgbWVhbnMgMSBpbml0aWFsICsgMyByZXRyaWVzID0gNCB0b3RhbCBhdHRlbXB0cy5cbiAgICAgLy8gVGhlIHRlc3Qgc2hvdWxkIG1vY2sgaXQgdG8gZmFpbCA0IHRpbWVzIGlmIHRoYXQncyB0aGUgY29uZmlnLlxuICAgICAvLyBUaGUgY3JlYXRlR29vZ2xlRXZlbnQgaGFzIGByZXRyaWVzOiAzYC4gYXN5bmMtcmV0cnkncyBgcmV0cmllc2Agb3B0aW9uIG1lYW5zIFwidG90YWwgbnVtYmVyIG9mIGF0dGVtcHRzIGlzIHJldHJpZXMgKyAxXCIuXG4gICAgIC8vIFNvLCAzIHJldHJpZXMgbWVhbnMgNCBhdHRlbXB0cy5cbiAgICBtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0XG4gICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKGFwaUVycm9yMSlcbiAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UoYXBpRXJyb3IyKVxuICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZShhcGlFcnJvcjMpXG4gICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKG5ldyBFcnJvcihcIkdvb2dsZSBBUEkgRXJyb3IgQXR0ZW1wdCA0XCIpKTsgLy8gU2hvdWxkIGZhaWwgb24gdGhlIDR0aCBhdHRlbXB0IGlmIHJldHJpZXMgPSAzXG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVHb29nbGVFdmVudChcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLnVzZXJJZCwgYmFzaWNFdmVudERldGFpbHMuY2FsZW5kYXJJZCwgYmFzaWNFdmVudERldGFpbHMuY2xpZW50VHlwZSxcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLnN1bW1hcnksIGJhc2ljRXZlbnREZXRhaWxzLnN0YXJ0RGF0ZVRpbWUsIGJhc2ljRXZlbnREZXRhaWxzLmVuZERhdGVUaW1lLFxuICAgICAgYmFzaWNFdmVudERldGFpbHMudGltZXpvbmVcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignR29vZ2xlIENhbGVuZGFyIEFQSSBlcnJvciBkdXJpbmcgZXZlbnQgY3JlYXRpb246IEdvb2dsZSBBUEkgRXJyb3IgQXR0ZW1wdCA0Jyk7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoNCk7IC8vIDEgaW5pdGlhbCArIDMgcmV0cmllc1xuICAgIGNvbnN0IHsgbG9jYWxBcGlIZWxwZXJMb2dnZXIgfSA9IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpO1xuICAgIGV4cGVjdChsb2NhbEFwaUhlbHBlckxvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7IC8vIFdhcm5zIG9uIGVhY2ggcmV0cnlcbiAgICAvLyBDaGVjayB0aGUgZmluYWwgZXJyb3IgbG9nIGlmIG9uZSBpcyBhZGRlZCBpbiB0aGUgY2F0Y2ggYmxvY2sgb2YgY3JlYXRlR29vZ2xlRXZlbnQgYWZ0ZXIgYWxsIHJldHJpZXNcbiAgICAvLyBUaGUgY3VycmVudCBjcmVhdGVHb29nbGVFdmVudCByZS10aHJvd3MsIHNvIHRoZSBmaW5hbCBlcnJvciBjb21lcyBmcm9tIGFzeW5jLXJldHJ5J3MgbGFzdCBhdHRlbXB0LlxuICAgIC8vIGxvY2FsQXBpSGVscGVyTG9nZ2VyLmVycm9yIHdvdWxkIGJlIGNhbGxlZCBpZiB0aGUgZnVuY3Rpb24gaXRzZWxmIGNhdWdodCB0aGUgZmluYWwgZXJyb3IgYW5kIGxvZ2dlZCBpdC5cbiAgICAvLyBUaGUgdGVzdCBhbHJlYWR5IGFzc2VydHMgdGhlIGVycm9yIG1lc3NhZ2UuXG4gIH0pO1xufSk7XG5cblxuZGVzY3JpYmUoJ2JyZWFrRG93blRhc2sgYW5kIGhvd1RvVGFzayBjb21tb24gaGVscGVyIG1vY2tzJywgKCkgPT4ge1xuICAgIC8vIFRoZXNlIHNwaWVzIGFyZSBjb21tb24gdG8gYnJlYWtEb3duVGFzayBhbmQgaG93VG9UYXNrXG4gICAgbGV0IGNhbGxPcGVuQUlTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgbGV0IGdldEdsb2JhbENhbGVuZGFyU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICAgIGxldCBjcmVhdGVHb29nbGVFdmVudFNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gICAgLy8gRW1haWwgc3BpZXMgd2lsbCBiZSBzcGVjaWZpYyB0byBlYWNoIGZ1bmN0aW9uJ3MgZGVzY3JpYmUgYmxvY2tcbiAgICBjb25zdCBjb25zb2xlTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcblxuICAgIGNvbnN0IGRlZmF1bHRUYXNrUGFyYW1zID0ge1xuICAgICAgICB1c2VySWQ6ICd1c2VyX3Rhc2tfdGVzdCcsXG4gICAgICAgIGNsaWVudFR5cGU6ICd3ZWInIGFzICd3ZWInIHwgJ2lvcycgfCAnYW5kcm9pZCcgfCAnYXRvbWljLXdlYicsXG4gICAgICAgIHVzZXJUaW1lem9uZTogJ0FtZXJpY2EvTG9zX0FuZ2VsZXMnLFxuICAgICAgICB0YXNrVGl0bGU6ICdQbGFuIFEzIFJvYWRtYXAnLFxuICAgICAgICB0YXNrRGVzY3JpcHRpb246ICdEZXRhaWxlZCBwbGFubmluZyBmb3IgYWxsIFEzIGZlYXR1cmVzLicsXG4gICAgICAgIGlzQWxsRGF5OiBmYWxzZSxcbiAgICAgICAgc3RhcnREYXRlOiAnMjAyNC0wNy0wMVQwMDowMDowMFonLCAvLyBBc3N1bWluZyBzcGVjaWZpYyB0aW1lIGlmIG5vdCBhbGwtZGF5XG4gICAgICAgIGVuZERhdGU6ICcyMDI0LTA3LTAxVDAyOjAwOjAwWicsXG4gICAgICAgIGVtYWlsOiAndXNlckBleGFtcGxlLmNvbScsXG4gICAgICAgIG5hbWU6ICdUYXNrIFVzZXInLFxuICAgIH07XG5cbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bE9wZW5BSV9UYXNrID0geyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiAnVGFzayBicmVha2Rvd24gZGV0YWlscyBvciBIb3ctdG8gc3RlcHMnIH07XG4gICAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGlkOiAndGFza0NhbElkJywgcHJpbWFyeUNhbGVuZGFySWQ6ICdwcmltYXJ5VGFza0NhbCcgfSB9O1xuICAgIGNvbnN0IG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnRfVGFzayA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBpZDogJ2dFdmVudFRhc2sjcHJpbWFyeVRhc2tDYWwnLCBnb29nbGVFdmVudElkOiAnZ0V2ZW50VGFzaycsIGdlbmVyYXRlZElkOiAndXVpZFRhc2snLCBjYWxlbmRhcklkOiAncHJpbWFyeVRhc2tDYWwnIH0gfTtcbiAgICBjb25zdCBtb2NrU3VjY2Vzc2Z1bFVwc2VydF9UYXNrID0geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGFmZmVjdGVkX3Jvd3M6IDEsIHJldHVybmluZzogW3sgaWQ6ICdkYkV2ZW50VGFzaycgfV0gfSB9O1xuXG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgICAgIGNhbGxPcGVuQUlTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NhbGxPcGVuQUknKTtcbiAgICAgICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2dldEdsb2JhbENhbGVuZGFyJyk7XG4gICAgICAgIC8vIE5vdGU6IGNyZWF0ZUV2ZW50SGVscGVyIGlzIG5vdCBleHBvcnRlZCwgc28gd2UgdGVzdCBpdHMgZWZmZWN0cyBieSBtb2NraW5nIGl0cyBkZXBlbmRlbmNpZXM6XG4gICAgICAgIC8vIGdldEdsb2JhbENhbGVuZGFyIChhbHJlYWR5IHNwaWVkKSBhbmQgY3JlYXRlR29vZ2xlRXZlbnQgKHNwaWVkIGJlbG93KVxuICAgICAgICAvLyBnZXRHb29nbGVBUElUb2tlbiBpcyBhbHNvIGNhbGxlZCBieSBjcmVhdGVHb29nbGVFdmVudCwgc28gd2UgZW5zdXJlIGl0J3Mgc3BpZWQgaWYgY3JlYXRlR29vZ2xlRXZlbnQgaXMgbm90IGZ1bGx5IG1vY2tlZCBvdXQuXG4gICAgICAgIC8vIEZvciBzaW1wbGljaXR5LCB3ZSdsbCBzcHkgb24gY3JlYXRlR29vZ2xlRXZlbnQgZGlyZWN0bHkgYXMgaXQncyBhbiBleHBvcnRlZCBoZWxwZXIuXG4gICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdjcmVhdGVHb29nbGVFdmVudCcpO1xuICAgICAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAndXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXInKTtcbiAgICB9KTtcblxuICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdicmVha0Rvd25UYXNrJywgKCkgPT4ge1xuICAgICAgICBsZXQgZW1haWxUYXNrQnJlYWtEb3duU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuXG4gICAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICAgICAgZW1haWxUYXNrQnJlYWtEb3duU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdlbWFpbFRhc2tCcmVha0Rvd24nKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgICAgICAgICBlbWFpbFRhc2tCcmVha0Rvd25TcHkubW9ja1Jlc3RvcmUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBzdWNjZXNzZnVsbHkgYnJlYWsgZG93biB0YXNrLCBjcmVhdGUgZXZlbnQsIGFuZCBzZW5kIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bE9wZW5BSV9UYXNrKTtcbiAgICAgICAgICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXJfVGFzayk7IC8vIEZvciBjcmVhdGVFdmVudEhlbHBlciBhbmQgZm9yIGRpcmVjdCBjYWxsXG4gICAgICAgICAgICBjcmVhdGVHb29nbGVFdmVudFNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bENyZWF0ZUdvb2dsZUV2ZW50X1Rhc2spO1xuICAgICAgICAgICAgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxVcHNlcnRfVGFzayk7XG4gICAgICAgICAgICBlbWFpbFRhc2tCcmVha0Rvd25TcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBicmVha0Rvd25UYXNrKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJJZCwgZGVmYXVsdFRhc2tQYXJhbXMuY2xpZW50VHlwZSwgZGVmYXVsdFRhc2tQYXJhbXMudXNlclRpbWV6b25lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnRhc2tUaXRsZSwgZGVmYXVsdFRhc2tQYXJhbXMudGFza0Rlc2NyaXB0aW9uLCBkZWZhdWx0VGFza1BhcmFtcy5pc0FsbERheSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy5zdGFydERhdGUsIGRlZmF1bHRUYXNrUGFyYW1zLmVuZERhdGUsIGRlZmF1bHRUYXNrUGFyYW1zLmVtYWlsLCBkZWZhdWx0VGFza1BhcmFtcy5uYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgICAgICBleHBlY3QoY2FsbE9wZW5BSVNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICAgICAgZXhwZWN0KGNyZWF0ZUdvb2dsZUV2ZW50U3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgICAgICBleHBlY3QodXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgICAgIGV4cGVjdChlbWFpbFRhc2tCcmVha0Rvd25TcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBzdWNjZWVkIGZvciBhbGwtZGF5IGV2ZW50IHdpdGhvdXQgZW1haWwnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsT3BlbkFJX1Rhc2spO1xuICAgICAgICAgICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrKTtcbiAgICAgICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnRfVGFzayk7XG4gICAgICAgICAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bFVwc2VydF9UYXNrKTtcblxuICAgICAgICAgICAgY29uc3QgcGFyYW1zQWxsRGF5ID0geyAuLi5kZWZhdWx0VGFza1BhcmFtcywgaXNBbGxEYXk6IHRydWUsIGVtYWlsOiB1bmRlZmluZWQsIG5hbWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYnJlYWtEb3duVGFzayhcbiAgICAgICAgICAgICAgICBwYXJhbXNBbGxEYXkudXNlcklkLCBwYXJhbXNBbGxEYXkuY2xpZW50VHlwZSwgcGFyYW1zQWxsRGF5LnVzZXJUaW1lem9uZSxcbiAgICAgICAgICAgICAgICBwYXJhbXNBbGxEYXkudGFza1RpdGxlLCBwYXJhbXNBbGxEYXkudGFza0Rlc2NyaXB0aW9uLCBwYXJhbXNBbGxEYXkuaXNBbGxEYXksXG4gICAgICAgICAgICAgICAgZGF5anMocGFyYW1zQWxsRGF5LnN0YXJ0RGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyksIC8vIEFsbC1kYXkgZXhwZWN0cyBZWVlZLU1NLUREXG4gICAgICAgICAgICAgICAgZGF5anMocGFyYW1zQWxsRGF5LmVuZERhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpICAgIC8vIEFsbC1kYXkgZXhwZWN0cyBZWVlZLU1NLUREXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICAgICAgICBleHBlY3QoZW1haWxUYXNrQnJlYWtEb3duU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICAgICAgZXhwZWN0KGNyZWF0ZUdvb2dsZUV2ZW50U3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAgICAgICBleHBlY3QuYW55dGhpbmcoKSwgZXhwZWN0LmFueXRoaW5nKCksIGV4cGVjdC5hbnl0aGluZygpLCBleHBlY3QuYW55dGhpbmcoKSxcbiAgICAgICAgICAgICAgICBkYXlqcyhwYXJhbXNBbGxEYXkuc3RhcnREYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKSwgLy8gQ2hlY2sgYWxsLWRheSBkYXRlIGZvcm1hdFxuICAgICAgICAgICAgICAgIGRheWpzKHBhcmFtc0FsbERheS5lbmREYXRlKS5hZGQoMSwgJ2RheScpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLCAvLyBDaGVjayBhbGwtZGF5IGVuZCBkYXRlIGZvcm1hdFxuICAgICAgICAgICAgICAgIGV4cGVjdC5hbnl0aGluZygpLCBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBpdCgnc2hvdWxkIGZhaWwgaWYgY2FsbE9wZW5BSSBmYWlscyBmb3IgYnJlYWtEb3duVGFzaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHsgbWVzc2FnZTogXCJBSSBicm9rZVwiIH19KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJyZWFrRG93blRhc2soXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudXNlcklkLCBkZWZhdWx0VGFza1BhcmFtcy5jbGllbnRUeXBlLCBkZWZhdWx0VGFza1BhcmFtcy51c2VyVGltZXpvbmUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudGFza1RpdGxlLCBkZWZhdWx0VGFza1BhcmFtcy50YXNrRGVzY3JpcHRpb24sIGRlZmF1bHRUYXNrUGFyYW1zLmlzQWxsRGF5LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdPcGVuQUkgY2FsbCBmYWlsZWQnKTtcbiAgICAgICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCBmYWlsIGlmIGNyZWF0ZUdvb2dsZUV2ZW50ICh2aWEgaGVscGVyKSBmYWlscyBmb3IgYnJlYWtEb3duVGFzaycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUlfVGFzayk7XG4gICAgICAgICAgICBnZXRHbG9iYWxDYWxlbmRhclNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bEdsb2JhbENhbGVuZGFyX1Rhc2spOyAvLyBGb3IgY3JlYXRlRXZlbnRIZWxwZXJcbiAgICAgICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHtzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHttZXNzYWdlOiBcIkdDYWwgY3JlYXRlIGVycm9yXCJ9fSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJyZWFrRG93blRhc2soXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudXNlcklkLCBkZWZhdWx0VGFza1BhcmFtcy5jbGllbnRUeXBlLCBkZWZhdWx0VGFza1BhcmFtcy51c2VyVGltZXpvbmUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudGFza1RpdGxlLCBkZWZhdWx0VGFza1BhcmFtcy50YXNrRGVzY3JpcHRpb24sIGRlZmF1bHRUYXNrUGFyYW1zLmlzQWxsRGF5LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdHb29nbGUgZXZlbnQgY3JlYXRpb24gZmFpbGVkJyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgZmFpbCBpZiBlbWFpbFRhc2tCcmVha0Rvd24gZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsT3BlbkFJX1Rhc2spO1xuICAgICAgICAgICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrKTtcbiAgICAgICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnRfVGFzayk7XG4gICAgICAgICAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bFVwc2VydF9UYXNrKTtcbiAgICAgICAgICAgIGVtYWlsVGFza0JyZWFrRG93blNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogeyBtZXNzYWdlOiBcIkVtYWlsIGJyb2tlXCIgfSB9KTtcblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYnJlYWtEb3duVGFzayhcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy51c2VySWQsIGRlZmF1bHRUYXNrUGFyYW1zLmNsaWVudFR5cGUsIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJUaW1lem9uZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy50YXNrVGl0bGUsIGRlZmF1bHRUYXNrUGFyYW1zLnRhc2tEZXNjcmlwdGlvbiwgZGVmYXVsdFRhc2tQYXJhbXMuaXNBbGxEYXksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMuc3RhcnREYXRlLCBkZWZhdWx0VGFza1BhcmFtcy5lbmREYXRlLCBkZWZhdWx0VGFza1BhcmFtcy5lbWFpbCwgZGVmYXVsdFRhc2tQYXJhbXMubmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICAgICAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdFbWFpbCBzZW5kaW5nIGZhaWxlZCcpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdob3dUb1Rhc2snLCAoKSA9PiB7XG4gICAgICAgIGxldCBzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweTogamVzdC5TcHlJbnN0YW5jZTtcblxuICAgICAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIHNlbmRHZW5lcmljVGFza0VtYWlsU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdzZW5kR2VuZXJpY1Rhc2tFbWFpbCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgICAgIHNlbmRHZW5lcmljVGFza0VtYWlsU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IHByb2Nlc3MgaG93VG9UYXNrLCBjcmVhdGUgZXZlbnQsIGFuZCBzZW5kIGVtYWlsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bE9wZW5BSV9UYXNrKTtcbiAgICAgICAgICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXJfVGFzayk7XG4gICAgICAgICAgICBjcmVhdGVHb29nbGVFdmVudFNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bENyZWF0ZUdvb2dsZUV2ZW50X1Rhc2spO1xuICAgICAgICAgICAgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxVcHNlcnRfVGFzayk7XG4gICAgICAgICAgICBzZW5kR2VuZXJpY1Rhc2tFbWFpbFNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhvd1RvVGFzayhcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy51c2VySWQsIGRlZmF1bHRUYXNrUGFyYW1zLmNsaWVudFR5cGUsIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJUaW1lem9uZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy50YXNrVGl0bGUsIGRlZmF1bHRUYXNrUGFyYW1zLmlzQWxsRGF5LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW1haWwsIGRlZmF1bHRUYXNrUGFyYW1zLm5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgc3VjY2VzczogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGV4cGVjdChjYWxsT3BlbkFJU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgICAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICAgICAgICAgIGV4cGVjdCh1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICAgICAgZXhwZWN0KHNlbmRHZW5lcmljVGFza0VtYWlsU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgc3VjY2VlZCBmb3IgYWxsLWRheSBob3dUb1Rhc2sgZXZlbnQgd2l0aG91dCBlbWFpbCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUlfVGFzayk7XG4gICAgICAgICAgICBnZXRHbG9iYWxDYWxlbmRhclNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bEdsb2JhbENhbGVuZGFyX1Rhc2spO1xuICAgICAgICAgICAgY3JlYXRlR29vZ2xlRXZlbnRTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxDcmVhdGVHb29nbGVFdmVudF9UYXNrKTtcbiAgICAgICAgICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsVXBzZXJ0X1Rhc2spO1xuXG4gICAgICAgICAgICBjb25zdCBwYXJhbXNBbGxEYXkgPSB7IC4uLmRlZmF1bHRUYXNrUGFyYW1zLCBpc0FsbERheTogdHJ1ZSwgZW1haWw6IHVuZGVmaW5lZCwgbmFtZTogdW5kZWZpbmVkIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBob3dUb1Rhc2soXG4gICAgICAgICAgICAgICAgcGFyYW1zQWxsRGF5LnVzZXJJZCwgcGFyYW1zQWxsRGF5LmNsaWVudFR5cGUsIHBhcmFtc0FsbERheS51c2VyVGltZXpvbmUsXG4gICAgICAgICAgICAgICAgcGFyYW1zQWxsRGF5LnRhc2tUaXRsZSwgcGFyYW1zQWxsRGF5LmlzQWxsRGF5LFxuICAgICAgICAgICAgICAgIGRheWpzKHBhcmFtc0FsbERheS5zdGFydERhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxuICAgICAgICAgICAgICAgIGRheWpzKHBhcmFtc0FsbERheS5lbmREYXRlKS5mb3JtYXQoJ1lZWVktTU0tREQnKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgICAgICAgZXhwZWN0KHNlbmRHZW5lcmljVGFza0VtYWlsU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgICAgICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgICAgICAgZXhwZWN0LmFueXRoaW5nKCksIGV4cGVjdC5hbnl0aGluZygpLCBleHBlY3QuYW55dGhpbmcoKSwgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0hvdyB0bzonKSwgLy8gU3VtbWFyeSBjaGVja1xuICAgICAgICAgICAgICAgIGRheWpzKHBhcmFtc0FsbERheS5zdGFydERhdGUpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxuICAgICAgICAgICAgICAgIGRheWpzKHBhcmFtc0FsbERheS5lbmREYXRlKS5hZGQoMSwgJ2RheScpLmZvcm1hdCgnWVlZWS1NTS1ERCcpLFxuICAgICAgICAgICAgICAgIGV4cGVjdC5hbnl0aGluZygpLCBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICBpdCgnc2hvdWxkIGZhaWwgaWYgY2FsbE9wZW5BSSBmYWlscyBmb3IgaG93VG9UYXNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogeyBtZXNzYWdlOiBcIkFJIGJyb2tlIGhvd3RvXCIgfX0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaG93VG9UYXNrKFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJJZCwgZGVmYXVsdFRhc2tQYXJhbXMuY2xpZW50VHlwZSwgZGVmYXVsdFRhc2tQYXJhbXMudXNlclRpbWV6b25lLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnRhc2tUaXRsZSwgZGVmYXVsdFRhc2tQYXJhbXMuaXNBbGxEYXksXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMuc3RhcnREYXRlLCBkZWZhdWx0VGFza1BhcmFtcy5lbmREYXRlXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIGlmKCFyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ09wZW5BSSBjYWxsIGZhaWxlZCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGZhaWwgaWYgY3JlYXRlR29vZ2xlRXZlbnQgKHZpYSBoZWxwZXIpIGZhaWxzIGZvciBob3dUb1Rhc2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsT3BlbkFJX1Rhc2spO1xuICAgICAgICAgICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrKTtcbiAgICAgICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHtzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHttZXNzYWdlOiBcIkdDYWwgY3JlYXRlIGVycm9yIGhvd3RvXCJ9fSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhvd1RvVGFzayhcbiAgICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudXNlcklkLCBkZWZhdWx0VGFza1BhcmFtcy5jbGllbnRUeXBlLCBkZWZhdWx0VGFza1BhcmFtcy51c2VyVGltZXpvbmUsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFRhc2tQYXJhbXMudGFza1RpdGxlLCBkZWZhdWx0VGFza1BhcmFtcy5pc0FsbERheSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy5zdGFydERhdGUsIGRlZmF1bHRUYXNrUGFyYW1zLmVuZERhdGVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignR29vZ2xlIGV2ZW50IGNyZWF0aW9uIGZhaWxlZCcpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIGZhaWwgaWYgc2VuZEdlbmVyaWNUYXNrRW1haWwgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsT3BlbkFJU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsT3BlbkFJX1Rhc2spO1xuICAgICAgICAgICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcl9UYXNrKTtcbiAgICAgICAgICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnRfVGFzayk7XG4gICAgICAgICAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bFVwc2VydF9UYXNrKTtcbiAgICAgICAgICAgIHNlbmRHZW5lcmljVGFza0VtYWlsU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiB7IG1lc3NhZ2U6IFwiR2VuZXJpYyBlbWFpbCBicm9rZVwiIH0gfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhvd1RvVGFzayhcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy51c2VySWQsIGRlZmF1bHRUYXNrUGFyYW1zLmNsaWVudFR5cGUsIGRlZmF1bHRUYXNrUGFyYW1zLnVzZXJUaW1lem9uZSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VGFza1BhcmFtcy50YXNrVGl0bGUsIGRlZmF1bHRUYXNrUGFyYW1zLmlzQWxsRGF5LFxuICAgICAgICAgICAgICAgIGRlZmF1bHRUYXNrUGFyYW1zLnN0YXJ0RGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW5kRGF0ZSwgZGVmYXVsdFRhc2tQYXJhbXMuZW1haWwsIGRlZmF1bHRUYXNrUGFyYW1zLm5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgICAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignRW1haWwgc2VuZGluZyBmYWlsZWQnKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59KTtcblxuLy8gLS0tIFRlc3RzIGZvciBjcmVhdGVBZ2VuZGEgLS0tXG5pbXBvcnQgeyBjcmVhdGVBZ2VuZGEgfSBmcm9tICcuL2FwaS1oZWxwZXInO1xuaW1wb3J0ICogYXMgYXBpSGVscGVyTW9kdWxlIGZyb20gJy4vYXBpLWhlbHBlcic7IC8vIFVzZWQgZm9yIHNweWluZyBvbiBzZWxmLW1vZHVsZSBjYWxsc1xuLy8gc2VuZEVtYWlsIGlzIGFscmVhZHkgbW9ja2VkIGZyb20gRW1haWwgV3JhcHBlciBGdW5jdGlvbnMgdGVzdHMuXG4vLyBnb3QgaXMgYWxyZWFkeSBtb2NrZWQuXG4vLyBnb29nbGVhcGlzIGlzIGFscmVhZHkgbW9ja2VkLlxuLy8gdXVpZCBpcyBhbHJlYWR5IG1vY2tlZC5cblxuZGVzY3JpYmUoJ2NyZWF0ZUFnZW5kYScsICgpID0+IHtcbiAgbGV0IGNhbGxPcGVuQUlTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gIGxldCBnZXRHbG9iYWxDYWxlbmRhclNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgbGV0IGdldENhbGVuZGFySW50ZWdyYXRpb25TcHk6IGplc3QuU3B5SW5zdGFuY2U7IC8vIFRob3VnaCBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGNyZWF0ZUFnZW5kYSwgZ2V0R29vZ2xlQVBJVG9rZW4gY2FsbHMgaXQuXG4gIGxldCBjcmVhdGVHb29nbGVFdmVudFNweTogamVzdC5TcHlJbnN0YW5jZTtcbiAgbGV0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICBsZXQgc2VuZEFnZW5kYUVtYWlsU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuICBsZXQgZ2V0R29vZ2xlQVBJVG9rZW5TcHk6IGplc3QuU3B5SW5zdGFuY2U7IC8vIGNyZWF0ZUdvb2dsZUV2ZW50IGNhbGxzIHRoaXNcblxuICBjb25zdCBjb25zb2xlTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTsgLy8gQ2xlYXJzIGFsbCBtb2NrcyBpbmNsdWRpbmcgdGhvc2UgZm9yIGdvdCwgc2VuZEVtYWlsLCBldGMuXG5cbiAgICAvLyBTcHkgb24gYWxsIGhlbHBlciBmdW5jdGlvbnMgd2l0aGluIHRoZSBzYW1lIG1vZHVsZVxuICAgIGNhbGxPcGVuQUlTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2NhbGxPcGVuQUknKTtcbiAgICBnZXRHbG9iYWxDYWxlbmRhclNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0R2xvYmFsQ2FsZW5kYXInKTtcbiAgICAvLyBnZXRDYWxlbmRhckludGVncmF0aW9uU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdnZXRDYWxlbmRhckludGVncmF0aW9uJyk7IC8vIE5vdCBkaXJlY3RseSBjYWxsZWQgYnkgY3JlYXRlQWdlbmRhXG4gICAgZ2V0R29vZ2xlQVBJVG9rZW5TcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ2dldEdvb2dsZUFQSVRva2VuJyk7IC8vIFNwaWVkIGJlY2F1c2UgY3JlYXRlR29vZ2xlRXZlbnQgY2FsbHMgaXRcbiAgICBjcmVhdGVHb29nbGVFdmVudFNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnY3JlYXRlR29vZ2xlRXZlbnQnKTtcbiAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweSA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAndXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXInKTtcbiAgICBzZW5kQWdlbmRhRW1haWxTcHkgPSBqZXN0LnNweU9uKGFwaUhlbHBlck1vZHVsZSwgJ3NlbmRBZ2VuZGFFbWFpbCcpO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIC8vIFJlc3RvcmUgYWxsIHNwaWVzXG4gICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzdG9yZSgpO1xuICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgLy8gZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvblNweS5tb2NrUmVzdG9yZSgpO1xuICAgIGdldEdvb2dsZUFQSVRva2VuU3B5Lm1vY2tSZXN0b3JlKCk7XG4gICAgY3JlYXRlR29vZ2xlRXZlbnRTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICB1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweS5tb2NrUmVzdG9yZSgpO1xuICAgIHNlbmRBZ2VuZGFFbWFpbFNweS5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgfSk7XG5cbiAgY29uc3QgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcyA9IHtcbiAgICB1c2VySWQ6ICd1c2VyMTIzJyxcbiAgICBjbGllbnRUeXBlOiAnd2ViJyBhcyAnd2ViJyB8ICdpb3MnIHwgJ2FuZHJvaWQnIHwgJ2F0b21pYy13ZWInLFxuICAgIHVzZXJUaW1lem9uZTogJ0FtZXJpY2EvTmV3X1lvcmsnLFxuICAgIHVzZXJEYXRlOiAnMjAyNC0wMy0xNScsXG4gICAgcHJvbXB0OiAnQ3JlYXRlIGFuIGFnZW5kYSBmb3IgYSBwcm9kdWN0IHN0cmF0ZWd5IG1lZXRpbmcuJyxcbiAgICBlbWFpbDogJ3Rlc3RAZXhhbXBsZS5jb20nLFxuICAgIG5hbWU6ICdUZXN0IFVzZXInLFxuICB9O1xuXG4gIC8vIE1vY2sgc3VjY2Vzc2Z1bCByZXNwb25zZXMgZm9yIGFsbCBoZWxwZXJzIGJ5IGRlZmF1bHRcbiAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxPcGVuQUkgPSB7IHN1Y2Nlc3M6IHRydWUsIGNvbnRlbnQ6ICdHZW5lcmF0ZWQgQWdlbmRhIERldGFpbHMnIH07XG4gIGNvbnN0IG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIgPSB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHsgaWQ6ICdnbG9iYWxDYWxJZCcsIHByaW1hcnlDYWxlbmRhcklkOiAncHJpbWFyeUNhbDEyMycgfSB9O1xuICAvLyBnZXRHb29nbGVBUElUb2tlbiBpcyBjYWxsZWQgYnkgY3JlYXRlR29vZ2xlRXZlbnQsIHNvIGl0cyBtb2NrIGlzIGltcGxpY2l0IHZpYSBjcmVhdGVHb29nbGVFdmVudCdzIG1vY2sgaWYgbm90IHNwaWVkIGRpcmVjdGx5LlxuICAvLyBIb3dldmVyLCBjcmVhdGVHb29nbGVFdmVudCBpdHNlbGYgaXMgc3BpZWQgdXBvbiwgc28gd2UgY29udHJvbCBpdHMgZGlyZWN0IG91dHB1dC5cbiAgY29uc3QgbW9ja1N1Y2Nlc3NmdWxDcmVhdGVHb29nbGVFdmVudCA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBpZDogJ2dFdmVudDEyMyNwcmltYXJ5Q2FsMTIzJywgZ29vZ2xlRXZlbnRJZDogJ2dFdmVudDEyMycsIGdlbmVyYXRlZElkOiAndXVpZDEnLCBjYWxlbmRhcklkOiAncHJpbWFyeUNhbDEyMycgfSB9O1xuICBjb25zdCBtb2NrU3VjY2Vzc2Z1bFVwc2VydCA9IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogeyBhZmZlY3RlZF9yb3dzOiAxLCByZXR1cm5pbmc6IFt7IGlkOiAnZGJFdmVudElkNDU2JyB9XSB9IH07XG4gIGNvbnN0IG1vY2tTdWNjZXNzZnVsRW1haWwgPSB7IHN1Y2Nlc3M6IHRydWUgfTtcblxuICAvLyBUZXN0IENhc2UgMTogU3VjY2Vzc2Z1bCBhZ2VuZGEgY3JlYXRpb24gYW5kIGVtYWlsIHNlbnQuXG4gIGl0KCdzaG91bGQgc3VjY2Vzc2Z1bGx5IGNyZWF0ZSBhZ2VuZGEgYW5kIHNlbmQgZW1haWwgd2hlbiBhbGwgaGVscGVycyBzdWNjZWVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUkpO1xuICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIpO1xuICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnQpO1xuICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsVXBzZXJ0KTtcbiAgICBzZW5kQWdlbmRhRW1haWxTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxFbWFpbCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVBZ2VuZGEoXG4gICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJJZCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyVGltZXpvbmUsIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlckRhdGUsXG4gICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnByb21wdCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5lbWFpbCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5uYW1lXG4gICAgKTtcblxuICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgIGV4cGVjdChjYWxsT3BlbkFJU3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KGdldEdsb2JhbENhbGVuZGFyU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJJZCk7XG4gICAgZXhwZWN0KGNyZWF0ZUdvb2dsZUV2ZW50U3B5KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7IC8vIFNpbXBsaWZpZWQ6IG9uZSBldmVudFxuICAgIGV4cGVjdCh1cHNlcnRFdmVudHNQb3N0UGxhbm5lclNweSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIGV4cGVjdChzZW5kQWdlbmRhRW1haWxTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmVtYWlsLFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLm5hbWUsXG4gICAgICAgIFwiWW91ciBHZW5lcmF0ZWQgQWdlbmRhXCIsXG4gICAgICAgIG1vY2tTdWNjZXNzZnVsT3BlbkFJLmNvbnRlbnRcbiAgICApO1xuICB9KTtcblxuICAvLyBUZXN0IENhc2UgMjogY2FsbE9wZW5BSSBmYWlscy5cbiAgaXQoJ3Nob3VsZCBmYWlsIGlmIGNhbGxPcGVuQUkgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgb3BlbkFJRXJyb3IgPSB7IG1lc3NhZ2U6ICdPcGVuQUkgQVBJIGxpbWl0IHJlYWNoZWQnIH07XG4gICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogb3BlbkFJRXJyb3IgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVBZ2VuZGEoXG4gICAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlcklkLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmNsaWVudFR5cGUsXG4gICAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlclRpbWV6b25lLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJEYXRlLFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnByb21wdFxuICAgICk7XG5cbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGlmKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignT3BlbkFJIGNhbGwgZmFpbGVkJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9FcXVhbChvcGVuQUlFcnJvcik7XG4gICAgfVxuICAgIGV4cGVjdChnZXRHbG9iYWxDYWxlbmRhclNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICBleHBlY3QoY3JlYXRlR29vZ2xlRXZlbnRTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgZXhwZWN0KHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIGV4cGVjdChzZW5kQWdlbmRhRW1haWxTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gIH0pO1xuXG4gIC8vIFRlc3QgQ2FzZSAzOiBnZXRHbG9iYWxDYWxlbmRhciBmYWlscy5cbiAgaXQoJ3Nob3VsZCBmYWlsIGlmIGdldEdsb2JhbENhbGVuZGFyIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUkpO1xuICAgIGNvbnN0IGNhbGVuZGFyRXJyb3IgPSB7IG1lc3NhZ2U6ICdHbG9iYWwgY2FsZW5kYXIgbm90IGZvdW5kJyB9O1xuICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBjYWxlbmRhckVycm9yIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlQWdlbmRhKFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJJZCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJUaW1lem9uZSwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyRGF0ZSxcbiAgICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5wcm9tcHRcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2dsb2JhbCBjYWxlbmRhciByZXRyaWV2YWwgZmFpbHVyZScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoY2FsZW5kYXJFcnJvcik7XG4gICAgfVxuICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG5cbiAgLy8gVGVzdCBDYXNlIDQ6IGNyZWF0ZUdvb2dsZUV2ZW50IGZhaWxzLlxuICBpdCgnc2hvdWxkIGZhaWwgaWYgY3JlYXRlR29vZ2xlRXZlbnQgZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bE9wZW5BSSk7XG4gICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcik7XG4gICAgY29uc3QgZXZlbnRDcmVhdGlvbkVycm9yID0geyBtZXNzYWdlOiAnR29vZ2xlIENhbGVuZGFyIEFQSSBlcnJvcicgfTtcbiAgICBjcmVhdGVHb29nbGVFdmVudFNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXZlbnRDcmVhdGlvbkVycm9yIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlQWdlbmRhKFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJJZCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJUaW1lem9uZSwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyRGF0ZSxcbiAgICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5wcm9tcHRcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgaWYoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdHb29nbGUgZXZlbnQgY3JlYXRpb24gZmFpbHVyZScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoZXZlbnRDcmVhdGlvbkVycm9yKTtcbiAgICB9XG4gICAgZXhwZWN0KHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICB9KTtcblxuICAvLyBUZXN0IENhc2UgNTogc2VuZEFnZW5kYUVtYWlsIGZhaWxzICh3aGVuIGVtYWlsIGlzIHByb3ZpZGVkKS5cbiAgaXQoJ3Nob3VsZCBmYWlsIGlmIHNlbmRBZ2VuZGFFbWFpbCBmYWlscyB3aGVuIGVtYWlsIGlzIHByb3ZpZGVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUkpO1xuICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIpO1xuICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnQpO1xuICAgIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsVXBzZXJ0KTtcbiAgICBjb25zdCBlbWFpbFNlbmRFcnJvciA9IHsgbWVzc2FnZTogJ1NNVFAgc2VydmVyIGRvd24nIH07XG4gICAgc2VuZEFnZW5kYUVtYWlsU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBlbWFpbFNlbmRFcnJvciB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZUFnZW5kYShcbiAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlcklkLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmNsaWVudFR5cGUsXG4gICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJUaW1lem9uZSwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyRGF0ZSxcbiAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMucHJvbXB0LCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLmVtYWlsLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLm5hbWVcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2VtYWlsIHNlbmRpbmcgZmFpbHVyZScpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoZW1haWxTZW5kRXJyb3IpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGVzdCBDYXNlIDY6IFN1Y2Nlc3NmdWwgYWdlbmRhIGNyZWF0aW9uLCBubyBlbWFpbCB0byBzZW5kLlxuICBpdCgnc2hvdWxkIHN1Y2NlZWQgaWYgYWxsIGhlbHBlcnMgc3VjY2VlZCBhbmQgbm8gZW1haWwgaXMgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bE9wZW5BSSk7XG4gICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxHbG9iYWxDYWxlbmRhcik7XG4gICAgY3JlYXRlR29vZ2xlRXZlbnRTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxDcmVhdGVHb29nbGVFdmVudCk7XG4gICAgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxVcHNlcnQpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlQWdlbmRhKFxuICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VySWQsIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMuY2xpZW50VHlwZSxcbiAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlclRpbWV6b25lLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJEYXRlLFxuICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5wcm9tcHQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkIC8vIE5vIGVtYWlsLCBubyBuYW1lXG4gICAgKTtcblxuICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgIGV4cGVjdChzZW5kQWdlbmRhRW1haWxTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gIH0pO1xuXG4gIC8vIFRlc3QgQ2FzZSA3OiB1cHNlcnRFdmVudHNQb3N0UGxhbm5lciBmYWlscy5cbiAgaXQoJ3Nob3VsZCBmYWlsIGlmIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgIGNhbGxPcGVuQUlTcHkubW9ja1Jlc29sdmVkVmFsdWUobW9ja1N1Y2Nlc3NmdWxPcGVuQUkpO1xuICAgIGdldEdsb2JhbENhbGVuZGFyU3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsR2xvYmFsQ2FsZW5kYXIpO1xuICAgIGNyZWF0ZUdvb2dsZUV2ZW50U3B5Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tTdWNjZXNzZnVsQ3JlYXRlR29vZ2xlRXZlbnQpO1xuICAgIGNvbnN0IHVwc2VydEVycm9yID0geyBtZXNzYWdlOiAnRGF0YWJhc2UgY29uc3RyYWludCB2aW9sYXRpb24nIH07XG4gICAgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXJTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHVwc2VydEVycm9yIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlQWdlbmRhKFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJJZCwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5jbGllbnRUeXBlLFxuICAgICAgICBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJUaW1lem9uZSwgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VyRGF0ZSxcbiAgICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5wcm9tcHRcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ2RhdGFiYXNlIGV2ZW50IHVwc2VydCBmYWlsdXJlJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9FcXVhbCh1cHNlcnRFcnJvcik7XG4gICAgfVxuICAgIGV4cGVjdChzZW5kQWdlbmRhRW1haWxTcHkpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7IC8vIEVtYWlsIHNlbmRpbmcgaXMgdHlwaWNhbGx5IGFmdGVyIERCIHVwc2VydFxuICB9KTtcbiAgIGl0KCdzaG91bGQgZmFpbCBpZiBnZXRHbG9iYWxDYWxlbmRhciBkb2VzIG5vdCByZXR1cm4gcHJpbWFyeUNhbGVuZGFySWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY2FsbE9wZW5BSVNweS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrU3VjY2Vzc2Z1bE9wZW5BSSk7XG4gICAgZ2V0R2xvYmFsQ2FsZW5kYXJTcHkubW9ja1Jlc29sdmVkVmFsdWUoeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiB7IGlkOiAnZ2xvYmFsQ2FsSWQnIH0gYXMgYW55IH0pOyAvLyBObyBwcmltYXJ5Q2FsZW5kYXJJZFxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlQWdlbmRhKFxuICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy51c2VySWQsIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMuY2xpZW50VHlwZSxcbiAgICAgIGRlZmF1bHRDcmVhdGVBZ2VuZGFQYXJhbXMudXNlclRpbWV6b25lLCBkZWZhdWx0Q3JlYXRlQWdlbmRhUGFyYW1zLnVzZXJEYXRlLFxuICAgICAgZGVmYXVsdENyZWF0ZUFnZW5kYVBhcmFtcy5wcm9tcHRcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignZ2xvYmFsIGNhbGVuZGFyIHJldHJpZXZhbCBmYWlsdXJlJyk7XG4gICAgfVxuICAgIGV4cGVjdChjcmVhdGVHb29nbGVFdmVudFNweSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG59KTtcblxuLy8gLS0tIFRlc3RzIGZvciBFbWFpbCBXcmFwcGVyIEZ1bmN0aW9ucyAtLS1cbmltcG9ydCB7XG4gIHNlbmRBZ2VuZGFFbWFpbCxcbiAgc2VuZFN1bW1hcnlFbWFpbCxcbiAgZW1haWxUYXNrQnJlYWtEb3duLFxuICBzZW5kR2VuZXJpY1Rhc2tFbWFpbCxcbiAgc2VuZE1lZXRpbmdSZXF1ZXN0VGVtcGxhdGUsXG59IGZyb20gJy4vYXBpLWhlbHBlcic7XG5pbXBvcnQgeyBzZW5kRW1haWwgfSBmcm9tICdAL191dGlscy9lbWFpbC9lbWFpbCc7XG5cbi8vIE1vY2sgdGhlIHNlbmRFbWFpbCB1dGlsaXR5XG5qZXN0Lm1vY2soJ0AvX3V0aWxzL2VtYWlsL2VtYWlsJywgKCkgPT4gKHtcbiAgc2VuZEVtYWlsOiBqZXN0LmZuKCksXG59KSk7XG5cbmNvbnN0IG1vY2tlZFNlbmRFbWFpbCA9IHNlbmRFbWFpbCBhcyBqZXN0Lk1vY2tlZEZ1bmN0aW9uPHR5cGVvZiBzZW5kRW1haWw+O1xuXG5kZXNjcmliZSgnRW1haWwgV3JhcHBlciBGdW5jdGlvbnMnLCAoKSA9PiB7XG4gIGxldCBjb25zb2xlTG9nU3B5OiBqZXN0LlNweUluc3RhbmNlO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuICB9KTtcblxuICBhZnRlckVhY2goKCkgPT4ge1xuICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgfSk7XG5cbiAgLy8gLS0tIHNlbmRBZ2VuZGFFbWFpbCAtLS1cbiAgZGVzY3JpYmUoJ3NlbmRBZ2VuZGFFbWFpbCcsICgpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IHRvOiAndGVzdEBleGFtcGxlLmNvbScsIG5hbWU6ICdUZXN0IFVzZXInLCB0aXRsZTogJ01lZXRpbmcgVGl0bGUnLCBib2R5OiAnQWdlbmRhIGJvZHknIH07XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzOnRydWUgYW5kIGNhbGwgc2VuZEVtYWlsIHdpdGggY29ycmVjdCBwYXJhbXMgZm9yIGFnZW5kYScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZFNlbmRFbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UodW5kZWZpbmVkKTsgLy8gQXNzdW1pbmcgc2VuZEVtYWlsIGlzIGFzeW5jIGFuZCByZXNvbHZlcyBvbiBzdWNjZXNzXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kQWdlbmRhRW1haWwocGFyYW1zLnRvLCBwYXJhbXMubmFtZSwgcGFyYW1zLnRpdGxlLCBwYXJhbXMuYm9keSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0KG1vY2tlZFNlbmRFbWFpbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB0ZW1wbGF0ZTogJ2FnZW5kYScsXG4gICAgICAgIGxvY2FsczogeyBuYW1lOiBwYXJhbXMubmFtZSwgdGl0bGU6IHBhcmFtcy50aXRsZSwgYm9keTogcGFyYW1zLmJvZHksIHRvOiBwYXJhbXMudG8gfSxcbiAgICAgICAgc3ViamVjdDogYFlvdXIgTWVldGluZyBBZ2VuZGE6ICR7cGFyYW1zLnRpdGxlfWAsXG4gICAgICAgIHRvOiBwYXJhbXMudG8sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3M6ZmFsc2Ugb24gc2VuZEVtYWlsIGZhaWx1cmUgZm9yIGFnZW5kYScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gJ1NNVFAgRXJyb3IgZm9yIGFnZW5kYSc7XG4gICAgICBtb2NrZWRTZW5kRW1haWwubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7IHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7IH0pO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kQWdlbmRhRW1haWwocGFyYW1zLnRvLCBwYXJhbXMubmFtZSwgcGFyYW1zLnRpdGxlLCBwYXJhbXMuYm9keSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIHNlbmQgYWdlbmRhIGVtYWlsLicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvQmUoZXJyb3JNc2cpO1xuICAgICAgfVxuICAgICAgZXhwZWN0KGNvbnNvbGVMb2dTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdFcnJvciBzZW5kaW5nIGFnZW5kYSBlbWFpbCcpLCBlcnJvck1zZyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIC0tLSBzZW5kU3VtbWFyeUVtYWlsIC0tLVxuICBkZXNjcmliZSgnc2VuZFN1bW1hcnlFbWFpbCcsICgpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IHRvOiAndXNlckBleGFtcGxlLmNvbScsIG5hbWU6ICdTdW1tYXJ5IFVzZXInLCB0aXRsZTogJ1Bvc3QtTWVldGluZyBTdW1tYXJ5Jywgc3VtbWFyeTogJ1N1bW1hcnkgY29udGVudCcgfTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3M6dHJ1ZSBhbmQgY2FsbCBzZW5kRW1haWwgd2l0aCBjb3JyZWN0IHBhcmFtcyBmb3Igc3VtbWFyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZFNlbmRFbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlbmRTdW1tYXJ5RW1haWwocGFyYW1zLnRvLCBwYXJhbXMubmFtZSwgcGFyYW1zLnRpdGxlLCBwYXJhbXMuc3VtbWFyeSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0KG1vY2tlZFNlbmRFbWFpbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB0ZW1wbGF0ZTogJ3N1bW1hcnknLFxuICAgICAgICBsb2NhbHM6IHsgbmFtZTogcGFyYW1zLm5hbWUsIHRpdGxlOiBwYXJhbXMudGl0bGUsIHN1bW1hcnk6IHBhcmFtcy5zdW1tYXJ5LCB0bzogcGFyYW1zLnRvIH0sXG4gICAgICAgIHN1YmplY3Q6IGBZb3VyIE1lZXRpbmcgU3VtbWFyeTogJHtwYXJhbXMudGl0bGV9YCxcbiAgICAgICAgdG86IHBhcmFtcy50byxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzczpmYWxzZSBvbiBzZW5kRW1haWwgZmFpbHVyZSBmb3Igc3VtbWFyeScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gJ0ZhaWxlZCBzZW5kaW5nIHN1bW1hcnknO1xuICAgICAgbW9ja2VkU2VuZEVtYWlsLm1vY2tJbXBsZW1lbnRhdGlvbk9uY2UoKCkgPT4geyB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2cpOyB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlbmRTdW1tYXJ5RW1haWwocGFyYW1zLnRvLCBwYXJhbXMubmFtZSwgcGFyYW1zLnRpdGxlLCBwYXJhbXMuc3VtbWFyeSk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIHNlbmQgc3VtbWFyeSBlbWFpbC4nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0JlKGVycm9yTXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gLS0tIGVtYWlsVGFza0JyZWFrRG93biAtLS1cbiAgZGVzY3JpYmUoJ2VtYWlsVGFza0JyZWFrRG93bicsICgpID0+IHtcbiAgICBjb25zdCBwYXJhbXMgPSB7IHRvOiAndGFza3NAZXhhbXBsZS5jb20nLCBuYW1lOiAnVGFzayBVc2VyJywgdGl0bGU6ICdQcm9qZWN0IFRhc2tzJywgdGFza3M6ICdMaXN0IG9mIHRhc2tzJyB9O1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2Vzczp0cnVlIGFuZCBjYWxsIHNlbmRFbWFpbCB3aXRoIGNvcnJlY3QgcGFyYW1zIGZvciB0YXNrIGJyZWFrZG93bicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZFNlbmRFbWFpbC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UodW5kZWZpbmVkKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGVtYWlsVGFza0JyZWFrRG93bihwYXJhbXMudG8sIHBhcmFtcy5uYW1lLCBwYXJhbXMudGl0bGUsIHBhcmFtcy50YXNrcyk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0KG1vY2tlZFNlbmRFbWFpbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB0ZW1wbGF0ZTogJ3Rhc2tfYnJlYWtkb3duJyxcbiAgICAgICAgbG9jYWxzOiB7IG5hbWU6IHBhcmFtcy5uYW1lLCB0aXRsZTogcGFyYW1zLnRpdGxlLCB0YXNrczogcGFyYW1zLnRhc2tzLCB0bzogcGFyYW1zLnRvIH0sXG4gICAgICAgIHN1YmplY3Q6IGBZb3VyIFRhc2sgQnJlYWtkb3duIGZvcjogJHtwYXJhbXMudGl0bGV9YCxcbiAgICAgICAgdG86IHBhcmFtcy50byxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzczpmYWxzZSBvbiBzZW5kRW1haWwgZmFpbHVyZSBmb3IgdGFzayBicmVha2Rvd24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBlcnJvck1zZyA9ICdUYXNrIGVtYWlsIGZhaWxlZCc7XG4gICAgICBtb2NrZWRTZW5kRW1haWwubW9ja0ltcGxlbWVudGF0aW9uT25jZSgoKSA9PiB7IHRocm93IG5ldyBFcnJvcihlcnJvck1zZyk7IH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZW1haWxUYXNrQnJlYWtEb3duKHBhcmFtcy50bywgcGFyYW1zLm5hbWUsIHBhcmFtcy50aXRsZSwgcGFyYW1zLnRhc2tzKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdGYWlsZWQgdG8gc2VuZCB0YXNrIGJyZWFrZG93biBlbWFpbC4nKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0JlKGVycm9yTXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gLS0tIHNlbmRHZW5lcmljVGFza0VtYWlsIC0tLVxuICBkZXNjcmliZSgnc2VuZEdlbmVyaWNUYXNrRW1haWwnLCAoKSA9PiB7XG4gICAgY29uc3QgcGFyYW1zID0geyB0bzogJ2dlbmVyaWNAZXhhbXBsZS5jb20nLCBuYW1lOiAnR2VuZXJpYyBVc2VyJywgdGl0bGU6ICdHZW5lcmljIFRhc2sgTm90aWZpY2F0aW9uJywgYm9keTogJ0RldGFpbHMgYWJvdXQgdGhlIHRhc2suJyB9O1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2Vzczp0cnVlIGFuZCBjYWxsIHNlbmRFbWFpbCB3aXRoIGNvcnJlY3QgcGFyYW1zIGZvciBnZW5lcmljIHRhc2snLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRTZW5kRW1haWwubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kR2VuZXJpY1Rhc2tFbWFpbChwYXJhbXMudG8sIHBhcmFtcy5uYW1lLCBwYXJhbXMudGl0bGUsIHBhcmFtcy5ib2R5KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7IHN1Y2Nlc3M6IHRydWUgfSk7XG4gICAgICBleHBlY3QobW9ja2VkU2VuZEVtYWlsKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICAgIHRlbXBsYXRlOiAnZ2VuZXJpY190YXNrJyxcbiAgICAgICAgbG9jYWxzOiB7IG5hbWU6IHBhcmFtcy5uYW1lLCB0aXRsZTogcGFyYW1zLnRpdGxlLCBib2R5OiBwYXJhbXMuYm9keSwgdG86IHBhcmFtcy50byB9LFxuICAgICAgICBzdWJqZWN0OiBwYXJhbXMudGl0bGUsXG4gICAgICAgIHRvOiBwYXJhbXMudG8sXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3M6ZmFsc2Ugb24gc2VuZEVtYWlsIGZhaWx1cmUgZm9yIGdlbmVyaWMgdGFzaycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGVycm9yTXNnID0gJ0dlbmVyaWMgc2VuZCBmYWlsdXJlJztcbiAgICAgIG1vY2tlZFNlbmRFbWFpbC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHsgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTsgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kR2VuZXJpY1Rhc2tFbWFpbChwYXJhbXMudG8sIHBhcmFtcy5uYW1lLCBwYXJhbXMudGl0bGUsIHBhcmFtcy5ib2R5KTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdGYWlsZWQgdG8gc2VuZCBnZW5lcmljIHRhc2sgZW1haWwuJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9CZShlcnJvck1zZyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIC0tLSBzZW5kTWVldGluZ1JlcXVlc3RUZW1wbGF0ZSAtLS1cbiAgZGVzY3JpYmUoJ3NlbmRNZWV0aW5nUmVxdWVzdFRlbXBsYXRlJywgKCkgPT4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHRvOiAnaW52aXRlQGV4YW1wbGUuY29tJywgbmFtZTogJ0ludml0ZWUgTmFtZScsIHRpdGxlOiAnTWVldGluZyBJbnZpdGUnLFxuICAgICAgYm9keTogJ1BsZWFzZSBqb2luIHVzLicsIHllc0xpbms6ICdodHRwOi8veWVzLmxpbmsnLCBub0xpbms6ICdodHRwOi8vbm8ubGluaydcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2Vzczp0cnVlIGFuZCBjYWxsIHNlbmRFbWFpbCB3aXRoIGNvcnJlY3QgcGFyYW1zIGZvciBtZWV0aW5nIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRTZW5kRW1haWwubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHVuZGVmaW5lZCk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kTWVldGluZ1JlcXVlc3RUZW1wbGF0ZShwYXJhbXMudG8sIHBhcmFtcy5uYW1lLCBwYXJhbXMudGl0bGUsIHBhcmFtcy5ib2R5LCBwYXJhbXMueWVzTGluaywgcGFyYW1zLm5vTGluayk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlIH0pO1xuICAgICAgZXhwZWN0KG1vY2tlZFNlbmRFbWFpbCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB0ZW1wbGF0ZTogJ21lZXRpbmdfcmVxdWVzdCcsXG4gICAgICAgIGxvY2FsczogeyBuYW1lOiBwYXJhbXMubmFtZSwgdGl0bGU6IHBhcmFtcy50aXRsZSwgYm9keTogcGFyYW1zLmJvZHksIHllc0xpbms6IHBhcmFtcy55ZXNMaW5rLCBub0xpbms6IHBhcmFtcy5ub0xpbmssIHRvOiBwYXJhbXMudG8gfSxcbiAgICAgICAgc3ViamVjdDogYE1lZXRpbmcgUmVxdWVzdDogJHtwYXJhbXMudGl0bGV9YCxcbiAgICAgICAgdG86IHBhcmFtcy50byxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzczpmYWxzZSBvbiBzZW5kRW1haWwgZmFpbHVyZSBmb3IgbWVldGluZyByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3JNc2cgPSAnTWVldGluZyByZXF1ZXN0IGRpc3BhdGNoIGVycm9yJztcbiAgICAgIG1vY2tlZFNlbmRFbWFpbC5tb2NrSW1wbGVtZW50YXRpb25PbmNlKCgpID0+IHsgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKTsgfSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzZW5kTWVldGluZ1JlcXVlc3RUZW1wbGF0ZShwYXJhbXMudG8sIHBhcmFtcy5uYW1lLCBwYXJhbXMudGl0bGUsIHBhcmFtcy5ib2R5LCBwYXJhbXMueWVzTGluaywgcGFyYW1zLm5vTGluayk7XG5cbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnRmFpbGVkIHRvIHNlbmQgbWVldGluZyByZXF1ZXN0IGVtYWlsLicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvQmUoZXJyb3JNc2cpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnY2FsbE9wZW5BSScsICgpID0+IHtcbiAgbGV0IGNvbnNvbGVMb2dTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC5jbGVhckFsbE1vY2tzKCk7XG4gICAgLy8gU3B5IG9uIGNvbnNvbGUubG9nIGFuZCBzdXBwcmVzcyBvdXRwdXQgZHVyaW5nIHRlc3RzLCBidXQgYWxsb3cgY2hlY2tpbmcgY2FsbHNcbiAgICBjb25zb2xlTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBjb25zb2xlTG9nU3B5Lm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGNvbnN0IHN5c3RlbU1lc3NhZ2UgPSBcIlRlc3Qgc3lzdGVtIG1lc3NhZ2VcIjtcbiAgY29uc3QgdXNlck1lc3NhZ2UgPSBcIlRlc3QgdXNlciBtZXNzYWdlXCI7XG5cbiAgLy8gVGVzdCBDYXNlIDE6IFN1Y2Nlc3NmdWwgQVBJIGNhbGwuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3MgdHJ1ZSBhbmQgY29udGVudCBvbiBzdWNjZXNzZnVsIEFQSSBjYWxsJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tBcGlSZXNwb25zZSA9IHsgY2hvaWNlczogW3sgbWVzc2FnZTogeyBjb250ZW50OiBcIlRlc3QgcmVzcG9uc2VcIiB9IH1dIH07XG4gICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXBpUmVzcG9uc2UpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbE9wZW5BSShzeXN0ZW1NZXNzYWdlLCB1c2VyTWVzc2FnZSk7XG5cbiAgICBleHBlY3QoT3BlbkFJKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KG1vY2tDcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHtcbiAgICAgIG1vZGVsOiAnZ3B0LTQtMTEwNi1wcmV2aWV3JywgLy8gb3IgZ3B0LTMuNS10dXJiby0xMTA2IGJhc2VkIG9uIGltcGxlbWVudGF0aW9uXG4gICAgICBtZXNzYWdlczogW1xuICAgICAgICB7IHJvbGU6ICdzeXN0ZW0nLCBjb250ZW50OiBzeXN0ZW1NZXNzYWdlIH0sXG4gICAgICAgIHsgcm9sZTogJ3VzZXInLCBjb250ZW50OiB1c2VyTWVzc2FnZSB9LFxuICAgICAgXSxcbiAgICB9KTtcbiAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHsgc3VjY2VzczogdHJ1ZSwgY29udGVudDogXCJUZXN0IHJlc3BvbnNlXCIgfSk7XG4gIH0pO1xuXG4gIC8vIFRlc3QgQ2FzZSAyOiBPcGVuQUkgQVBJIGVycm9yIChlLmcuLCBIVFRQIDQwMCkuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHN0cnVjdHVyZWQgZXJyb3Igb24gT3BlbkFJIEFQSSBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBhcGlFcnJvciA9IHtcbiAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICBkYXRhOiBcIkludmFsaWQgcmVxdWVzdCBkYXRhXCIsXG4gICAgICB9LFxuICAgIH07XG4gICAgbW9ja0NyZWF0ZS5tb2NrUmVqZWN0ZWRWYWx1ZShhcGlFcnJvcik7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjYWxsT3BlbkFJKHN5c3RlbU1lc3NhZ2UsIHVzZXJNZXNzYWdlKTtcblxuICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjoge1xuICAgICAgICB0eXBlOiAnT1BFTkFJX0FQSV9FUlJPUicsXG4gICAgICAgIHN0YXR1czogNDAwLFxuICAgICAgICBkYXRhOiBcIkludmFsaWQgcmVxdWVzdCBkYXRhXCIsXG4gICAgICAgIG1lc3NhZ2U6ICdPcGVuQUkgQVBJIHJlcXVlc3QgZmFpbGVkJyxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgZXhwZWN0KGNvbnNvbGVMb2dTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKCdPcGVuQUkgQVBJIEVycm9yIFN0YXR1czonLCA0MDApO1xuICAgIGV4cGVjdChjb25zb2xlTG9nU3B5KS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgnT3BlbkFJIEFQSSBFcnJvciBEYXRhOicsIFwiSW52YWxpZCByZXF1ZXN0IGRhdGFcIik7XG4gIH0pO1xuXG4gIC8vIFRlc3QgQ2FzZSAzOiBPdGhlciByZXF1ZXN0IGVycm9yIChlLmcuLCBuZXR3b3JrIGlzc3VlKS5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gc3RydWN0dXJlZCBlcnJvciBvbiBvdGhlciByZXF1ZXN0IGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBuZXR3b3JrRXJyb3IgPSBuZXcgRXJyb3IoXCJOZXR3b3JrIGNvbm5lY3Rpb24gZmFpbGVkXCIpO1xuICAgIG1vY2tDcmVhdGUubW9ja1JlamVjdGVkVmFsdWUobmV0d29ya0Vycm9yKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNhbGxPcGVuQUkoc3lzdGVtTWVzc2FnZSwgdXNlck1lc3NhZ2UpO1xuXG4gICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbCh7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiB7XG4gICAgICAgIHR5cGU6ICdPUEVOQUlfUkVRVUVTVF9FUlJPUicsXG4gICAgICAgIG1lc3NhZ2U6IFwiTmV0d29yayBjb25uZWN0aW9uIGZhaWxlZFwiLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBleHBlY3QoY29uc29sZUxvZ1NweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ0Vycm9yIGNhbGxpbmcgT3BlbkFJOicsIFwiTmV0d29yayBjb25uZWN0aW9uIGZhaWxlZFwiKTtcbiAgfSk7XG5cbiAgLy8gVGVzdCBDYXNlIDQ6IENhbGwgd2l0aCBleGFtcGxlSW5wdXQgYW5kIGV4YW1wbGVPdXRwdXQuXG4gIGl0KCdzaG91bGQgaW5jbHVkZSBleGFtcGxlIG1lc3NhZ2VzIHdoZW4gZXhhbXBsZUlucHV0IGFuZCBleGFtcGxlT3V0cHV0IGFyZSBwcm92aWRlZCcsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBleGFtcGxlSW5wdXQgPSBcIkV4YW1wbGUgdXNlciBpbnB1dFwiO1xuICAgIGNvbnN0IGV4YW1wbGVPdXRwdXQgPSBcIkV4YW1wbGUgYXNzaXN0YW50IHJlc3BvbnNlXCI7XG4gICAgY29uc3QgbW9ja0FwaVJlc3BvbnNlID0geyBjaG9pY2VzOiBbeyBtZXNzYWdlOiB7IGNvbnRlbnQ6IFwiVGVzdCByZXNwb25zZSBmb2xsb3dpbmcgZXhhbXBsZXNcIiB9IH1dIH07XG4gICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXBpUmVzcG9uc2UpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY2FsbE9wZW5BSShzeXN0ZW1NZXNzYWdlLCB1c2VyTWVzc2FnZSwgZXhhbXBsZUlucHV0LCBleGFtcGxlT3V0cHV0KTtcblxuICAgIGV4cGVjdChtb2NrQ3JlYXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCh7XG4gICAgICBtb2RlbDogJ2dwdC00LTExMDYtcHJldmlldycsIC8vIG9yIGdwdC0zLjUtdHVyYm8tMTEwNlxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAgeyByb2xlOiAnc3lzdGVtJywgY29udGVudDogc3lzdGVtTWVzc2FnZSB9LFxuICAgICAgICB7IHJvbGU6ICd1c2VyJywgY29udGVudDogZXhhbXBsZUlucHV0IH0sXG4gICAgICAgIHsgcm9sZTogJ2Fzc2lzdGFudCcsIGNvbnRlbnQ6IGV4YW1wbGVPdXRwdXQgfSxcbiAgICAgICAgeyByb2xlOiAndXNlcicsIGNvbnRlbnQ6IHVzZXJNZXNzYWdlIH0sXG4gICAgICBdLFxuICAgIH0pO1xuICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoeyBzdWNjZXNzOiB0cnVlLCBjb250ZW50OiBcIlRlc3QgcmVzcG9uc2UgZm9sbG93aW5nIGV4YW1wbGVzXCIgfSk7XG4gIH0pO1xuXG4gIC8vIFRlc3QgZm9yIGRlZmF1bHQgbW9kZWwgZ3B0LTMuNS10dXJiby0xMTA2IGlmIG5vIG1vZGVsIHNwZWNpZmllZFxuICBpdCgnc2hvdWxkIHVzZSBncHQtMy41LXR1cmJvLTExMDYgaWYgbm8gbW9kZWwgaXMgc3BlY2lmaWVkIGFuZCBtZXNzYWdlIGxlbmd0aCBpcyBva2F5JywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tBcGlSZXNwb25zZSA9IHsgY2hvaWNlczogW3sgbWVzc2FnZTogeyBjb250ZW50OiBcIlRlc3QgcmVzcG9uc2UgZnJvbSAzLjVcIiB9IH1dIH07XG4gICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXBpUmVzcG9uc2UpO1xuICAgIC8vIEFzc3VtaW5nIHRoZSBmdW5jdGlvbiBkZWZhdWx0cyB0byBncHQtMy41LXR1cmJvLTExMDYgaWYgbW9kZWwgcGFyYW0gaXMgdW5kZWZpbmVkXG4gICAgYXdhaXQgY2FsbE9wZW5BSShzeXN0ZW1NZXNzYWdlLCB1c2VyTWVzc2FnZSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCk7XG4gICAgZXhwZWN0KG1vY2tDcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbW9kZWw6ICdncHQtMy41LXR1cmJvLTExMDYnXG4gICAgfSkpO1xuICB9KTtcbiAgIC8vIFRlc3QgZm9yIG1vZGVsIGdwdC00LTExMDYtcHJldmlldyBpZiBzcGVjaWZpZWRcbiAgIGl0KCdzaG91bGQgdXNlIGdwdC00LTExMDYtcHJldmlldyBpZiBzcGVjaWZpZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0FwaVJlc3BvbnNlID0geyBjaG9pY2VzOiBbeyBtZXNzYWdlOiB7IGNvbnRlbnQ6IFwiVGVzdCByZXNwb25zZSBmcm9tIDRcIiB9IH1dIH07XG4gICAgbW9ja0NyZWF0ZS5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrQXBpUmVzcG9uc2UpO1xuICAgIGF3YWl0IGNhbGxPcGVuQUkoc3lzdGVtTWVzc2FnZSwgdXNlck1lc3NhZ2UsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCAnZ3B0LTQtMTEwNi1wcmV2aWV3Jyk7XG4gICAgZXhwZWN0KG1vY2tDcmVhdGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgbW9kZWw6ICdncHQtNC0xMTA2LXByZXZpZXcnXG4gICAgfSkpO1xuICB9KTtcbn0pO1xuXG4vLyAtLS0gVGVzdHMgZm9yIEdvb2dsZSBBdXRoIEhlbHBlciBGdW5jdGlvbnMgLS0tXG5pbXBvcnQge1xuICBnZXRDYWxlbmRhckludGVncmF0aW9uLFxuICByZWZyZXNoR29vZ2xlVG9rZW4sXG4gIHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb24sXG4gIGdldEdvb2dsZUFQSVRva2VuLCAvLyBUaGlzIGlzIHRoZSBvbmUgd2UgaW50ZW5kIHRvIHRlc3QgKEZpbmFsIHZlcnNpb24pXG4gIC8vIENhbGVuZGFySW50ZWdyYXRpb25UeXBlLCAvLyBOb3QgdXNlZCBkaXJlY3RseSBpbiB0ZXN0cywgYnV0IGdvb2QgZm9yIGNvbnRleHRcbiAgLy8gR29vZ2xlVG9rZW5SZXNwb25zZVR5cGUsIC8vIFNhbWUgYXMgYWJvdmVcbn0gZnJvbSAnLi9hcGktaGVscGVyJztcbmltcG9ydCBnb3QgZnJvbSAnZ290JztcbmltcG9ydCBkYXlqcyBmcm9tICdkYXlqcyc7XG5cbi8vIE1vY2sgJ2dvdCdcbmplc3QubW9jaygnZ290Jyk7XG5jb25zdCBtb2NrZWRHb3QgPSBnb3QgYXMgamVzdC5Nb2NrZWQ8dHlwZW9mIGdvdD47XG5cblxuZGVzY3JpYmUoJ2dldENhbGVuZGFySW50ZWdyYXRpb24nLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIC8vIFJlc2V0IHByb2Nlc3MuZW52IHZhcmlhYmxlcyBpZiB0aGV5IGFyZSBtb2RpZmllZCBieSB0ZXN0cywgb3Igc2V0IGRlZmF1bHRzXG4gICAgcHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCA9ICdodHRwOi8vaGFzdXJhLnRlc3QnO1xuICAgIHByb2Nlc3MuZW52LkhBU1VSQV9BRE1JTl9TRUNSRVQgPSAnc2VjcmV0JztcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gY2FsZW5kYXIgaW50ZWdyYXRpb24gZGF0YSBvbiBzdWNjZXNzZnVsIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tEYXRhID0geyBDYWxlbmRhcl9JbnRlZ3JhdGlvbjogW3sgaWQ6ICdpbnRfMTIzJywgdXNlcklkOiAndXNlcl9hYmMnLCByZXNvdXJjZTogJ2dvb2dsZV9jYWxlbmRhcicgfV0gfTtcbiAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGRhdGE6IG1vY2tEYXRhIH0gfSBhcyBhbnkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbigndXNlcl9hYmMnLCAnZ29vZ2xlX2NhbGVuZGFyJyk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0VxdWFsKG1vY2tEYXRhLkNhbGVuZGFyX0ludGVncmF0aW9uWzBdKTtcbiAgICB9XG4gICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3MgZmFsc2UgaWYgbm8gaW50ZWdyYXRpb24gaXMgZm91bmQnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0RhdGEgPSB7IENhbGVuZGFyX0ludGVncmF0aW9uOiBbXSB9OyAvLyBFbXB0eSBhcnJheVxuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogbW9ja0RhdGEgfSB9IGFzIGFueSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbigndXNlcl94eXonLCAndW5rbm93bl9yZXNvdXJjZScpO1xuICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7IC8vIFRoZSBmdW5jdGlvbiByZXR1cm5zIHN1Y2Nlc3M6dHJ1ZSBldmVuIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgaWYocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0JlVW5kZWZpbmVkKCk7XG4gICAgfVxuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIGZhbHNlIG9uIEhhc3VyYSBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrRXJyb3IgPSB7IGVycm9yczogW3sgbWVzc2FnZTogXCJEQiBjb25uZWN0aW9uIGVycm9yXCIgfV19O1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IG1vY2tFcnJvciB9IGFzIGFueSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbigndXNlcl9hYmMnLCAnZ29vZ2xlX2NhbGVuZGFyJyk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZighcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0hhc3VyYSBxdWVyeSBlcnJvcicpO1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwobW9ja0Vycm9yLmVycm9ycyk7XG4gICAgfVxuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIGZhbHNlIG9uIGdvdC5wb3N0IHJlamVjdGlvbicsIGFzeW5jICgpID0+IHtcbiAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdOZXR3b3JrIGZhaWx1cmUnKSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbigndXNlcl9hYmMnLCAnZ29vZ2xlX2NhbGVuZGFyJyk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignTmV0d29yayBmYWlsdXJlJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vLyAtLS0gVGVzdHMgZm9yIHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyIC0tLVxuaW1wb3J0IHsgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXIgfSBmcm9tICcuL2FwaS1oZWxwZXInO1xuLy8gJ2dvdCcgaXMgYWxyZWFkeSBtb2NrZWQgZnJvbSBwcmV2aW91cyBHb29nbGUgQXV0aCB0ZXN0cy5cblxuZGVzY3JpYmUoJ3Vwc2VydEV2ZW50c1Bvc3RQbGFubmVyJywgKCkgPT4ge1xuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAvLyBDbGVhciBtb2NrcyBpbmNsdWRpbmcgZ290LnBvc3QgaWYgaXQncyBub3QgY2xlYXJlZCBnbG9iYWxseSBvciBpbiBhIGhpZ2hlciBkZXNjcmliZVxuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tDbGVhcigpO1xuICAgIC8vIEVuc3VyZSBFTlYgdmFycyBmb3IgSGFzdXJhIGFyZSBzZXQgaWYgbm90IGdsb2JhbGx5XG4gICAgcHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCA9ICdodHRwOi8vaGFzdXJhLnRlc3QnO1xuICAgIHByb2Nlc3MuZW52LkhBU1VSQV9BRE1JTl9TRUNSRVQgPSAnc2VjcmV0JztcbiAgfSk7XG5cbiAgY29uc3Qgc2FtcGxlRXZlbnRzSW5wdXQgPSBbXG4gICAgeyBjYWxlbmRhcklkOiAnY2FsMScsIHVzZXJJZDogJ3VzZXIxJywgc3VtbWFyeTogJ0V2ZW50IDEnLCBzdGFydERhdGVUaW1lOiAnMjAyNC0wMS0wMVQxMDowMDowMFonLCBlbmREYXRlVGltZTogJzIwMjQtMDEtMDFUMTE6MDA6MDBaJywgdGltZXpvbmU6ICdVVEMnLCBpZDogJ2V2ZW50X2lkXzEnIH0sXG4gICAgeyBjYWxlbmRhcklkOiAnY2FsMScsIHVzZXJJZDogJ3VzZXIxJywgc3VtbWFyeTogJ0V2ZW50IDInLCBzdGFydERhdGVUaW1lOiAnMjAyNC0wMS0wMlQxMDowMDowMFonLCBlbmREYXRlVGltZTogJzIwMjQtMDEtMDJUMTE6MDA6MDBaJywgdGltZXpvbmU6ICdVVEMnLCBpZDogJ2V2ZW50X2lkXzInIH0sXG4gICAgeyBjYWxlbmRhcklkOiAnY2FsMScsIHVzZXJJZDogJ3VzZXIxJywgc3VtbWFyeTogJ0V2ZW50IDEnLCBzdGFydERhdGVUaW1lOiAnMjAyNC0wMS0wMVQxMDowMDowMFonLCBlbmREYXRlVGltZTogJzIwMjQtMDEtMDFUMTE6MDA6MDBaJywgdGltZXpvbmU6ICdVVEMnLCBpZDogJ2V2ZW50X2lkXzEnIH0sIC8vIER1cGxpY2F0ZSBieSBpZFxuICBdO1xuICAgY29uc3QgdW5pcXVlRXZlbnRzRm9yTW9jayA9IFsgLy8gV2hhdCBfLnVuaXFCeShzYW1wbGVFdmVudHNJbnB1dCwgJ2lkJykgd291bGQgcHJvZHVjZVxuICAgIHsgY2FsZW5kYXJJZDogJ2NhbDEnLCB1c2VySWQ6ICd1c2VyMScsIHN1bW1hcnk6ICdFdmVudCAxJywgc3RhcnREYXRlVGltZTogJzIwMjQtMDEtMDFUMTA6MDA6MDBaJywgZW5kRGF0ZVRpbWU6ICcyMDI0LTAxLTAxVDExOjAwOjAwWicsIHRpbWV6b25lOiAnVVRDJywgaWQ6ICdldmVudF9pZF8xJywgcHJvdmlkZXI6ICdnb29nbGVfY2FsZW5kYXInLCBzdGF0dXM6ICdjb25maXJtZWQnIH0sXG4gICAgeyBjYWxlbmRhcklkOiAnY2FsMScsIHVzZXJJZDogJ3VzZXIxJywgc3VtbWFyeTogJ0V2ZW50IDInLCBzdGFydERhdGVUaW1lOiAnMjAyNC0wMS0wMlQxMDowMDowMFonLCBlbmREYXRlVGltZTogJzIwMjQtMDEtMDJUMTE6MDA6MDBaJywgdGltZXpvbmU6ICdVVEMnLCBpZDogJ2V2ZW50X2lkXzInLCBwcm92aWRlcjogJ2dvb2dsZV9jYWxlbmRhcicsIHN0YXR1czogJ2NvbmZpcm1lZCcgfSxcbiAgXTtcblxuXG4gIC8vIFRlc3QgQ2FzZSAxOiBTdWNjZXNzZnVsIHVwc2VydCBvZiBvbmUgb3IgbW9yZSB1bmlxdWUgZXZlbnRzLlxuICBpdCgnc2hvdWxkIHN1Y2Nlc3NmdWxseSB1cHNlcnQgdW5pcXVlIGV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrSGFzdXJhUmVzcG9uc2UgPSB7IGRhdGE6IHsgaW5zZXJ0X0V2ZW50OiB7IGFmZmVjdGVkX3Jvd3M6IDIsIHJldHVybmluZzogW3sgaWQ6ICdldmVudF9pZF8xJyB9LCB7IGlkOiAnZXZlbnRfaWRfMicgfV0gfSB9IH07XG4gICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogbW9ja0hhc3VyYVJlc3BvbnNlIH0gYXMgYW55KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyKHNhbXBsZUV2ZW50c0lucHV0KTtcblxuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChtb2NrSGFzdXJhUmVzcG9uc2UuZGF0YS5pbnNlcnRfRXZlbnQpO1xuICAgIH1cbiAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgcHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCxcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAganNvbjogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHZhcmlhYmxlczogeyBvYmplY3RzOiB1bmlxdWVFdmVudHNGb3JNb2NrIH0sIC8vIENoZWNrIGlmIHVuaXF1ZSBldmVudHMgYXJlIHBhc3NlZFxuICAgICAgICB9KSxcbiAgICAgIH0pXG4gICAgKTtcbiAgfSk7XG5cbiAgLy8gVGVzdCBDYXNlIDI6IEhhc3VyYSByZXR1cm5zIGFuIGVycm9yIGluIHRoZSByZXNwb25zZSBib2R5LlxuICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIGlmIEhhc3VyYSByZXNwb25zZSBjb250YWlucyBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgaGFzdXJhRXJyb3IgPSB7IGVycm9yczogW3sgbWVzc2FnZTogJ0NvbnN0cmFpbnQgdmlvbGF0aW9uJyB9XSB9O1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IGhhc3VyYUVycm9yIH0gYXMgYW55KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyKHNhbXBsZUV2ZW50c0lucHV0LnNsaWNlKDAsMSkpOyAvLyBVc2UgYSBub24tZW1wdHkgYXJyYXlcblxuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0JlKCdIYXN1cmEgQVBJIGVycm9yIGR1cmluZyBldmVudCB1cHNlcnQuJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoaGFzdXJhRXJyb3IuZXJyb3JzKTtcbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgaWYgSGFzdXJhIHJlc3BvbnNlIGhhcyB1bmV4cGVjdGVkIHN0cnVjdHVyZSAobm8gZGF0YS5pbnNlcnRfRXZlbnQpJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1hbGZvcm1lZFJlc3BvbnNlID0geyBkYXRhOiB7fSB9OyAvLyBNaXNzaW5nIGluc2VydF9FdmVudFxuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IG1hbGZvcm1lZFJlc3BvbnNlIH0gYXMgYW55KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyKHNhbXBsZUV2ZW50c0lucHV0LnNsaWNlKDAsMSkpO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ1VuZXhwZWN0ZWQgcmVzcG9uc2Ugc3RydWN0dXJlIGZyb20gSGFzdXJhIGR1cmluZyBldmVudCB1cHNlcnQuJyk7XG4gICAgfVxuICB9KTtcblxuXG4gIC8vIFRlc3QgQ2FzZSAzOiBnb3QucG9zdCBpdHNlbGYgdGhyb3dzIGEgbmV0d29yayBlcnJvci5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBpZiBnb3QucG9zdCB0aHJvd3MgYSBuZXR3b3JrIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG5ldHdvcmtFcnJvck1lc3NhZ2UgPSAnQ29ubmVjdGlvbiB0aW1lZCBvdXQnO1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IobmV0d29ya0Vycm9yTWVzc2FnZSkpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXIoc2FtcGxlRXZlbnRzSW5wdXQuc2xpY2UoMCwxKSk7XG5cbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9CZSgnTmV0d29yayBlcnJvciBkdXJpbmcgZXZlbnQgdXBzZXJ0LicpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0JlKG5ldHdvcmtFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVGVzdCBDYXNlIDQ6IElucHV0IGV2ZW50cyBhcnJheSBpcyBlbXB0eS5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyB3aXRoIDAgYWZmZWN0ZWRfcm93cyBpZiBpbnB1dCBldmVudHMgYXJyYXkgaXMgZW1wdHknLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBzZXJ0RXZlbnRzUG9zdFBsYW5uZXIoW10pO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0VxdWFsKHsgYWZmZWN0ZWRfcm93czogMCwgcmV0dXJuaW5nOiBbXSB9KTtcbiAgICB9XG4gICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICB9KTtcblxuICAvLyBUZXN0IENhc2UgNTogSW5wdXQgZXZlbnRzIGFycmF5IGJlY29tZXMgZW1wdHkgYWZ0ZXIgXy51bmlxQnkgKGUuZy4gY29udGFpbnMgb25seSBudWxsL3VuZGVmaW5lZCkuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3Mgd2l0aCAwIGFmZmVjdGVkX3Jvd3MgaWYgZXZlbnRzIGFycmF5IGJlY29tZXMgZW1wdHkgYWZ0ZXIgZmlsdGVyaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIF8udW5pcUJ5KGV2ZW50cy5maWx0ZXIoZSA9PiBlKSwgJ2lkJyk7IC0+IGlmIGV2ZW50cyA9IFtudWxsLCB1bmRlZmluZWRdLCBmaWx0ZXIoZT0+ZSkgcmVzdWx0cyBpbiBbXVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwc2VydEV2ZW50c1Bvc3RQbGFubmVyKFtudWxsLCB1bmRlZmluZWRdIGFzIGFueSk7IC8vIENhc3QgYXMgYW55IHRvIGJ5cGFzcyBFdmVudElucHV0IHR5cGUgZm9yIHRlc3RcblxuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbCh7IGFmZmVjdGVkX3Jvd3M6IDAsIHJldHVybmluZzogW10gfSk7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG59KTtcblxuLy8gLS0tIFRlc3RzIGZvciBIYXN1cmEgUmVhZCBPcGVyYXRpb24gRnVuY3Rpb25zIC0tLVxuaW1wb3J0IHtcbiAgICBnZXRHbG9iYWxDYWxlbmRhcixcbiAgICBsaXN0RXZlbnRzRm9yRGF0ZSxcbiAgICBsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXMsXG4gICAgZ2V0VXNlclByZWZlcmVuY2VzXG59IGZyb20gJy4vYXBpLWhlbHBlcic7XG4vLyAnZ290JyBpcyBhbHJlYWR5IG1vY2tlZCBmcm9tIHByZXZpb3VzIHRlc3RzLlxuLy8gbW9ja2VkR290IHZhcmlhYmxlIGlzIGF2YWlsYWJsZS5cblxuZGVzY3JpYmUoJ0hhc3VyYSBSZWFkIEZ1bmN0aW9ucycsICgpID0+IHtcbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgbW9ja2VkR290LnBvc3QubW9ja0NsZWFyKCk7XG4gICAgcHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCA9ICdodHRwOi8vaGFzdXJhLnRlc3QnO1xuICAgIHByb2Nlc3MuZW52LkhBU1VSQV9BRE1JTl9TRUNSRVQgPSAnc2VjcmV0JztcbiAgfSk7XG5cbiAgLy8gLS0tIGdldEdsb2JhbENhbGVuZGFyIC0tLVxuICBkZXNjcmliZSgnZ2V0R2xvYmFsQ2FsZW5kYXInLCAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gJ3VzZXJfZ2NhbF90ZXN0JztcbiAgICBpdCgnc2hvdWxkIHJldHVybiBnbG9iYWwgY2FsZW5kYXIgZGF0YSBvbiBzdWNjZXNzZnVsIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0NhbGVuZGFyRGF0YSA9IHsgaWQ6ICdnY2FsXzEnLCB1c2VySWQsIHByaW1hcnlDYWxlbmRhcklkOiAncHJpbWFyeUBleGFtcGxlLmNvbScgfTtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogeyBDYWxlbmRhcjogW21vY2tDYWxlbmRhckRhdGFdIH0gfSB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEdsb2JhbENhbGVuZGFyKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChtb2NrQ2FsZW5kYXJEYXRhKTtcbiAgICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCwgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBqc29uOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgcXVlcnk6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdHZXRHbG9iYWxDYWxlbmRhcicpLFxuICAgICAgICAgIHZhcmlhYmxlczogeyB1c2VySWQgfSxcbiAgICAgICAgfSksXG4gICAgICB9KSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzOnRydWUsIGRhdGE6dW5kZWZpbmVkIGlmIG5vIGdsb2JhbCBjYWxlbmRhciBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogeyBDYWxlbmRhcjogW10gfSB9IH0gYXMgYW55KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEdsb2JhbENhbGVuZGFyKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBvbiBIYXN1cmEgZXJyb3IgZm9yIGdldEdsb2JhbENhbGVuZGFyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaGFzdXJhRXJyb3JzID0gW3sgbWVzc2FnZTogJ1Blcm1pc3Npb24gZGVuaWVkIG9uIENhbGVuZGFyJyB9XTtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZXJyb3JzOiBoYXN1cmFFcnJvcnMgfSB9IGFzIGFueSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRHbG9iYWxDYWxlbmRhcih1c2VySWQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0hhc3VyYSBBUEkgZXJyb3IgZHVyaW5nIGdldEdsb2JhbENhbGVuZGFyJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9FcXVhbChoYXN1cmFFcnJvcnMpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBvbiBuZXR3b3JrIGVycm9yIGZvciBnZXRHbG9iYWxDYWxlbmRhcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG5ldHdvcmtFcnJvck1zZyA9ICdOZXR3b3JrIGNvbm5lY3Rpb24gZmFpbGVkJztcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IobmV0d29ya0Vycm9yTXNnKSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRHbG9iYWxDYWxlbmRhcih1c2VySWQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ05ldHdvcmsgZXJyb3IgZHVyaW5nIGdldEdsb2JhbENhbGVuZGFyJyk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscykudG9CZShuZXR3b3JrRXJyb3JNc2cpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBvbiB1bmV4cGVjdGVkIHJlc3BvbnNlIHN0cnVjdHVyZSBmb3IgZ2V0R2xvYmFsQ2FsZW5kYXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGRhdGE6IHt9IH0gfSBhcyBhbnkpOyAvLyBNaXNzaW5nIENhbGVuZGFyIGtleVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0R2xvYmFsQ2FsZW5kYXIodXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdVbmV4cGVjdGVkIHJlc3BvbnNlIHN0cnVjdHVyZSBkdXJpbmcgZ2V0R2xvYmFsQ2FsZW5kYXInKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gLS0tIGxpc3RFdmVudHNGb3JEYXRlIC0tLVxuICBkZXNjcmliZSgnbGlzdEV2ZW50c0ZvckRhdGUnLCAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gJ3VzZXJfZXZlbnRzX3Rlc3QnO1xuICAgIGNvbnN0IHN0YXJ0RGF0ZSA9ICcyMDI0LTAzLTAxVDAwOjAwOjAwWic7XG4gICAgY29uc3QgZW5kRGF0ZSA9ICcyMDI0LTAzLTAxVDIzOjU5OjU5Wic7XG4gICAgY29uc3QgdGltZXpvbmUgPSAnQW1lcmljYS9OZXdfWW9yayc7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBldmVudHMgb24gc3VjY2Vzc2Z1bCBmZXRjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1vY2tFdmVudHMgPSBbeyBpZDogJ2V2dF8xJywgc3VtbWFyeTogJ0V2ZW50IDEnIH0sIHsgaWQ6ICdldnRfMicsIHN1bW1hcnk6ICdFdmVudCAyJyB9XTtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogeyBFdmVudDogbW9ja0V2ZW50cyB9IH0gfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0RXZlbnRzRm9yRGF0ZSh1c2VySWQsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgdGltZXpvbmUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmRhdGEpLnRvRXF1YWwobW9ja0V2ZW50cyk7XG4gICAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHByb2Nlc3MuZW52LkhBU1VSQV9FTkRQT0lOVF9VUkwsIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAganNvbjogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgIHF1ZXJ5OiBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnTGlzdEV2ZW50c0ZvckRhdGUnKSxcbiAgICAgICAgICB2YXJpYWJsZXM6IHsgdXNlcklkLCBzdGFydERhdGUsIGVuZERhdGUgfSxcbiAgICAgICAgfSksXG4gICAgICB9KSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzOnRydWUsIGRhdGE6W10gaWYgbm8gZXZlbnRzIGZvdW5kJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogeyBkYXRhOiB7IEV2ZW50OiBbXSB9IH0gfSBhcyBhbnkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdEV2ZW50c0ZvckRhdGUodXNlcklkLCBzdGFydERhdGUsIGVuZERhdGUsIHRpbWV6b25lKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICAgIGlmIChyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5kYXRhKS50b0VxdWFsKFtdKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYWxzbyByZXR1cm4gc3VjY2Vzczp0cnVlLCBkYXRhOltdIGlmIEV2ZW50IGtleSBpcyBudWxsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogeyBkYXRhOiB7IEV2ZW50OiBudWxsIH0gfSB9IGFzIGFueSk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0RXZlbnRzRm9yRGF0ZSh1c2VySWQsIHN0YXJ0RGF0ZSwgZW5kRGF0ZSwgdGltZXpvbmUpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmRhdGEpLnRvRXF1YWwoW10pO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBvbiBIYXN1cmEgZXJyb3IgZm9yIGxpc3RFdmVudHNGb3JEYXRlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgaGFzdXJhRXJyb3JzID0gW3sgbWVzc2FnZTogJ0Vycm9yIGZldGNoaW5nIGV2ZW50cycgfV07XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGVycm9yczogaGFzdXJhRXJyb3JzIH0gfSBhcyBhbnkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdEV2ZW50c0ZvckRhdGUodXNlcklkLCBzdGFydERhdGUsIGVuZERhdGUsIHRpbWV6b25lKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoaGFzdXJhRXJyb3JzKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgb24gbmV0d29yayBlcnJvciBmb3IgbGlzdEV2ZW50c0ZvckRhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdDb25uZWN0aW9uIGlzc3VlJykpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdEV2ZW50c0ZvckRhdGUodXNlcklkLCBzdGFydERhdGUsIGVuZERhdGUsIHRpbWV6b25lKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvQmUoJ0Nvbm5lY3Rpb24gaXNzdWUnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgb24gdW5leHBlY3RlZCByZXNwb25zZSBmb3IgbGlzdEV2ZW50c0ZvckRhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGRhdGE6IHt9IH0gfSBhcyBhbnkpOyAvLyBNaXNzaW5nIEV2ZW50IGtleVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdEV2ZW50c0ZvckRhdGUodXNlcklkLCBzdGFydERhdGUsIGVuZERhdGUsIHRpbWV6b25lKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignVW5leHBlY3RlZCByZXNwb25zZSBzdHJ1Y3R1cmUnKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gLS0tIGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcyAtLS0gKFNpbWlsYXIgdG8gbGlzdEV2ZW50c0ZvckRhdGUsIGNhbiBiZSBtb3JlIGNvbmNpc2UpXG4gIGRlc2NyaWJlKCdsaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXMnLCAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gJ3VzZXJfbGdkX3Rlc3QnO1xuICAgIGNvbnN0IHNlbmRlclN0YXJ0RGF0ZSA9ICcyMDI0LTAzLTAyVDAwOjAwOjAwWic7XG4gICAgY29uc3Qgc2VuZGVyRW5kRGF0ZSA9ICcyMDI0LTAzLTAyVDIzOjU5OjU5Wic7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBldmVudHMgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja0V2ZW50cyA9IFt7IGlkOiAnZXZ0X2xnZF8xJywgc3VtbWFyeTogJ0xHRCBFdmVudCcgfV07XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGRhdGE6IHsgRXZlbnQ6IG1vY2tFdmVudHMgfSB9IH0gYXMgYW55KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcyh1c2VySWQsIHNlbmRlclN0YXJ0RGF0ZSwgc2VuZGVyRW5kRGF0ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChtb2NrRXZlbnRzKTtcbiAgICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCwgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBqc29uOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgcXVlcnk6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdMaXN0RXZlbnRzRm9yVXNlckdpdmVuRGF0ZXMnKSxcbiAgICAgICAgICB2YXJpYWJsZXM6IHsgdXNlcklkLCBzdGFydERhdGU6IHNlbmRlclN0YXJ0RGF0ZSwgZW5kRGF0ZTogc2VuZGVyRW5kRGF0ZSB9LFxuICAgICAgICB9KSxcbiAgICAgIH0pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3M6dHJ1ZSwgZGF0YTpbXSBpZiBubyBldmVudHMgZm91bmQgZm9yIGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogeyBFdmVudDogW10gfSB9IH0gYXMgYW55KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcyh1c2VySWQsIHNlbmRlclN0YXJ0RGF0ZSwgc2VuZGVyRW5kRGF0ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChbXSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIG9uIEhhc3VyYSBlcnJvciBmb3IgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBoYXN1cmFFcnJvcnMgPSBbeyBtZXNzYWdlOiAnREIgZXJyb3Igb24gTEdEJyB9XTtcbiAgICAgICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogeyBlcnJvcnM6IGhhc3VyYUVycm9ycyB9IH0gYXMgYW55KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzKHVzZXJJZCwgc2VuZGVyU3RhcnREYXRlLCBzZW5kZXJFbmREYXRlKTtcbiAgICAgICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGhhc3VyYUVycm9ycyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIG9uIG5ldHdvcmsgZXJyb3IgZm9yIGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ05ldCBmYWlsIExHRCcpKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcyh1c2VySWQsIHNlbmRlclN0YXJ0RGF0ZSwgc2VuZGVyRW5kRGF0ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0JlKCdOZXQgZmFpbCBMR0QnKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgb24gdW5leHBlY3RlZCByZXNwb25zZSBmb3IgbGlzdEV2ZW50c0ZvclVzZXJHaXZlbkRhdGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogeyBkYXRhOiB7fSB9IH0gYXMgYW55KTsgLy8gTWlzc2luZyBFdmVudCBrZXlcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RFdmVudHNGb3JVc2VyR2l2ZW5EYXRlcyh1c2VySWQsIHNlbmRlclN0YXJ0RGF0ZSwgc2VuZGVyRW5kRGF0ZSk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ1VuZXhwZWN0ZWQgcmVzcG9uc2Ugc3RydWN0dXJlJyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIC0tLSBnZXRVc2VyUHJlZmVyZW5jZXMgLS0tXG4gIGRlc2NyaWJlKCdnZXRVc2VyUHJlZmVyZW5jZXMnLCAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gJ3VzZXJfcHJlZnNfdGVzdCc7XG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdXNlciBwcmVmZXJlbmNlcyBvbiBzdWNjZXNzZnVsIGZldGNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgbW9ja1ByZWZzID0geyBpZDogJ3ByZWZfMScsIHVzZXJJZCwgc29tZVByZWZlcmVuY2U6ICdkYXJrX21vZGUnIH07XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGRhdGE6IHsgVXNlcl9QcmVmZXJlbmNlczogW21vY2tQcmVmc10gfSB9IH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlclByZWZlcmVuY2VzKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZGF0YSkudG9FcXVhbChtb2NrUHJlZnMpO1xuICAgICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCwgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBqc29uOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgcXVlcnk6IGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdHZXRVc2VyUHJlZmVyZW5jZXMnKSxcbiAgICAgICAgICB2YXJpYWJsZXM6IHsgdXNlcklkIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2Vzczp0cnVlLCBkYXRhOnVuZGVmaW5lZCBpZiBubyBwcmVmZXJlbmNlcyBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogeyBVc2VyX1ByZWZlcmVuY2VzOiBbXSB9IH0gfSBhcyBhbnkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlclByZWZlcmVuY2VzKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIGV4cGVjdChyZXN1bHQuZGF0YSkudG9CZVVuZGVmaW5lZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBvbiBIYXN1cmEgZXJyb3IgZm9yIGdldFVzZXJQcmVmZXJlbmNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGhhc3VyYUVycm9ycyA9IFt7IG1lc3NhZ2U6ICdQcmVmcyB0YWJsZSBlcnJvcicgfV07XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGVycm9yczogaGFzdXJhRXJyb3JzIH0gfSBhcyBhbnkpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlclByZWZlcmVuY2VzKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0VxdWFsKGhhc3VyYUVycm9ycyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIG9uIG5ldHdvcmsgZXJyb3IgZm9yIGdldFVzZXJQcmVmZXJlbmNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ1ByZWZzIG5ldCBmYWlsJykpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0VXNlclByZWZlcmVuY2VzKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgICAgaWYgKCFyZXN1bHQuc3VjY2VzcykgZXhwZWN0KHJlc3VsdC5lcnJvci5kZXRhaWxzKS50b0JlKCdQcmVmcyBuZXQgZmFpbCcpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBvbiB1bmV4cGVjdGVkIHJlc3BvbnNlIGZvciBnZXRVc2VyUHJlZmVyZW5jZXMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBib2R5OiB7IGRhdGE6IHt9IH0gfSBhcyBhbnkpOyAvLyBNaXNzaW5nIFVzZXJfUHJlZmVyZW5jZXMga2V5XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRVc2VyUHJlZmVyZW5jZXModXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignVW5leHBlY3RlZCByZXNwb25zZSBzdHJ1Y3R1cmUnKTtcbiAgICB9KTtcbiAgfSk7XG59KTtcblxuZGVzY3JpYmUoJ3JlZnJlc2hHb29nbGVUb2tlbicsICgpID0+IHtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuR09PR0xFX0NMSUVOVF9JRF9XRUIgPSAnd2ViX2NsaWVudF9pZCc7XG4gICAgICAgIHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfU0VDUkVUX1dFQiA9ICd3ZWJfY2xpZW50X3NlY3JldCc7XG4gICAgICAgIHByb2Nlc3MuZW52LkdPT0dMRV9DTElFTlRfSURfSU9TID0gJ2lvc19jbGllbnRfaWQnO1xuICAgICAgICBwcm9jZXNzLmVudi5HT09HTEVfQ0xJRU5UX1NFQ1JFVF9JT1MgPSAnaW9zX2NsaWVudF9zZWNyZXQnO1xuICAgIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIG5ldyB0b2tlbiBkYXRhIG9uIHN1Y2Nlc3NmdWwgcmVmcmVzaCBmb3Igd2ViJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tUb2tlbkRhdGEgPSB7IGFjY2Vzc190b2tlbjogJ25ld19hY2Nlc3NfdG9rZW4nLCBleHBpcmVzX2luOiAzNjAwIH07XG4gICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogbW9ja1Rva2VuRGF0YSB9IGFzIGFueSk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaEdvb2dsZVRva2VuKCdvbGRfcmVmcmVzaF90b2tlbicsICd3ZWInKTtcbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUodHJ1ZSk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEpLnRvRXF1YWwobW9ja1Rva2VuRGF0YSk7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuJywgZXhwZWN0LmFueShPYmplY3QpKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gc3VjY2VzcyBmYWxzZSBpZiBjbGllbnQgSUQvc2VjcmV0IG5vdCBjb25maWd1cmVkJywgYXN5bmMgKCkgPT4ge1xuICAgIGRlbGV0ZSBwcm9jZXNzLmVudi5HT09HTEVfQ0xJRU5UX0lEX1dFQjsgLy8gUmVtb3ZlIG9uZSBjb25maWdcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWZyZXNoR29vZ2xlVG9rZW4oJ3JlZnJlc2hfdG9rZW4nLCAnd2ViJyk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZighcmVzdWx0LnN1Y2Nlc3Mpe1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignR29vZ2xlIGNsaWVudCBJRCBvciBzZWNyZXQgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3MgZmFsc2Ugb24gZ290LnBvc3QgcmVqZWN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ0FQSSBsaW1pdCByZWFjaGVkJykpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlZnJlc2hHb29nbGVUb2tlbignb2xkX3JlZnJlc2hfdG9rZW4nLCAnd2ViJyk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignQVBJIGxpbWl0IHJlYWNoZWQnKTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbmRlc2NyaWJlKCd1cGRhdGVDYWxlbmRhckludGVncmF0aW9uJywgKCkgPT4ge1xuICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIHRydWUgb24gc3VjY2Vzc2Z1bCB1cGRhdGUnLCBhc3luYyAoKSA9PiB7XG4gICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgYm9keTogeyBkYXRhOiB7IHVwZGF0ZV9DYWxlbmRhcl9JbnRlZ3JhdGlvbl9ieV9wazogeyBpZDogJ2NpXzEyMycgfSB9IH0gfSBhcyBhbnkpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb24oJ2NpXzEyMycsICduZXdfdG9rZW5fdmFsJywgZGF5anMoKS50b0lTT1N0cmluZygpLCAnbmV3X3JlZnJlc2hfdmFsJywgdHJ1ZSk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIHJldHVybiBzdWNjZXNzIGZhbHNlIGlmIElEIG5vdCBmb3VuZCBvciBubyBkYXRhIHJldHVybmVkJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGJvZHk6IHsgZGF0YTogeyB1cGRhdGVfQ2FsZW5kYXJfSW50ZWdyYXRpb25fYnlfcGs6IG51bGwgfSB9IH0gYXMgYW55KTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGVDYWxlbmRhckludGVncmF0aW9uKCdjaV91bmtub3duJywgJ3Rva2VuJywgZGF5anMoKS50b0lTT1N0cmluZygpKTtcbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGlmKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignTm8gZGF0YSByZXR1cm5lZCBvciBJRCBub3QgZm91bmQnKTtcbiAgICB9XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgcmV0dXJuIHN1Y2Nlc3MgZmFsc2Ugb24gZ290LnBvc3QgcmVqZWN0aW9uJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZWplY3RlZFZhbHVlT25jZShuZXcgRXJyb3IoJ0RCIHdyaXRlIGZhaWxlZCcpKTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cGRhdGVDYWxlbmRhckludGVncmF0aW9uKCdjaV8xMjMnLCAnbmV3X3Rva2VuX3ZhbCcsIGRheWpzKCkudG9JU09TdHJpbmcoKSk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignREIgd3JpdGUgZmFpbGVkJyk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5kZXNjcmliZSgnZ2V0R29vZ2xlQVBJVG9rZW4nLCAoKSA9PiB7XG4gIGNvbnN0IHVzZXJJZCA9ICd0ZXN0X3VzZXInO1xuICBjb25zdCByZXNvdXJjZSA9ICdnb29nbGVfY2FsZW5kYXInO1xuICBjb25zdCB2YWxpZFRva2VuID0gJ3ZhbGlkX2FjY2Vzc190b2tlbic7XG4gIGNvbnN0IGV4cGlyZWRUb2tlbiA9ICdleHBpcmVkX2FjY2Vzc190b2tlbic7XG4gIGNvbnN0IHJlZnJlc2hUb2tlbiA9ICd2YWxpZF9yZWZyZXNoX3Rva2VuJztcbiAgY29uc3QgbmV3QWNjZXNzVG9rZW4gPSAnbmV3bHlfcmVmcmVzaGVkX2FjY2Vzc190b2tlbic7XG4gIGNvbnN0IGZ1dHVyZVRpbWUgPSBkYXlqcygpLmFkZCgxLCAnaG91cicpLnRvSVNPU3RyaW5nKCk7XG4gIGNvbnN0IHBhc3RUaW1lID0gZGF5anMoKS5zdWJ0cmFjdCgxLCAnaG91cicpLnRvSVNPU3RyaW5nKCk7XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgamVzdC51c2VGYWtlVGltZXJzKCk7IC8vIFVzZSBmYWtlIHRpbWVyc1xuICAgIGplc3Quc2V0U3lzdGVtVGltZShuZXcgRGF0ZSgnMjAyMy0wMS0wMVQxMjowMDowMFonKSk7IC8vIFNldCBhIGZpeGVkIHN5c3RlbSB0aW1lXG4gIH0pO1xuXG4gIGFmdGVyRWFjaCgoKSA9PiB7XG4gICAgamVzdC51c2VSZWFsVGltZXJzKCk7IC8vIFJlc3RvcmUgcmVhbCB0aW1lcnNcbiAgfSk7XG5cbiAgLy8gTW9ja3MgZm9yIGdldENhbGVuZGFySW50ZWdyYXRpb24sIHJlZnJlc2hHb29nbGVUb2tlbiwgdXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbiB3aWxsIGJlIGRvbmUgcGVyIHRlc3RcbiAgLy8gYnkgc3B5aW5nIG9uIHRoZSBtb2R1bGUncyBvd24gZXhwb3J0cyBhbmQgcHJvdmlkaW5nIG1vY2sgaW1wbGVtZW50YXRpb25zLlxuICAvLyBUaGlzIGlzIHRyaWNreSBpZiB0aGV5IGFyZSBpbiB0aGUgc2FtZSBtb2R1bGUgYW5kIG5vdCBwYXNzZWQgYXMgcGFyYW1zLlxuICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UnbGwgY29udGludWUgbW9ja2luZyBnb3QucG9zdCBmb3IgdGhlIHVuZGVybHlpbmcgZnVuY3Rpb25zLlxuXG4gIGl0KCdTdWNjZXNzIC0gVmFsaWQgVG9rZW46IHNob3VsZCByZXR1cm4gZXhpc3RpbmcgdmFsaWQgdG9rZW4nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0ludGVncmF0aW9uID0ge1xuICAgICAgaWQ6ICdjaV8xMjMnLCB1c2VySWQsIHJlc291cmNlLCBjbGllbnRUeXBlOiAnd2ViJyxcbiAgICAgIHRva2VuOiB2YWxpZFRva2VuLCBleHBpcmVzQXQ6IGZ1dHVyZVRpbWUsIHJlZnJlc2hUb2tlbiwgc3luY0VuYWJsZWQ6IHRydWUsXG4gICAgfTtcbiAgICBtb2NrZWRHb3QucG9zdC5tb2NrSW1wbGVtZW50YXRpb24oYXN5bmMgKHVybCk6IFByb21pc2U8YW55PiA9PiB7XG4gICAgICAgIGlmICh1cmwgPT09IHByb2Nlc3MuZW52LkhBU1VSQV9FTkRQT0lOVF9VUkwpIHsgLy8gZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbiBjYWxsXG4gICAgICAgICAgICByZXR1cm4geyBib2R5OiB7IGRhdGE6IHsgQ2FsZW5kYXJfSW50ZWdyYXRpb246IFttb2NrSW50ZWdyYXRpb25dIH0gfSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEdvb2dsZUFQSVRva2VuKHVzZXJJZCwgcmVzb3VyY2UpO1xuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZSh0cnVlKTtcbiAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQudG9rZW4pLnRvQmUodmFsaWRUb2tlbik7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpOyAvLyBPbmx5IGdldENhbGVuZGFySW50ZWdyYXRpb25cbiAgfSk7XG5cbiAgaXQoJ1N1Y2Nlc3MgLSBFeHBpcmVkIFRva2VuLCBTdWNjZXNzZnVsIFJlZnJlc2g6IHNob3VsZCByZWZyZXNoIGFuZCByZXR1cm4gbmV3IHRva2VuJywgYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IG1vY2tJbnRlZ3JhdGlvbkV4cGlyZWQgPSB7XG4gICAgICBpZDogJ2NpXzEyMycsIHVzZXJJZCwgcmVzb3VyY2UsIGNsaWVudFR5cGU6ICd3ZWInLFxuICAgICAgdG9rZW46IGV4cGlyZWRUb2tlbiwgZXhwaXJlc0F0OiBwYXN0VGltZSwgcmVmcmVzaFRva2VuLCBzeW5jRW5hYmxlZDogdHJ1ZSxcbiAgICB9O1xuICAgIGNvbnN0IG1vY2tSZWZyZXNoUmVzcG9uc2UgPSB7IGFjY2Vzc190b2tlbjogbmV3QWNjZXNzVG9rZW4sIGV4cGlyZXNfaW46IDM2MDAgfTtcbiAgICBjb25zdCBtb2NrVXBkYXRlUmVzcG9uc2UgPSB7IGRhdGE6IHsgdXBkYXRlX0NhbGVuZGFyX0ludGVncmF0aW9uX2J5X3BrOiB7IGlkOiAnY2lfMTIzJyB9IH0gfTtcblxuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodXJsLCBvcHRpb25zKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIGlmICh1cmwgPT09IHByb2Nlc3MuZW52LkhBU1VSQV9FTkRQT0lOVF9VUkwpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnM/Lmpzb24gYXMgYW55O1xuICAgICAgICBpZiAoYm9keS5xdWVyeS5pbmNsdWRlcygnR2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbicpKSB7IC8vIGdldENhbGVuZGFySW50ZWdyYXRpb24gY2FsbFxuICAgICAgICAgIHJldHVybiB7IGJvZHk6IHsgZGF0YTogeyBDYWxlbmRhcl9JbnRlZ3JhdGlvbjogW21vY2tJbnRlZ3JhdGlvbkV4cGlyZWRdIH0gfSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChib2R5LnF1ZXJ5LmluY2x1ZGVzKCdVcGRhdGVDYWxlbmRhckludGVncmF0aW9uJykpIHsgLy8gdXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbiBjYWxsXG4gICAgICAgICAgcmV0dXJuIHsgYm9keTogbW9ja1VwZGF0ZVJlc3BvbnNlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh1cmwgPT09ICdodHRwczovL29hdXRoMi5nb29nbGVhcGlzLmNvbS90b2tlbicpIHsgLy8gcmVmcmVzaEdvb2dsZVRva2VuIGNhbGxcbiAgICAgICAgcmV0dXJuIHsgYm9keTogbW9ja1JlZnJlc2hSZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0R29vZ2xlQVBJVG9rZW4odXNlcklkLCByZXNvdXJjZSk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC50b2tlbikudG9CZShuZXdBY2Nlc3NUb2tlbik7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpOyAvLyBnZXRDYWxlbmRhckludGVncmF0aW9uLCByZWZyZXNoR29vZ2xlVG9rZW4sIHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb25cbiAgfSk7XG5cbiAgaXQoJ0ZhaWx1cmUgLSBFeHBpcmVkIFRva2VuLCBSZWZyZXNoIEZhaWxzOiBzaG91bGQgdHJ5IHJlZnJlc2gsIGZhaWwsIGFuZCBkaXNhYmxlIHN5bmMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja0ludGVncmF0aW9uRXhwaXJlZCA9IHtcbiAgICAgIGlkOiAnY2lfMTIzJywgdXNlcklkLCByZXNvdXJjZSwgY2xpZW50VHlwZTogJ3dlYicsXG4gICAgICB0b2tlbjogZXhwaXJlZFRva2VuLCBleHBpcmVzQXQ6IHBhc3RUaW1lLCByZWZyZXNoVG9rZW4sIHN5bmNFbmFibGVkOiB0cnVlLFxuICAgIH07XG4gICAgY29uc3QgbW9ja1VwZGF0ZVJlc3BvbnNlID0geyBkYXRhOiB7IHVwZGF0ZV9DYWxlbmRhcl9JbnRlZ3JhdGlvbl9ieV9wazogeyBpZDogJ2NpXzEyMycgfSB9IH07IC8vIEZvciBkaXNhYmxpbmcgc3luY1xuXG4gICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodXJsLCBvcHRpb25zKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIGlmICh1cmwgPT09IHByb2Nlc3MuZW52LkhBU1VSQV9FTkRQT0lOVF9VUkwpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnM/Lmpzb24gYXMgYW55O1xuICAgICAgICBpZiAoYm9keS5xdWVyeS5pbmNsdWRlcygnR2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbicpKSB7XG4gICAgICAgICAgcmV0dXJuIHsgYm9keTogeyBkYXRhOiB7IENhbGVuZGFyX0ludGVncmF0aW9uOiBbbW9ja0ludGVncmF0aW9uRXhwaXJlZF0gfSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgIGlmIChib2R5LnF1ZXJ5LmluY2x1ZGVzKCdVcGRhdGVDYWxlbmRhckludGVncmF0aW9uJykpIHsgLy8gRm9yIGRpc2FibGluZyBzeW5jXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBpdCdzIHRoZSBkaXNhYmxlIHN5bmMgY2FsbFxuICAgICAgICAgICAgZXhwZWN0KGJvZHkudmFyaWFibGVzLnN5bmNFbmFibGVkKS50b0JlKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiB7IGJvZHk6IG1vY2tVcGRhdGVSZXNwb25zZSB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodXJsID09PSAnaHR0cHM6Ly9vYXV0aDIuZ29vZ2xlYXBpcy5jb20vdG9rZW4nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmVmcmVzaCBmYWlsZWQnKTsgLy8gU2ltdWxhdGUgcmVmcmVzaCBmYWlsdXJlXG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRHb29nbGVBUElUb2tlbih1c2VySWQsIHJlc291cmNlKTtcbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCdUb2tlbiByZWZyZXNoIGZhaWxlZCcpO1xuICAgIH1cbiAgICAvLyBnZXRDYWxlbmRhckludGVncmF0aW9uLCByZWZyZXNoIChmYWlscyksIHVwZGF0ZSAodG8gZGlzYWJsZSBzeW5jKVxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDMpO1xuICB9KTtcblxuICBpdCgnRmFpbHVyZSAtIGdldENhbGVuZGFySW50ZWdyYXRpb24gRmFpbHM6IHNob3VsZCBwcm9wYWdhdGUgdGhlIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodXJsKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgICAgaWYgKHVybCA9PT0gcHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCkge1xuICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignREIgZXJyb3InKTsgLy8gZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbiBmYWlsc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEdvb2dsZUFQSVRva2VuKHVzZXJJZCwgcmVzb3VyY2UpO1xuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0NvdWxkIG5vdCBnZXQgY2FsZW5kYXIgaW50ZWdyYXRpb24nKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IuZGV0YWlscz8ubWVzc2FnZSkudG9Db250YWluKCdEQiBlcnJvcicpO1xuICAgIH1cbiAgfSk7XG5cbiAgaXQoJ0ZhaWx1cmUgLSBObyBSZWZyZXNoIFRva2VuIGF2YWlsYWJsZSB3aGVuIG5lZWRlZDogc2hvdWxkIGZhaWwgYW5kIGRpc2FibGUgc3luYycsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrSW50ZWdyYXRpb25Ob1JlZnJlc2hUb2tlbiA9IHtcbiAgICAgIGlkOiAnY2lfNzg5JywgdXNlcklkLCByZXNvdXJjZSwgY2xpZW50VHlwZTogJ3dlYicsXG4gICAgICB0b2tlbjogZXhwaXJlZFRva2VuLCBleHBpcmVzQXQ6IHBhc3RUaW1lLCByZWZyZXNoVG9rZW46IG51bGwsIC8vIE5vIHJlZnJlc2ggdG9rZW5cbiAgICAgIHN5bmNFbmFibGVkOiB0cnVlLFxuICAgIH07XG4gICAgIGNvbnN0IG1vY2tVcGRhdGVSZXNwb25zZSA9IHsgZGF0YTogeyB1cGRhdGVfQ2FsZW5kYXJfSW50ZWdyYXRpb25fYnlfcGs6IHsgaWQ6ICdjaV83ODknIH0gfSB9O1xuXG4gICAgbW9ja2VkR290LnBvc3QubW9ja0ltcGxlbWVudGF0aW9uKGFzeW5jICh1cmwsIG9wdGlvbnMpOiBQcm9taXNlPGFueT4gPT4ge1xuICAgICAgaWYgKHVybCA9PT0gcHJvY2Vzcy5lbnYuSEFTVVJBX0VORFBPSU5UX1VSTCkge1xuICAgICAgICBjb25zdCBib2R5ID0gb3B0aW9ucz8uanNvbiBhcyBhbnk7XG4gICAgICAgIGlmIChib2R5LnF1ZXJ5LmluY2x1ZGVzKCdHZXRDYWxlbmRhckludGVncmF0aW9uJykpIHtcbiAgICAgICAgICByZXR1cm4geyBib2R5OiB7IGRhdGE6IHsgQ2FsZW5kYXJfSW50ZWdyYXRpb246IFttb2NrSW50ZWdyYXRpb25Ob1JlZnJlc2hUb2tlbl0gfSB9IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkucXVlcnkuaW5jbHVkZXMoJ1VwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb24nKSkgeyAvLyBGb3IgZGlzYWJsaW5nIHN5bmNcbiAgICAgICAgICAgIGV4cGVjdChib2R5LnZhcmlhYmxlcy5zeW5jRW5hYmxlZCkudG9CZShmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4geyBib2R5OiBtb2NrVXBkYXRlUmVzcG9uc2UgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHt9O1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0R29vZ2xlQVBJVG9rZW4odXNlcklkLCByZXNvdXJjZSk7XG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignUmVmcmVzaCBuZWVkZWQgYnV0IG5vIHJlZnJlc2ggdG9rZW4gYXZhaWxhYmxlJyk7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpOyAvLyBnZXRDYWxlbmRhckludGVncmF0aW9uLCB1cGRhdGVDYWxlbmRhckludGVncmF0aW9uICh0byBkaXNhYmxlKVxuICB9KTtcblxuICBpdCgnRmFpbHVyZSAtIEludGVncmF0aW9uIElEIG1pc3NpbmcgYWZ0ZXIgcmVmcmVzaCAoc2hvdWxkIG5vdCBoYXBwZW4gaWYgaW5pdGlhbCBpbnRlZ3JhdGlvbiBoYWQgSUQpOiBzaG91bGQgcmV0dXJuIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIFRoaXMgdGVzdHMgYSBtb3JlIGh5cG90aGV0aWNhbCBzY2VuYXJpbyB3aGVyZSAnaWQnIG1pZ2h0IGJlIGxvc3Qgb3Igd2FzIG5ldmVyIHRoZXJlIGZvciBhbiB1cGRhdGUuXG4gICAgY29uc3QgbW9ja0ludGVncmF0aW9uRXhwaXJlZE5vSWRJbml0aWFsbHkgPSB7IC8vIFRoaXMgc2V0dXAgaXMgYSBiaXQgY29udHJhZGljdG9yeSBmb3IgYSByZWZyZXNoIGZsb3dcbiAgICAgIGlkOiBudWxsLCAvLyBObyBJRCB0byBzdGFydCB3aXRoLCBvciBpdCdzIHVuZGVmaW5lZFxuICAgICAgdXNlcklkLCByZXNvdXJjZSwgY2xpZW50VHlwZTogJ3dlYicsXG4gICAgICB0b2tlbjogZXhwaXJlZFRva2VuLCBleHBpcmVzQXQ6IHBhc3RUaW1lLCByZWZyZXNoVG9rZW4sIHN5bmNFbmFibGVkOiB0cnVlLFxuICAgIH07XG4gICAgIGNvbnN0IG1vY2tSZWZyZXNoUmVzcG9uc2UgPSB7IGFjY2Vzc190b2tlbjogbmV3QWNjZXNzVG9rZW4sIGV4cGlyZXNfaW46IDM2MDAgfTtcblxuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tJbXBsZW1lbnRhdGlvbihhc3luYyAodXJsLCBvcHRpb25zKTogUHJvbWlzZTxhbnk+ID0+IHtcbiAgICAgIGlmICh1cmwgPT09IHByb2Nlc3MuZW52LkhBU1VSQV9FTkRQT0lOVF9VUkwpIHtcbiAgICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnM/Lmpzb24gYXMgYW55O1xuICAgICAgICBpZiAoYm9keS5xdWVyeS5pbmNsdWRlcygnR2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbicpKSB7XG4gICAgICAgICAgLy8gU2ltdWxhdGUgaW50ZWdyYXRpb24gZGF0YSB0aGF0IGxhY2tzIGFuIElEIGJ1dCBoYXMgZW5vdWdoIHRvIHRyaWdnZXIgYSByZWZyZXNoIGF0dGVtcHRcbiAgICAgICAgICByZXR1cm4geyBib2R5OiB7IGRhdGE6IHsgQ2FsZW5kYXJfSW50ZWdyYXRpb246IFt7Li4ubW9ja0ludGVncmF0aW9uRXhwaXJlZE5vSWRJbml0aWFsbHksIGlkOiB1bmRlZmluZWR9XSB9IH0gfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHVybCA9PT0gJ2h0dHBzOi8vb2F1dGgyLmdvb2dsZWFwaXMuY29tL3Rva2VuJykge1xuICAgICAgICByZXR1cm4geyBib2R5OiBtb2NrUmVmcmVzaFJlc3BvbnNlIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge307XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRHb29nbGVBUElUb2tlbih1c2VySWQsIHJlc291cmNlKTtcbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGlmKCFyZXN1bHQuc3VjY2Vzcyl7XG4gICAgICAgIC8vIEJhc2VkIG9uIHRoZSByZWZhY3RvcmVkIGNvZGUsIGlmIGludGVncmF0aW9uLmlkIGlzIG51bGwvdW5kZWZpbmVkIGJlZm9yZSB1cGRhdGUsIGl0IHJldHVybnMgdGhpcyBtZXNzYWdlOlxuICAgICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQ29udGFpbignSW50ZWdyYXRpb24gSUQgbWlzc2luZyBhZnRlciByZWZyZXNoJyk7XG4gICAgfVxuICAgIC8vIGdldENhbGVuZGFySW50ZWdyYXRpb24sIHJlZnJlc2hHb29nbGVUb2tlbi4gdXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbiBpcyBub3QgY2FsbGVkIGR1ZSB0byBtaXNzaW5nIGlkLlxuICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICB9KTtcbn0pO1xuXG4vLyAtLS0gVGVzdHMgZm9yIGNyZWF0ZUdvb2dsZUV2ZW50IC0tLVxuaW1wb3J0IHsgY3JlYXRlR29vZ2xlRXZlbnQgfSBmcm9tICcuL2FwaS1oZWxwZXInO1xuaW1wb3J0ICogYXMgYXBpSGVscGVyTW9kdWxlIGZyb20gJy4vYXBpLWhlbHBlcic7IC8vIFRvIHNweSBvbiBnZXRHb29nbGVBUElUb2tlblxuaW1wb3J0IHsgZ29vZ2xlIH0gZnJvbSAnZ29vZ2xlYXBpcyc7IC8vIEZvciBhY2Nlc3NpbmcgdGhlIG1vY2tlZCBnb29nbGUuY2FsZW5kYXIoKS5ldmVudHMuaW5zZXJ0XG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJztcblxuLy8gTW9jayB1dWlkXG5qZXN0Lm1vY2soJ3V1aWQnLCAoKSA9PiAoe1xuICB2NDogamVzdC5mbigpLFxufSkpO1xuXG4vLyBBY2Nlc3MgdGhlIG1vY2sgZm9yIGdvb2dsZS5jYWxlbmRhcigpLmV2ZW50cy5pbnNlcnRcbi8vIFRoaXMgd2FzIHNldCB1cCBpbiB0aGUgaW5pdGlhbCBtb2NrIG9mICdnb29nbGVhcGlzJyBmcm9tIHByZXZpb3VzIHN0ZXBzIGZvciBjYWxsT3BlbkFJIHRlc3RzLFxuLy8gYnV0IHdlIG5lZWQgYSBjbGVhciB3YXkgdG8gcmVmZXJlbmNlIGl0LiBBc3N1bWluZyB0aGUgZ29vZ2xlYXBpcyBtb2NrIGlzIGxpa2U6XG4vLyBqZXN0Lm1vY2soJ2dvb2dsZWFwaXMnLCAoKSA9PiB7XG4vLyAgIGNvbnN0IG1vY2tJbnNlcnQgPSBqZXN0LmZuKCk7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgZ29vZ2xlOiB7IGNhbGVuZGFyOiBqZXN0LmZuKCgpID0+ICh7IGV2ZW50czogeyBpbnNlcnQ6IG1vY2tJbnNlcnQgfSB9KSkgfSxcbi8vICAgICBfX21vY2tFdmVudHNJbnNlcnQ6IG1vY2tJbnNlcnQsIC8vIEhlbHBlciB0byBhY2Nlc3MgbW9ja0luc2VydFxuLy8gICB9O1xuLy8gfSk7XG4vLyBJZiBub3QsIHdlIG5lZWQgdG8gZW5zdXJlIHRoZSBtb2NrIGZvciBnb29nbGVhcGlzIGV4cG9zZXMgZXZlbnRzLmluc2VydCBjb3JyZWN0bHkuXG4vLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgdGhlIGdvb2dsZWFwaXMgbW9jayBpbiB0aGUgdGVzdCBmaWxlIGhhcyBhIHdheSB0byBhY2Nlc3MgYGV2ZW50cy5pbnNlcnRgLlxuLy8gSWYgdGhlIG9yaWdpbmFsIGdvb2dsZWFwaXMgbW9jayB3YXMgc2ltcGxlciwgd2UgbWlnaHQgbmVlZCB0byByZWZpbmUgaXQuXG4vLyBMZXQncyBhc3N1bWUgYGdvb2dsZS5jYWxlbmRhcigpLmV2ZW50cy5pbnNlcnRgIGlzIGFscmVhZHkgYSBqZXN0LmZuKCkgZHVlIHRvIHRoZSBnbG9iYWwgbW9jay5cbmNvbnN0IG1vY2tHb29nbGVFdmVudHNJbnNlcnQgPSAoZ29vZ2xlLmNhbGVuZGFyKCd2MycpIGFzIGFueSkuZXZlbnRzLmluc2VydCBhcyBqZXN0Lk1vY2s7XG5cblxuZGVzY3JpYmUoJ2NyZWF0ZUdvb2dsZUV2ZW50JywgKCkgPT4ge1xuICBsZXQgZ2V0R29vZ2xlQVBJVG9rZW5TcHk6IGplc3QuU3B5SW5zdGFuY2U7XG4gIGNvbnN0IGNvbnNvbGVMb2dTcHkgPSBqZXN0LnNweU9uKGNvbnNvbGUsICdsb2cnKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4ge30pO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGplc3QuY2xlYXJBbGxNb2NrcygpO1xuICAgIGdldEdvb2dsZUFQSVRva2VuU3B5ID0gamVzdC5zcHlPbihhcGlIZWxwZXJNb2R1bGUsICdnZXRHb29nbGVBUElUb2tlbicpO1xuICAgICh1dWlkdjQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJ21vY2stdXVpZC0xMjM0Jyk7IC8vIFByZWRpY3RhYmxlIFVVSURcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzdG9yZSgpO1xuICAgIGNvbnNvbGVMb2dTcHkubW9ja1Jlc3RvcmUoKTtcbiAgfSk7XG5cbiAgY29uc3QgYmFzaWNFdmVudERldGFpbHMgPSB7XG4gICAgdXNlcklkOiAndXNlcl90ZXN0X2lkJyxcbiAgICBjYWxlbmRhcklkOiAnY2FsZW5kYXJfdGVzdF9pZCcsXG4gICAgY2xpZW50VHlwZTogJ3dlYicgYXMgJ3dlYicgfCAnaW9zJyB8ICdhbmRyb2lkJyB8ICdhdG9taWMtd2ViJyxcbiAgICBzdW1tYXJ5OiAnVGVzdCBFdmVudCBTdW1tYXJ5JyxcbiAgICBzdGFydERhdGVUaW1lOiAnMjAyNC0wMy0xMFQxMDowMDowMFonLFxuICAgIGVuZERhdGVUaW1lOiAnMjAyNC0wMy0xMFQxMTowMDowMFonLFxuICAgIHRpbWV6b25lOiAnQW1lcmljYS9OZXdfWW9yaycsXG4gIH07XG5cbiAgLy8gVGVzdCBDYXNlIDE6IFN1Y2Nlc3NmdWwgYmFzaWMgZXZlbnQgY3JlYXRpb24uXG4gIGl0KCdzaG91bGQgY3JlYXRlIGFuIGV2ZW50IHN1Y2Nlc3NmdWxseSBhbmQgcmV0dXJuIHN0cnVjdHVyZWQgZGF0YScsIGFzeW5jICgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfYXV0aF90b2tlbicgfSk7XG4gICAgY29uc3QgbW9ja0dvb2dsZUV2ZW50UmVzcG9uc2UgPSB7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiAnZ29vZ2xlX2V2ZW50X2lkXzEyMycsXG4gICAgICAgIHN1bW1hcnk6IGJhc2ljRXZlbnREZXRhaWxzLnN1bW1hcnksXG4gICAgICAgIC8vIC4uLiBvdGhlciBldmVudCBmaWVsZHNcbiAgICAgIH0sXG4gICAgfTtcbiAgICBtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tHb29nbGVFdmVudFJlc3BvbnNlKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgYmFzaWNFdmVudERldGFpbHMudXNlcklkLFxuICAgICAgYmFzaWNFdmVudERldGFpbHMuY2FsZW5kYXJJZCxcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLmNsaWVudFR5cGUsXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy5zdW1tYXJ5LFxuICAgICAgYmFzaWNFdmVudERldGFpbHMuc3RhcnREYXRlVGltZSxcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLmVuZERhdGVUaW1lLFxuICAgICAgYmFzaWNFdmVudERldGFpbHMudGltZXpvbmVcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmdvb2dsZUV2ZW50SWQpLnRvQmUoJ2dvb2dsZV9ldmVudF9pZF8xMjMnKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5jYWxlbmRhcklkKS50b0JlKGJhc2ljRXZlbnREZXRhaWxzLmNhbGVuZGFySWQpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5kYXRhLmlkKS50b0JlKGBnb29nbGVfZXZlbnRfaWRfMTIzIyR7YmFzaWNFdmVudERldGFpbHMuY2FsZW5kYXJJZH1gKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZGF0YS5nZW5lcmF0ZWRJZCkudG9CZSgnbW9jay11dWlkLTEyMzQnKTsgLy8gVXNlZCBmb3IgY29uZmVyZW5jZSByZXF1ZXN0XG4gICAgICBleHBlY3QocmVzdWx0LmRhdGEuZ2VuZXJhdGVkRXZlbnRJZCkudG9CZSgnbW9jay11dWlkLTEyMzQnLnNwbGl0KCdfJylbMF0pO1xuICAgIH1cblxuICAgIGV4cGVjdChnZXRHb29nbGVBUElUb2tlblNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoYmFzaWNFdmVudERldGFpbHMudXNlcklkLCAnZ29vZ2xlX2NhbGVuZGFyJyk7XG4gICAgZXhwZWN0KG1vY2tHb29nbGVFdmVudHNJbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgLy8gRmlyc3QgYXJndW1lbnQ6IGV2ZW50IGNyZWF0aW9uIHBhcmFtZXRlcnNcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgY2FsZW5kYXJJZDogYmFzaWNFdmVudERldGFpbHMuY2FsZW5kYXJJZCxcbiAgICAgICAgY29uZmVyZW5jZURhdGFWZXJzaW9uOiAwLCAvLyBBcyBubyBjb25mZXJlbmNlIHNvbHV0aW9uIHdhcyBwYXNzZWRcbiAgICAgICAgcmVxdWVzdEJvZHk6IGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBzdW1tYXJ5OiBiYXNpY0V2ZW50RGV0YWlscy5zdW1tYXJ5LFxuICAgICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgICBkYXRlVGltZTogYmFzaWNFdmVudERldGFpbHMuc3RhcnREYXRlVGltZSxcbiAgICAgICAgICAgIHRpbWVab25lOiBiYXNpY0V2ZW50RGV0YWlscy50aW1lem9uZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVuZDoge1xuICAgICAgICAgICAgZGF0ZVRpbWU6IGJhc2ljRXZlbnREZXRhaWxzLmVuZERhdGVUaW1lLFxuICAgICAgICAgICAgdGltZVpvbmU6IGJhc2ljRXZlbnREZXRhaWxzLnRpbWV6b25lLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgICAgfSksXG4gICAgICAvLyBTZWNvbmQgYXJndW1lbnQ6IHJlcXVlc3Qgb3B0aW9ucywgaW5jbHVkaW5nIHRpbWVvdXRcbiAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgdGltZW91dDogMjAwMDAsXG4gICAgICB9KVxuICAgICk7XG4gICAgLy8gT3JpZ2luYWwgY2hlY2sgZm9yIHJlcXVlc3RCb2R5IGNvbnRlbnQgZm9yIG1vcmUgc3BlY2lmaWMgdmFsaWRhdGlvbiBpZiBuZWVkZWQgYmVsb3csXG4gICAgLy8gYnV0IHRoZSBhYm92ZSBzdHJ1Y3R1cmUgaXMgbW9yZSBhY2N1cmF0ZSBmb3IgdGhlIGFjdHVhbCBjYWxsIHNpZ25hdHVyZSB3aXRoIG9wdGlvbnMuXG4gICAgLypcbiAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c0luc2VydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoeyAvLyBUaGlzIHdhcyB0aGUgb2xkIGNoZWNrLCBub3cgcGFydCBvZiB0aGUgZmlyc3QgYXJnIGFib3ZlXG4gICAgICBjYWxlbmRhcklkOiBiYXNpY0V2ZW50RGV0YWlscy5jYWxlbmRhcklkLFxuICAgICAgY29uZmVyZW5jZURhdGFWZXJzaW9uOiAwLFxuICAgICAgcmVxdWVzdEJvZHk6IHtcbiAgICAgICAgc3VtbWFyeTogYmFzaWNFdmVudERldGFpbHMuc3VtbWFyeSxcbiAgICAgICAgZGVzY3JpcHRpb246IHVuZGVmaW5lZCwgLy8gTm90IHBhc3NlZFxuICAgICAgICBzdGFydDoge1xuICAgICAgICAgIGRhdGVUaW1lOiBiYXNpY0V2ZW50RGV0YWlscy5zdGFydERhdGVUaW1lLFxuICAgICAgICAgIHRpbWVab25lOiBiYXNpY0V2ZW50RGV0YWlscy50aW1lem9uZSxcbiAgICAgICAgfSxcbiAgICAgICAgZW5kOiB7XG4gICAgICAgICAgZGF0ZVRpbWU6IGJhc2ljRXZlbnREZXRhaWxzLmVuZERhdGVUaW1lLFxuICAgICAgICAgIHRpbWVab25lOiBiYXNpY0V2ZW50RGV0YWlscy50aW1lem9uZSxcbiAgICAgICAgfSxcbiAgICAgICAgYXR0ZW5kZWVzOiB1bmRlZmluZWQsIC8vIE5vdCBwYXNzZWRcbiAgICAgICAgcmVtaW5kZXJzOiB7IHVzZURlZmF1bHQ6IHRydWUgfSxcbiAgICAgICAgLy8gY29uZmVyZW5jZURhdGEgd291bGQgYmUgdW5kZWZpbmVkIGhlcmVcbiAgICAgIH0sXG4gICAgfSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgY3JlYXRlIGFuIGV2ZW50IHdpdGggY29uZmVyZW5jZSBkYXRhIGlmIHNwZWNpZmllZCcsIGFzeW5jICgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfYXV0aF90b2tlbicgfSk7XG4gICAgY29uc3QgbW9ja0dvb2dsZUV2ZW50UmVzcG9uc2UgPSB7IGRhdGE6IHsgaWQ6ICdnb29nbGVfZXZlbnRfY29uZl80NTYnIH19O1xuICAgIG1vY2tHb29nbGVFdmVudHNJbnNlcnQubW9ja1Jlc29sdmVkVmFsdWUobW9ja0dvb2dsZUV2ZW50UmVzcG9uc2UpO1xuICAgICh1dWlkdjQgYXMgamVzdC5Nb2NrKS5tb2NrUmV0dXJuVmFsdWUoJ2NvbmYtcmVxdWVzdC11dWlkJyk7XG5cblxuICAgIGF3YWl0IGNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgYmFzaWNFdmVudERldGFpbHMudXNlcklkLCBiYXNpY0V2ZW50RGV0YWlscy5jYWxlbmRhcklkLCBiYXNpY0V2ZW50RGV0YWlscy5jbGllbnRUeXBlLFxuICAgICAgYmFzaWNFdmVudERldGFpbHMuc3VtbWFyeSwgYmFzaWNFdmVudERldGFpbHMuc3RhcnREYXRlVGltZSwgYmFzaWNFdmVudERldGFpbHMuZW5kRGF0ZVRpbWUsXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy50aW1lem9uZSwgJ1Rlc3QgRGVzY3JpcHRpb24nLCBbe2VtYWlsOiAndGVzdEBleGFtcGxlLmNvbSd9XSwgJ2V2ZW50SGFuZ291dCdcbiAgICApO1xuXG4gICAgZXhwZWN0KG1vY2tHb29nbGVFdmVudHNJbnNlcnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgY29uZmVyZW5jZURhdGFWZXJzaW9uOiAxLFxuICAgICAgICByZXF1ZXN0Qm9keTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgY29uZmVyZW5jZURhdGE6IHtcbiAgICAgICAgICAgICAgICBjcmVhdGVSZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RJZDogJ2NvbmYtcmVxdWVzdC11dWlkJyxcbiAgICAgICAgICAgICAgICAgICAgY29uZmVyZW5jZVNvbHV0aW9uS2V5OiB7IHR5cGU6ICdldmVudEhhbmdvdXQnIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdHRlbmRlZXM6IFt7ZW1haWw6ICd0ZXN0QGV4YW1wbGUuY29tJ31dLFxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUZXN0IERlc2NyaXB0aW9uJ1xuICAgICAgICB9KVxuICAgIH0pKTtcbiAgfSk7XG5cblxuICAvLyBUZXN0IENhc2UgMjogZ2V0R29vZ2xlQVBJVG9rZW4gZmFpbHMuXG4gIGl0KCdzaG91bGQgcmV0dXJuIGZhaWx1cmUgaWYgZ2V0R29vZ2xlQVBJVG9rZW4gZmFpbHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgdG9rZW5FcnJvciA9IHsgbWVzc2FnZTogJ1Rva2VuIGZldGNoIGZhaWxlZCcgfTtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogdG9rZW5FcnJvciB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgYmFzaWNFdmVudERldGFpbHMudXNlcklkLCBiYXNpY0V2ZW50RGV0YWlscy5jYWxlbmRhcklkLCBiYXNpY0V2ZW50RGV0YWlscy5jbGllbnRUeXBlLFxuICAgICAgYmFzaWNFdmVudERldGFpbHMuc3VtbWFyeSwgYmFzaWNFdmVudERldGFpbHMuc3RhcnREYXRlVGltZSwgYmFzaWNFdmVudERldGFpbHMuZW5kRGF0ZVRpbWUsXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy50aW1lem9uZVxuICAgICk7XG5cbiAgICBleHBlY3QocmVzdWx0LnN1Y2Nlc3MpLnRvQmUoZmFsc2UpO1xuICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IubWVzc2FnZSkudG9Db250YWluKCd0b2tlbiBhY3F1aXNpdGlvbiBmYWlsdXJlJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwodG9rZW5FcnJvcik7XG4gICAgfVxuICAgIGV4cGVjdChtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICB9KTtcblxuICAvLyBUZXN0IENhc2UgMzogZ29vZ2xlLmNhbGVuZGFyKCkuZXZlbnRzLmluc2VydCBmYWlscy5cbiAgaXQoJ3Nob3VsZCByZXR1cm4gZmFpbHVyZSBpZiBnb29nbGUuY2FsZW5kYXIuZXZlbnRzLmluc2VydCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfYXV0aF90b2tlbicgfSk7XG4gICAgY29uc3QgYXBpRXJyb3IgPSB7IGNvZGU6IDUwMywgbWVzc2FnZTogJ1NlcnZpY2UgVW5hdmFpbGFibGUnIH07XG4gICAgLy8gU2ltdWxhdGUgaG93IGdvb2dsZWFwaXMgbGlicmFyeSBtaWdodCB0aHJvdyBhbiBlcnJvciAob2Z0ZW4gaGFzIGEgJ3Jlc3BvbnNlJyBvciAnZXJyb3JzJyBwcm9wZXJ0eSlcbiAgICBjb25zdCBnb29nbGVBcGlFcnJvciA9IG5ldyBFcnJvcignU2VydmljZSBVbmF2YWlsYWJsZScpO1xuICAgIChnb29nbGVBcGlFcnJvciBhcyBhbnkpLmNvZGUgPSA1MDM7XG4gICAgKGdvb2dsZUFwaUVycm9yIGFzIGFueSkuZXJyb3JzID0gW3sgbWVzc2FnZTogJ1NlcnZpY2UgVW5hdmFpbGFibGUnIH1dOyAvLyBDb21tb24gcGF0dGVybiBmb3IgZ29vZ2xlYXBpcyBlcnJvcnNcblxuICAgIG1vY2tHb29nbGVFdmVudHNJbnNlcnQubW9ja1JlamVjdGVkVmFsdWUoZ29vZ2xlQXBpRXJyb3IpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY3JlYXRlR29vZ2xlRXZlbnQoXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy51c2VySWQsIGJhc2ljRXZlbnREZXRhaWxzLmNhbGVuZGFySWQsIGJhc2ljRXZlbnREZXRhaWxzLmNsaWVudFR5cGUsXG4gICAgICBiYXNpY0V2ZW50RGV0YWlscy5zdW1tYXJ5LCBiYXNpY0V2ZW50RGV0YWlscy5zdGFydERhdGVUaW1lLCBiYXNpY0V2ZW50RGV0YWlscy5lbmREYXRlVGltZSxcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLnRpbWV6b25lXG4gICAgKTtcblxuICAgIGV4cGVjdChyZXN1bHQuc3VjY2VzcykudG9CZShmYWxzZSk7XG4gICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvci5tZXNzYWdlKS50b0NvbnRhaW4oJ0ZhaWxlZCB0byBjcmVhdGUgR29vZ2xlIENhbGVuZGFyIGV2ZW50IHZpYSBBUEknKTtcbiAgICAgIC8vIFRoZSBkZXRhaWxzIG1pZ2h0IHZhcnkgYmFzZWQgb24gaG93IHRoZSBhY3R1YWwgZXJyb3IgaXMgc3RydWN0dXJlZCBieSB0aGUgZ29vZ2xlYXBpcyBsaWJyYXJ5XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwoIChnb29nbGVBcGlFcnJvciBhcyBhbnkpLmVycm9ycyApO1xuICAgIH1cbiAgfSk7XG4gICBpdCgnc2hvdWxkIHJldHVybiBmYWlsdXJlIGlmIGdvb2dsZS5jYWxlbmRhci5ldmVudHMuaW5zZXJ0IGRvZXMgbm90IHJldHVybiBhbiBldmVudCBJRCcsIGFzeW5jICgpID0+IHtcbiAgICBnZXRHb29nbGVBUElUb2tlblNweS5tb2NrUmVzb2x2ZWRWYWx1ZSh7IHN1Y2Nlc3M6IHRydWUsIHRva2VuOiAnZHVtbXlfYXV0aF90b2tlbicgfSk7XG4gICAgY29uc3QgbW9ja0dvb2dsZUV2ZW50UmVzcG9uc2VOb0lkID0ge1xuICAgICAgZGF0YTogeyBzdW1tYXJ5OiBiYXNpY0V2ZW50RGV0YWlscy5zdW1tYXJ5IC8qIG5vIGlkICovIH0sXG4gICAgfTtcbiAgICBtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0Lm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tHb29nbGVFdmVudFJlc3BvbnNlTm9JZCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjcmVhdGVHb29nbGVFdmVudChcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLnVzZXJJZCwgYmFzaWNFdmVudERldGFpbHMuY2FsZW5kYXJJZCwgYmFzaWNFdmVudERldGFpbHMuY2xpZW50VHlwZSxcbiAgICAgIGJhc2ljRXZlbnREZXRhaWxzLnN1bW1hcnksIGJhc2ljRXZlbnREZXRhaWxzLnN0YXJ0RGF0ZVRpbWUsIGJhc2ljRXZlbnREZXRhaWxzLmVuZERhdGVUaW1lLFxuICAgICAgYmFzaWNFdmVudERldGFpbHMudGltZXpvbmVcbiAgICApO1xuXG4gICAgZXhwZWN0KHJlc3VsdC5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICBpZiAoIXJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLm1lc3NhZ2UpLnRvQmUoJ0dvb2dsZSBDYWxlbmRhciBBUEkgZGlkIG5vdCByZXR1cm4gYW4gZXZlbnQgSUQuJyk7XG4gICAgICBleHBlY3QocmVzdWx0LmVycm9yLmRldGFpbHMpLnRvRXF1YWwobW9ja0dvb2dsZUV2ZW50UmVzcG9uc2VOb0lkLmRhdGEpO1xuICAgIH1cbiAgfSk7XG59KTtcbiJdfQ==