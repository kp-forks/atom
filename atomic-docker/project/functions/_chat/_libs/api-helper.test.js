import { 
// Import functions to test, starting with resilientGotPostHasura (if exported)
// or functions that use it. For now, we'll test it indirectly.
upsertConference, // Example function using resilientGotPostHasura
refreshZoomToken, convertEventTitleToOpenAIVector,
// We'll need to import the logger to spy on it
 } from './api-helper';
import got from 'got';
import axios from 'axios';
// Mock 'got'
jest.mock('got');
const mockedGot = got;
// Mock 'axios'
jest.mock('axios');
const mockedAxios = axios;
// Mock 'openai'
const mockOpenAICreateEmbedding = jest.fn();
const mockOpenAIChatCompletionsCreate = jest.fn();
jest.mock('openai', () => {
    return jest.fn().mockImplementation(() => ({
        embeddings: { create: mockOpenAICreateEmbedding },
        chat: { completions: { create: mockOpenAIChatCompletionsCreate } },
    }));
});
// Mock the logger
jest.mock('./api-helper', () => {
    const originalModule = jest.requireActual('./api-helper');
    const winston = require('winston');
    const mockLogger = {
        info: jest.fn(),
        warn: jest.fn(),
        error: jest.fn(),
        debug: jest.fn(),
    };
    // Create a real logger but spy on its methods
    const actualLogger = winston.createLogger({
        level: 'info',
        transports: [new winston.transports.Console({ silent: true })], // Silent during tests
    });
    for (const level in mockLogger) {
        actualLogger[level] = mockLogger[level];
    }
    return {
        ...originalModule,
        chatApiHelperLogger: actualLogger, // Provide the spied-upon logger
        // resilientGotPostHasura: originalModule.resilientGotPostHasura, // Keep actual implementation
    };
});
describe('_chat/_libs/api-helper.ts', () => {
    const testUserId = 'test-user-123';
    const testOperationName = 'TestHasuraOperation';
    const testQuery = 'query Test { test }';
    const testVariables = { id: 1 };
    const mockSuccessData = { test: 'success' };
    const mockGraphQLErrors = [{ message: 'GraphQL error from Hasura' }];
    // Access the spied logger methods
    let spiedLogger;
    beforeAll(() => {
        // Import here to get the version with the mocked logger
        const apiHelper = require('./api-helper');
        spiedLogger = apiHelper.chatApiHelperLogger;
    });
    beforeEach(() => {
        jest.clearAllMocks(); // Clears spies and mocks
        mockedGot.post.mockReset(); // Reset specifically for got
        mockedAxios.post.mockReset();
        mockedAxios.mockReset(); // For other methods like axios({})
        mockOpenAICreateEmbedding.mockReset();
        mockOpenAIChatCompletionsCreate.mockReset();
    });
    describe('resilientGotPostHasura (tested via a consumer like upsertConference)', () => {
        // We test resilientGotPostHasura indirectly by calling a function that uses it.
        // Let's use upsertConference as an example.
        const mockConferenceInput = { id: 'conf1', name: 'Test Conference' };
        const upsertConferenceQuery = expect.stringContaining('UpsertConference');
        it('should succeed on the first attempt', async () => {
            mockedGot.post.mockResolvedValueOnce({
                json: () => Promise.resolve({ data: { insert_Conference_one: { id: 'conf1' } } }),
            });
            const result = await upsertConference(mockConferenceInput);
            expect(result?.id).toBe('conf1');
            expect(mockedGot.post).toHaveBeenCalledTimes(1);
            expect(mockedGot.post).toHaveBeenCalledWith(वस्तुನಿಷ್ಠ_URL, // Using the actual constant name from the file for hasuraGraphUrl
            expect.objectContaining({
                json: expect.objectContaining({ query: upsertConferenceQuery }),
                timeout: { request: 10000 },
            }));
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Hasura call attempt 1 for UpsertConference'), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Hasura call UpsertConference successful on attempt 1'), expect.anything());
        });
        it('should succeed on the second attempt after a 503 error', async () => {
            mockedGot.post
                .mockRejectedValueOnce({
                response: { statusCode: 503 },
                message: 'Service Unavailable',
                isGotError: true,
            })
                .mockResolvedValueOnce({
                json: () => Promise.resolve({
                    data: { insert_Conference_one: { id: 'conf1' } },
                }),
            });
            const result = await upsertConference(mockConferenceInput);
            expect(result?.id).toBe('conf1');
            expect(mockedGot.post).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining('Hasura call attempt 1 for UpsertConference failed'), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Waiting 1000ms before Hasura retry 1 for UpsertConference'), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Hasura call UpsertConference successful on attempt 2'), expect.anything());
        });
        it('should fail after all retries for persistent 500 errors', async () => {
            mockedGot.post
                .mockRejectedValueOnce({
                response: { statusCode: 500 },
                message: 'Internal Server Error 1',
                isGotError: true,
            })
                .mockRejectedValueOnce({
                response: { statusCode: 500 },
                message: 'Internal Server Error 2',
                isGotError: true,
            })
                .mockRejectedValueOnce({
                response: { statusCode: 500 },
                message: 'Internal Server Error 3',
                isGotError: true,
            });
            await expect(upsertConference(mockConferenceInput)).rejects.toThrow('Internal Server Error 3');
            expect(mockedGot.post).toHaveBeenCalledTimes(3);
            expect(spiedLogger.warn).toHaveBeenCalledTimes(3);
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining("Failed Hasura operation 'UpsertConference' after 3 attempts."), expect.anything());
        });
        it('should fail immediately on a non-retryable 400 error', async () => {
            mockedGot.post.mockRejectedValueOnce({
                response: { statusCode: 400 },
                message: 'Bad Request',
                isGotError: true,
            });
            await expect(upsertConference(mockConferenceInput)).rejects.toThrow('Bad Request');
            expect(mockedGot.post).toHaveBeenCalledTimes(1);
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining('Non-retryable HTTP error 400 for UpsertConference. Aborting.'), expect.anything());
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining("Failed Hasura operation 'UpsertConference' after 1 attempts."), expect.anything());
        });
        it('should handle GraphQL errors in response (and retry by default)', async () => {
            mockedGot.post
                .mockResolvedValueOnce({
                json: () => Promise.resolve({ errors: mockGraphQLErrors }),
            })
                .mockResolvedValueOnce({
                json: () => Promise.resolve({
                    data: { insert_Conference_one: { id: 'conf1' } },
                }),
            });
            const result = await upsertConference(mockConferenceInput);
            expect(result?.id).toBe('conf1');
            expect(mockedGot.post).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining('Hasura call attempt 1 for UpsertConference failed'), expect.objectContaining({
                error: expect.stringContaining('GraphQL error in UpsertConference'),
            }));
        });
        it('should handle timeout (ETIMEDOUT)', async () => {
            mockedGot.post
                .mockRejectedValueOnce({
                code: 'ETIMEDOUT',
                message: 'Connection timed out',
                isGotError: true,
            })
                .mockResolvedValueOnce({
                json: () => Promise.resolve({
                    data: { insert_Conference_one: { id: 'conf1' } },
                }),
            });
            const result = await upsertConference(mockConferenceInput);
            expect(result?.id).toBe('conf1');
            expect(mockedGot.post).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining('Hasura call attempt 1 for UpsertConference failed'), expect.objectContaining({ code: 'ETIMEDOUT' }));
        });
    });
    // More tests would follow for refreshZoomToken, OpenAI calls, and Google API calls...
    // For brevity, I'll add a placeholder for one Zoom and one OpenAI function.
    describe('refreshZoomToken (axios resilience)', () => {
        const refreshToken = 'dummy-refresh-token';
        const mockZoomSuccess = {
            access_token: 'new_zoom_token',
            expires_in: 3600,
        };
        it('should succeed on first attempt', async () => {
            mockedAxios.mockResolvedValueOnce({ data: mockZoomSuccess });
            const result = await refreshZoomToken(refreshToken);
            expect(result).toEqual(mockZoomSuccess);
            expect(mockedAxios).toHaveBeenCalledTimes(1);
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Attempt 1 to refreshZoomToken'), expect.anything());
        });
        it('should retry on 503 and then succeed', async () => {
            mockedAxios
                .mockRejectedValueOnce({
                isAxiosError: true,
                response: { status: 503 },
            })
                .mockResolvedValueOnce({ data: mockZoomSuccess });
            const result = await refreshZoomToken(refreshToken);
            expect(result).toEqual(mockZoomSuccess);
            expect(mockedAxios).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining('Attempt 1 for refreshZoomToken failed'), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Waiting 1000ms before refreshZoomToken retry 2'), expect.anything());
        });
        it('should fail after all retries for persistent 500 errors', async () => {
            mockedAxios.mockRejectedValue({
                isAxiosError: true,
                response: { status: 500 },
            }); // Fails all 3 times
            await expect(refreshZoomToken(refreshToken)).rejects.toThrow();
            expect(mockedAxios).toHaveBeenCalledTimes(3);
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining('Failed refreshZoomToken after 3 attempts'), expect.anything());
        });
    });
    describe('convertEventTitleToOpenAIVector (OpenAI resilience)', () => {
        const title = 'Test Event Title';
        const mockEmbedding = [0.1, 0.2, 0.3];
        it('should succeed on first attempt', async () => {
            mockOpenAICreateEmbedding.mockResolvedValueOnce({
                data: [{ embedding: mockEmbedding }],
            });
            const result = await convertEventTitleToOpenAIVector(title);
            expect(result).toEqual(mockEmbedding);
            expect(mockOpenAICreateEmbedding).toHaveBeenCalledTimes(1);
        });
        it('should retry on API error then succeed', async () => {
            mockOpenAICreateEmbedding
                .mockRejectedValueOnce({
                response: { status: 500 },
                message: 'OpenAI server error',
            })
                .mockResolvedValueOnce({ data: [{ embedding: mockEmbedding }] });
            const result = await convertEventTitleToOpenAIVector(title);
            expect(result).toEqual(mockEmbedding);
            expect(mockOpenAICreateEmbedding).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining('Attempt 1 for OpenAI embedding'), expect.anything());
        });
    });
    // New tests for Google Calendar related functions
    describe('refreshGoogleToken (via resilientGotGoogleAuth)', () => {
        const refreshToken = 'google-refresh-token';
        const clientType = 'web';
        const mockGoogleSuccess = {
            access_token: 'new_google_token',
            expires_in: 3599,
            scope: 'test_scope',
            token_type: 'Bearer',
        };
        it('should succeed on the first attempt', async () => {
            mockedGot.post.mockResolvedValueOnce({
                json: () => Promise.resolve(mockGoogleSuccess),
            });
            const result = await require('./api-helper').refreshGoogleToken(refreshToken, clientType);
            expect(result).toEqual(mockGoogleSuccess);
            expect(mockedGot.post).toHaveBeenCalledTimes(1);
            expect(mockedGot.post).toHaveBeenCalledWith(expect.stringContaining('oauth2/v4/token'), // googleTokenUrl
            expect.objectContaining({
                form: expect.objectContaining({
                    refresh_token: refreshToken,
                    grant_type: 'refresh_token',
                }),
                timeout: { request: 10000 },
            }));
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Google Auth call attempt 1 for refreshGoogleToken (${clientType})`), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Google Auth call refreshGoogleToken (${clientType}) successful on attempt 1`), expect.anything());
        });
        it('should retry on 503 then succeed', async () => {
            mockedGot.post
                .mockRejectedValueOnce({
                response: { statusCode: 503 },
                message: 'Server Error',
                isGotError: true,
            })
                .mockResolvedValueOnce({
                json: () => Promise.resolve(mockGoogleSuccess),
            });
            await require('./api-helper').refreshGoogleToken(refreshToken, clientType);
            expect(mockedGot.post).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Google Auth call attempt 1 for refreshGoogleToken (${clientType}) failed`), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Waiting 1000ms before Google Auth retry 2 for refreshGoogleToken (${clientType})`), expect.anything());
        });
        it('should fail after all retries for persistent 500 error', async () => {
            mockedGot.post.mockRejectedValue({
                response: { statusCode: 500 },
                message: 'Internal Error',
                isGotError: true,
            });
            await expect(require('./api-helper').refreshGoogleToken(refreshToken, clientType)).rejects.toThrow('Internal Error');
            expect(mockedGot.post).toHaveBeenCalledTimes(3);
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining(`Failed Google Auth operation 'refreshGoogleToken' (${clientType}) after 3 attempts`), expect.anything());
        });
        it('should fail immediately on 400 error', async () => {
            mockedGot.post.mockRejectedValueOnce({
                response: { statusCode: 400, body: { error: 'invalid_grant' } },
                message: 'Bad Request',
                isGotError: true,
            });
            await expect(require('./api-helper').refreshGoogleToken(refreshToken, clientType)).rejects.toThrow('Bad Request');
            expect(mockedGot.post).toHaveBeenCalledTimes(1);
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining(`Non-retryable HTTP error 400 for refreshGoogleToken (${clientType}). Aborting.`), expect.anything());
        });
        it('should handle timeout (ETIMEDOUT)', async () => {
            mockedGot.post
                .mockRejectedValueOnce({
                code: 'ETIMEDOUT',
                message: 'Connection timed out',
                isGotError: true,
            })
                .mockResolvedValueOnce({
                json: () => Promise.resolve(mockGoogleSuccess),
            });
            await require('./api-helper').refreshGoogleToken(refreshToken, clientType);
            expect(mockedGot.post).toHaveBeenCalledTimes(2);
            expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Google Auth call attempt 1 for refreshGoogleToken (${clientType}) failed`), expect.objectContaining({ code: 'ETIMEDOUT' }));
        });
    });
    describe('getGoogleAPIToken', () => {
        const userId = 'test-g-user';
        const name = 'google_calendar'; // Matches constant
        const clientType = 'web';
        const mockValidIntegration = {
            id: 'integ-id',
            token: 'valid-token',
            expiresAt: dayjs().add(1, 'hour').toISOString(),
            refreshToken: 'valid-refresh-token',
            clientType: 'web',
        };
        const mockExpiredIntegration = {
            ...mockValidIntegration,
            token: 'expired-token',
            expiresAt: dayjs().subtract(1, 'hour').toISOString(),
        };
        const mockIntegrationNoToken = {
            ...mockValidIntegration,
            token: null, // or undefined
            expiresAt: dayjs().add(1, 'hour').toISOString(),
        };
        let getCalendarIntegrationByNameMock;
        let refreshGoogleTokenMock;
        let updateCalendarIntegrationMock;
        beforeEach(() => {
            // Need to spy on functions within the same module
            const apiHelperModule = require('./api-helper');
            getCalendarIntegrationByNameMock = jest.spyOn(apiHelperModule, 'getCalendarIntegrationByName');
            refreshGoogleTokenMock = jest.spyOn(apiHelperModule, 'refreshGoogleToken');
            updateCalendarIntegrationMock = jest.spyOn(apiHelperModule, 'updateCalendarIntegration');
        });
        afterEach(() => {
            getCalendarIntegrationByNameMock.mockRestore();
            refreshGoogleTokenMock.mockRestore();
            updateCalendarIntegrationMock.mockRestore();
        });
        it('should return existing valid token (cache hit)', async () => {
            getCalendarIntegrationByNameMock.mockResolvedValueOnce(mockValidIntegration);
            const token = await require('./api-helper').getGoogleAPIToken(userId, name, clientType);
            expect(token).toBe(mockValidIntegration.token);
            expect(getCalendarIntegrationByNameMock).toHaveBeenCalledWith(userId, name);
            expect(refreshGoogleTokenMock).not.toHaveBeenCalled();
            expect(spiedLogger.debug).toHaveBeenCalledWith(expect.stringContaining('Existing token is valid'), expect.anything());
        });
        it('should refresh token if expired', async () => {
            getCalendarIntegrationByNameMock.mockResolvedValueOnce(mockExpiredIntegration);
            refreshGoogleTokenMock.mockResolvedValueOnce({
                access_token: 'new-refreshed-token',
                expires_in: 3600,
            });
            updateCalendarIntegrationMock.mockResolvedValueOnce(undefined);
            const token = await require('./api-helper').getGoogleAPIToken(userId, name, clientType);
            expect(token).toBe('new-refreshed-token');
            expect(refreshGoogleTokenMock).toHaveBeenCalledWith(mockExpiredIntegration.refreshToken, clientType);
            expect(updateCalendarIntegrationMock).toHaveBeenCalledWith(mockExpiredIntegration.id, 'new-refreshed-token', 3600);
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Token expired or missing, attempting refresh'), expect.anything());
        });
        it('should refresh token if token is missing', async () => {
            getCalendarIntegrationByNameMock.mockResolvedValueOnce(mockIntegrationNoToken);
            refreshGoogleTokenMock.mockResolvedValueOnce({
                access_token: 'new-refreshed-token-no-original',
                expires_in: 3600,
            });
            updateCalendarIntegrationMock.mockResolvedValueOnce(undefined);
            const token = await require('./api-helper').getGoogleAPIToken(userId, name, clientType);
            expect(token).toBe('new-refreshed-token-no-original');
            expect(refreshGoogleTokenMock).toHaveBeenCalledWith(mockIntegrationNoToken.refreshToken, clientType);
        });
        it('should throw and attempt to disable integration if getCalendarIntegrationByName returns nothing', async () => {
            getCalendarIntegrationByNameMock.mockResolvedValueOnce(null); // No integration found
            await expect(require('./api-helper').getGoogleAPIToken(userId, name, clientType)).rejects.toThrow('Calendar integration or essential details not found');
            expect(updateCalendarIntegrationMock).not.toHaveBeenCalled(); // Should not be called if integrationId was never set
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining('Calendar integration or essential details not found'), expect.anything());
        });
        it('should throw and attempt to disable integration if refreshGoogleToken fails', async () => {
            getCalendarIntegrationByNameMock.mockResolvedValueOnce(mockExpiredIntegration);
            refreshGoogleTokenMock.mockRejectedValueOnce(new Error('Refresh failed'));
            updateCalendarIntegrationMock.mockResolvedValueOnce(undefined); // Mock for disabling
            await expect(require('./api-helper').getGoogleAPIToken(userId, name, clientType)).rejects.toThrow('Refresh failed');
            expect(updateCalendarIntegrationMock).toHaveBeenCalledWith(mockExpiredIntegration.id, undefined, undefined, false);
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining('Failed to get/refresh Google API token'), expect.anything());
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('Attempting to disable calendar integration due to error'), expect.anything());
        });
    });
    describe('getGlobalCalendar', () => {
        const userId = 'test-user-global-cal';
        const mockCalendarData = { id: 'global-cal-id', title: 'Global Primary' };
        // Mock resilientGotPostHasura for these tests
        let resilientGotPostHasuraMock;
        beforeEach(() => {
            const apiHelperModule = require('./api-helper');
            // Correctly mock the resilientGotPostHasura if it's not already mocked globally in a way that allows per-test config
            // For this example, assuming it's part of the original module and we can spy on it.
            // If it's tricky due to module loading, direct mocking like `got` might be necessary.
            // For now, let's assume it's available to be spied upon or we have a way to control its behavior.
            // This might require adjusting the global mock setup for './api-helper'
            // For simplicity in this snippet, we'll assume a direct mock path or that it's included in the spied module.
            // This is a common Jest challenge with module-internal function calls.
            // A robust way is to ensure `resilientGotPostHasura` is also exported and then re-mocked here,
            // or ensure the global mock of './api-helper' provides a jest.fn() for it.
            // Let's assume the global mock setup can be adjusted or resilientGotPostHasura is exported.
            // For now, we'll act as if we can mock its behavior for getGlobalCalendar.
            resilientGotPostHasuraMock = jest.spyOn(apiHelperModule, 'resilientGotPostHasura');
        });
        afterEach(() => {
            resilientGotPostHasuraMock.mockRestore();
        });
        it('should return calendar data on successful fetch', async () => {
            resilientGotPostHasuraMock.mockResolvedValueOnce({
                Calendar: [mockCalendarData],
            });
            const result = await require('./api-helper').getGlobalCalendar(userId);
            expect(result).toEqual(mockCalendarData);
            expect(resilientGotPostHasuraMock).toHaveBeenCalledWith('getGlobalCalendar', expect.any(String), { userId });
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('getGlobalCalendar successful for user'), expect.anything());
        });
        it('should return undefined if no global calendar is found', async () => {
            resilientGotPostHasuraMock.mockResolvedValueOnce({ Calendar: [] });
            const result = await require('./api-helper').getGlobalCalendar(userId);
            expect(result).toBeUndefined();
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('getGlobalCalendar: No global primary calendar found for user'), expect.anything());
        });
        it('should return undefined if Calendar field is missing (unexpected response)', async () => {
            resilientGotPostHasuraMock.mockResolvedValueOnce({}); // Missing Calendar field
            const result = await require('./api-helper').getGlobalCalendar(userId);
            expect(result).toBeUndefined();
            expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining('getGlobalCalendar: No global primary calendar found for user'), expect.anything());
        });
        it('should throw if resilientGotPostHasura throws', async () => {
            const error = new Error('Hasura fetch failed');
            resilientGotPostHasuraMock.mockRejectedValueOnce(error);
            await expect(require('./api-helper').getGlobalCalendar(userId)).rejects.toThrow('Hasura fetch failed');
            expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining('Error in getGlobalCalendar for user'), expect.objectContaining({ error: 'Hasura fetch failed' }));
        });
    });
    describe('Google Calendar API Event Functions (create, patch, delete)', () => {
        const userId = 'test-gcal-user';
        const calendarId = 'primary';
        const clientType = 'web';
        const mockGCalEventId = 'gcal-event-id-123';
        const mockOurEventId = `${mockGCalEventId}#${calendarId}`;
        let getGoogleAPITokenMock;
        const mockGoogleEventsInsert = jest.fn();
        const mockGoogleEventsPatch = jest.fn();
        const mockGoogleEventsDelete = jest.fn();
        beforeEach(() => {
            const apiHelperModule = require('./api-helper');
            getGoogleAPITokenMock = jest.spyOn(apiHelperModule, 'getGoogleAPIToken');
            // Mock googleapis
            const google = require('googleapis').google;
            google.calendar = jest.fn().mockReturnValue({
                events: {
                    insert: mockGoogleEventsInsert,
                    patch: mockGoogleEventsPatch,
                    delete: mockGoogleEventsDelete,
                },
            });
        });
        afterEach(() => {
            getGoogleAPITokenMock.mockRestore();
            mockGoogleEventsInsert.mockReset();
            mockGoogleEventsPatch.mockReset();
            mockGoogleEventsDelete.mockReset();
        });
        describe('createGoogleEvent', () => {
            const eventSummary = 'Test Event Creation';
            const eventData = {
                summary: eventSummary,
                startDateTime: dayjs().add(1, 'day').toISOString(),
                endDateTime: dayjs().add(1, 'day').add(1, 'hour').toISOString(),
                timezone: 'America/New_York',
            };
            it('should create event successfully on first attempt', async () => {
                getGoogleAPITokenMock.mockResolvedValueOnce('fake-google-api-token');
                mockGoogleEventsInsert.mockResolvedValueOnce({
                    data: { id: mockGCalEventId, summary: eventSummary },
                });
                const result = await require('./api-helper').createGoogleEvent(userId, calendarId, clientType, mockOurEventId, eventData.endDateTime, eventData.startDateTime, 1, undefined, undefined, undefined, undefined, eventSummary, undefined, eventData.timezone);
                expect(result.googleEventId).toBe(mockGCalEventId);
                expect(getGoogleAPITokenMock).toHaveBeenCalledWith(userId, expect.any(String), clientType);
                expect(mockGoogleEventsInsert).toHaveBeenCalledTimes(1);
                expect(mockGoogleEventsInsert).toHaveBeenCalledWith(expect.objectContaining({
                    calendarId,
                    requestBody: expect.objectContaining({ summary: eventSummary }),
                }), { timeout: 20000 });
                expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Google Calendar event created successfully on attempt 1 for user ${userId}`), expect.anything());
            });
            it('should retry on 500 error then succeed', async () => {
                getGoogleAPITokenMock.mockResolvedValue('fake-google-api-token');
                mockGoogleEventsInsert
                    .mockRejectedValueOnce({ code: 500, message: 'Server error' })
                    .mockResolvedValueOnce({
                    data: { id: mockGCalEventId, summary: eventSummary },
                });
                await require('./api-helper').createGoogleEvent(userId, calendarId, clientType, mockOurEventId, eventData.endDateTime, eventData.startDateTime, 1, undefined, undefined, undefined, undefined, eventSummary, undefined, eventData.timezone);
                expect(mockGoogleEventsInsert).toHaveBeenCalledTimes(2);
                expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Attempt 1 to create Google event for user ${userId} failed`), expect.anything());
                expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Retrying Google event creation for user ${userId}, attempt 2`), expect.anything());
            });
            it('should fail immediately on 401 error', async () => {
                getGoogleAPITokenMock.mockResolvedValue('fake-google-api-token');
                mockGoogleEventsInsert.mockRejectedValueOnce({
                    code: 401,
                    message: 'Unauthorized',
                });
                await expect(require('./api-helper').createGoogleEvent(userId, calendarId, clientType, mockOurEventId, eventData.endDateTime, eventData.startDateTime, 1, undefined, undefined, undefined, undefined, eventSummary, undefined, eventData.timezone)).rejects.toThrow('Unauthorized');
                expect(mockGoogleEventsInsert).toHaveBeenCalledTimes(1);
                expect(spiedLogger.error).toHaveBeenCalledWith(expect.stringContaining('Failed to create Google event for user'), expect.anything());
            });
            it('should fail if getGoogleAPIToken fails', async () => {
                getGoogleAPITokenMock.mockRejectedValueOnce(new Error('Token fetch failed'));
                await expect(require('./api-helper').createGoogleEvent(userId, calendarId, clientType, mockOurEventId, eventData.endDateTime, eventData.startDateTime, 1, undefined, undefined, undefined, undefined, eventSummary, undefined, eventData.timezone)).rejects.toThrow('Token fetch failed');
                expect(mockGoogleEventsInsert).not.toHaveBeenCalled();
            });
        });
        describe('patchGoogleEvent', () => {
            const eventSummaryUpdate = 'Updated Test Event';
            const patchData = { summary: eventSummaryUpdate };
            it('should patch event successfully', async () => {
                getGoogleAPITokenMock.mockResolvedValue('fake-google-api-token');
                mockGoogleEventsPatch.mockResolvedValueOnce({
                    data: { id: mockGCalEventId, summary: eventSummaryUpdate },
                });
                await require('./api-helper').patchGoogleEvent(userId, calendarId, mockGCalEventId, clientType, undefined, undefined, 1, undefined, undefined, undefined, undefined, undefined, eventSummaryUpdate);
                expect(mockGoogleEventsPatch).toHaveBeenCalledTimes(1);
                expect(mockGoogleEventsPatch).toHaveBeenCalledWith(expect.objectContaining({
                    calendarId,
                    eventId: mockGCalEventId,
                    requestBody: expect.objectContaining(patchData),
                }), { timeout: 20000 });
                expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Google Calendar event ${mockGCalEventId} patched successfully on attempt 1`), expect.anything());
            });
            it('should retry on 403 rateLimitExceeded then succeed', async () => {
                getGoogleAPITokenMock.mockResolvedValue('fake-google-api-token');
                mockGoogleEventsPatch
                    .mockRejectedValueOnce({
                    code: 403,
                    errors: [{ reason: 'rateLimitExceeded' }],
                    message: 'Rate limit',
                })
                    .mockResolvedValueOnce({
                    data: { id: mockGCalEventId, summary: eventSummaryUpdate },
                });
                await require('./api-helper').patchGoogleEvent(userId, calendarId, mockGCalEventId, clientType, undefined, undefined, 1, undefined, undefined, undefined, undefined, undefined, eventSummaryUpdate);
                expect(mockGoogleEventsPatch).toHaveBeenCalledTimes(2);
                expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Attempt 1 to patch Google event ${mockGCalEventId} for user ${userId} failed`), expect.anything());
            });
        });
        describe('deleteGoogleEvent', () => {
            it('should delete event successfully', async () => {
                getGoogleAPITokenMock.mockResolvedValue('fake-google-api-token');
                mockGoogleEventsDelete.mockResolvedValueOnce({}); // Delete often returns empty response
                await require('./api-helper').deleteGoogleEvent(userId, calendarId, mockGCalEventId, clientType);
                expect(mockGoogleEventsDelete).toHaveBeenCalledTimes(1);
                expect(mockGoogleEventsDelete).toHaveBeenCalledWith(expect.objectContaining({ calendarId, eventId: mockGCalEventId }), { timeout: 20000 });
                expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Google Calendar event ${mockGCalEventId} deleted successfully on attempt 1`), expect.anything());
            });
            it('should fail immediately on 404 (event not found) if not retried by policy (though current policy might retry 404 - verify)', async () => {
                // The current retry policy in deleteGoogleEvent *does* retry 404.
                // To test immediate bail on 404, the policy in the main code would need to change.
                // For now, let's test that it *does* retry 404 and then could succeed or fail based on mock.
                getGoogleAPITokenMock.mockResolvedValue('fake-google-api-token');
                mockGoogleEventsDelete
                    .mockRejectedValueOnce({ code: 404, message: 'Not Found' }) // First attempt fails with 404
                    .mockResolvedValueOnce({}); // Second attempt succeeds
                await require('./api-helper').deleteGoogleEvent(userId, calendarId, mockGCalEventId, clientType);
                expect(mockGoogleEventsDelete).toHaveBeenCalledTimes(2);
                expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Attempt 1 to delete Google event ${mockGCalEventId} for user ${userId} failed`), expect.anything());
                expect(spiedLogger.warn).toHaveBeenCalledWith(expect.stringContaining(`Retrying Google event delete for event ${mockGCalEventId}`), expect.anything());
                expect(spiedLogger.info).toHaveBeenCalledWith(expect.stringContaining(`Google Calendar event ${mockGCalEventId} deleted successfully on attempt 2`), expect.anything());
            });
        });
    });
    describe('LanceDB/OpenSearch and other utilities with logger changes', () => {
        // Mock lancedb_service functions if they are called directly by the functions under test
        // For now, assume they throw errors for testing error paths.
        const mockSearchEvents = jest.fn();
        const mockGetSearchClient = jest.fn(); // For putDataInTrainEventIndexInOpenSearch
        jest.mock('@functions/_utils/lancedb_service', () => ({
            ...jest.requireActual('@functions/_utils/lancedb_service'), // Keep original for non-mocked parts
            searchEvents: mockSearchEvents,
            // Add other lancedb_service mocks if needed by other functions
        }));
        // Mock for putDataInTrainEventIndexInOpenSearch's getSearchClient
        // This is more complex if getSearchClient is not easily mockable or has side effects.
        // For this example, we'll assume a simplified path or that it's handled if needed.
        beforeEach(() => {
            mockSearchEvents.mockReset();
            mockGetSearchClient.mockReset();
            // Reset any other mocks for this suite
        });
        describe('searchSingleEventByVectorLanceDb', () => {
            const userId = 'lance-user';
            const vector = [0.1, 0.2];
            it('should return null and log error when searchEvents throws', async () => {
                const error = new Error('LanceDB connection failed');
                mockSearchEvents.mockRejectedValueOnce(error);
                const result = await require('./api-helper').searchSingleEventByVectorLanceDb(userId, vector);
                expect(result).toBeNull(); // As per original logic, it catches and returns null
                expect(spiedLogger.error).toHaveBeenCalledWith('Error in searchSingleEventByVectorLanceDb', expect.objectContaining({ userId, error: error.message }));
            });
        });
        describe('extrapolateDateFromJSONData', () => {
            // This function is very complex. We'll do a basic test to ensure it runs and a debug log is hit.
            it('should run and make a debug log call', () => {
                const currentTime = '2023-10-26T10:00:00Z';
                const timezone = 'America/New_York';
                // Call with some basic data, actual result isn't the focus, just that it runs and logs.
                require('./api-helper').extrapolateDateFromJSONData(currentTime, timezone, '2023', '10', '26', null, 14, 30, null, null, null);
                expect(spiedLogger.debug).toHaveBeenCalledWith(expect.stringContaining('[extrapolateDateFromJSONData] Initial params:'), expect.anything());
            });
        });
        describe('generateJSONDataFromUserInput', () => {
            const userInput = 'schedule a meeting for tomorrow';
            const userCurrentTime = 'Monday, 2023-10-30T10:00:00-04:00';
            it('should return undefined and log error if OpenAI call fails', async () => {
                // Mock the internal callOpenAIWithMessageHistoryOnly to throw an error
                // This requires callOpenAIWithMessageHistoryOnly to be mockable, might need to adjust global mock setup
                const apiHelperModule = require('./api-helper');
                const callOpenAIMock = jest.spyOn(apiHelperModule, 'callOpenAIWithMessageHistoryOnly');
                callOpenAIMock.mockRejectedValueOnce(new Error('OpenAI API Error'));
                const result = await apiHelperModule.generateJSONDataFromUserInput(userInput, userCurrentTime);
                expect(result).toBeUndefined();
                expect(spiedLogger.error).toHaveBeenCalledWith('Unable to generate JSON data from user input', expect.objectContaining({ userInput, error: 'OpenAI API Error' }));
                callOpenAIMock.mockRestore();
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBpLWhlbHBlci50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYXBpLWhlbHBlci50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU87QUFDTCwrRUFBK0U7QUFDL0UsK0RBQStEO0FBQy9ELGdCQUFnQixFQUFFLGdEQUFnRDtBQUNsRSxnQkFBZ0IsRUFDaEIsK0JBQStCO0FBRS9CLCtDQUErQztFQUNoRCxNQUFNLGNBQWMsQ0FBQztBQUN0QixPQUFPLEdBQUcsTUFBTSxLQUFLLENBQUM7QUFDdEIsT0FBTyxLQUFLLE1BQU0sT0FBTyxDQUFDO0FBSzFCLGFBQWE7QUFDYixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ2pCLE1BQU0sU0FBUyxHQUFHLEdBQThCLENBQUM7QUFFakQsZUFBZTtBQUNmLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDbkIsTUFBTSxXQUFXLEdBQUcsS0FBa0MsQ0FBQztBQUV2RCxnQkFBZ0I7QUFDaEIsTUFBTSx5QkFBeUIsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDNUMsTUFBTSwrQkFBK0IsR0FBRyxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7QUFDbEQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsR0FBRyxFQUFFO0lBQ3ZCLE9BQU8sSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUM7UUFDekMsVUFBVSxFQUFFLEVBQUUsTUFBTSxFQUFFLHlCQUF5QixFQUFFO1FBQ2pELElBQUksRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLE1BQU0sRUFBRSwrQkFBK0IsRUFBRSxFQUFFO0tBQ25FLENBQUMsQ0FBQyxDQUFDO0FBQ04sQ0FBQyxDQUFDLENBQUM7QUFFSCxrQkFBa0I7QUFDbEIsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLEVBQUUsR0FBRyxFQUFFO0lBQzdCLE1BQU0s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Q0FBQyxDQUNsRSxDQUFDO2dCQUNGLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUMvQixDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIC8vIEltcG9ydCBmdW5jdGlvbnMgdG8gdGVzdCwgc3RhcnRpbmcgd2l0aCByZXNpbGllbnRHb3RQb3N0SGFzdXJhIChpZiBleHBvcnRlZClcbiAgLy8gb3IgZnVuY3Rpb25zIHRoYXQgdXNlIGl0LiBGb3Igbm93LCB3ZSdsbCB0ZXN0IGl0IGluZGlyZWN0bHkuXG4gIHVwc2VydENvbmZlcmVuY2UsIC8vIEV4YW1wbGUgZnVuY3Rpb24gdXNpbmcgcmVzaWxpZW50R290UG9zdEhhc3VyYVxuICByZWZyZXNoWm9vbVRva2VuLFxuICBjb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yLFxuICBjYWxsT3BlbkFJV2l0aE1lc3NhZ2VIaXN0b3J5T25seSxcbiAgLy8gV2UnbGwgbmVlZCB0byBpbXBvcnQgdGhlIGxvZ2dlciB0byBzcHkgb24gaXRcbn0gZnJvbSAnLi9hcGktaGVscGVyJztcbmltcG9ydCBnb3QgZnJvbSAnZ290JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgT3BlbkFJIGZyb20gJ29wZW5haSc7XG5pbXBvcnQgeyDgsrXgsrjgs43gsqTgs4Hgsqjgsr/gsrfgs43gsqBfVVJMLCBoYXN1cmFBZG1pblNlY3JldCB9IGZyb20gJy4vY29uc3RhbnRzJzsgLy8gVGhlc2UgYXJlIHRoZSBhY3R1YWwgbmFtZXMgZnJvbSB0aGUgZmlsZVxuaW1wb3J0IHsgY2hhdEFwaUhlbHBlckxvZ2dlciB9IGZyb20gJy4vYXBpLWhlbHBlcic7IC8vIEFzc3VtaW5nIGxvZ2dlciBpcyBleHBvcnRlZCBvciBhY2Nlc3NpYmxlIGZvciBzcHlpbmdcblxuLy8gTW9jayAnZ290J1xuamVzdC5tb2NrKCdnb3QnKTtcbmNvbnN0IG1vY2tlZEdvdCA9IGdvdCBhcyBqZXN0Lk1vY2tlZDx0eXBlb2YgZ290PjtcblxuLy8gTW9jayAnYXhpb3MnXG5qZXN0Lm1vY2soJ2F4aW9zJyk7XG5jb25zdCBtb2NrZWRBeGlvcyA9IGF4aW9zIGFzIGplc3QuTW9ja2VkPHR5cGVvZiBheGlvcz47XG5cbi8vIE1vY2sgJ29wZW5haSdcbmNvbnN0IG1vY2tPcGVuQUlDcmVhdGVFbWJlZGRpbmcgPSBqZXN0LmZuKCk7XG5jb25zdCBtb2NrT3BlbkFJQ2hhdENvbXBsZXRpb25zQ3JlYXRlID0gamVzdC5mbigpO1xuamVzdC5tb2NrKCdvcGVuYWknLCAoKSA9PiB7XG4gIHJldHVybiBqZXN0LmZuKCkubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+ICh7XG4gICAgZW1iZWRkaW5nczogeyBjcmVhdGU6IG1vY2tPcGVuQUlDcmVhdGVFbWJlZGRpbmcgfSxcbiAgICBjaGF0OiB7IGNvbXBsZXRpb25zOiB7IGNyZWF0ZTogbW9ja09wZW5BSUNoYXRDb21wbGV0aW9uc0NyZWF0ZSB9IH0sXG4gIH0pKTtcbn0pO1xuXG4vLyBNb2NrIHRoZSBsb2dnZXJcbmplc3QubW9jaygnLi9hcGktaGVscGVyJywgKCkgPT4ge1xuICBjb25zdCBvcmlnaW5hbE1vZHVsZSA9IGplc3QucmVxdWlyZUFjdHVhbCgnLi9hcGktaGVscGVyJyk7XG4gIGNvbnN0IHdpbnN0b24gPSByZXF1aXJlKCd3aW5zdG9uJyk7XG4gIGNvbnN0IG1vY2tMb2dnZXIgPSB7XG4gICAgaW5mbzogamVzdC5mbigpLFxuICAgIHdhcm46IGplc3QuZm4oKSxcbiAgICBlcnJvcjogamVzdC5mbigpLFxuICAgIGRlYnVnOiBqZXN0LmZuKCksXG4gIH07XG4gIC8vIENyZWF0ZSBhIHJlYWwgbG9nZ2VyIGJ1dCBzcHkgb24gaXRzIG1ldGhvZHNcbiAgY29uc3QgYWN0dWFsTG9nZ2VyID0gd2luc3Rvbi5jcmVhdGVMb2dnZXIoe1xuICAgIGxldmVsOiAnaW5mbycsXG4gICAgdHJhbnNwb3J0czogW25ldyB3aW5zdG9uLnRyYW5zcG9ydHMuQ29uc29sZSh7IHNpbGVudDogdHJ1ZSB9KV0sIC8vIFNpbGVudCBkdXJpbmcgdGVzdHNcbiAgfSk7XG4gIGZvciAoY29uc3QgbGV2ZWwgaW4gbW9ja0xvZ2dlcikge1xuICAgIGFjdHVhbExvZ2dlcltsZXZlbF0gPSBtb2NrTG9nZ2VyW2xldmVsXTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ub3JpZ2luYWxNb2R1bGUsXG4gICAgY2hhdEFwaUhlbHBlckxvZ2dlcjogYWN0dWFsTG9nZ2VyLCAvLyBQcm92aWRlIHRoZSBzcGllZC11cG9uIGxvZ2dlclxuICAgIC8vIHJlc2lsaWVudEdvdFBvc3RIYXN1cmE6IG9yaWdpbmFsTW9kdWxlLnJlc2lsaWVudEdvdFBvc3RIYXN1cmEsIC8vIEtlZXAgYWN0dWFsIGltcGxlbWVudGF0aW9uXG4gIH07XG59KTtcblxuZGVzY3JpYmUoJ19jaGF0L19saWJzL2FwaS1oZWxwZXIudHMnLCAoKSA9PiB7XG4gIGNvbnN0IHRlc3RVc2VySWQgPSAndGVzdC11c2VyLTEyMyc7XG4gIGNvbnN0IHRlc3RPcGVyYXRpb25OYW1lID0gJ1Rlc3RIYXN1cmFPcGVyYXRpb24nO1xuICBjb25zdCB0ZXN0UXVlcnkgPSAncXVlcnkgVGVzdCB7IHRlc3QgfSc7XG4gIGNvbnN0IHRlc3RWYXJpYWJsZXMgPSB7IGlkOiAxIH07XG4gIGNvbnN0IG1vY2tTdWNjZXNzRGF0YSA9IHsgdGVzdDogJ3N1Y2Nlc3MnIH07XG4gIGNvbnN0IG1vY2tHcmFwaFFMRXJyb3JzID0gW3sgbWVzc2FnZTogJ0dyYXBoUUwgZXJyb3IgZnJvbSBIYXN1cmEnIH1dO1xuXG4gIC8vIEFjY2VzcyB0aGUgc3BpZWQgbG9nZ2VyIG1ldGhvZHNcbiAgbGV0IHNwaWVkTG9nZ2VyOiBhbnk7XG4gIGJlZm9yZUFsbCgoKSA9PiB7XG4gICAgLy8gSW1wb3J0IGhlcmUgdG8gZ2V0IHRoZSB2ZXJzaW9uIHdpdGggdGhlIG1vY2tlZCBsb2dnZXJcbiAgICBjb25zdCBhcGlIZWxwZXIgPSByZXF1aXJlKCcuL2FwaS1oZWxwZXInKTtcbiAgICBzcGllZExvZ2dlciA9IGFwaUhlbHBlci5jaGF0QXBpSGVscGVyTG9nZ2VyO1xuICB9KTtcblxuICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTsgLy8gQ2xlYXJzIHNwaWVzIGFuZCBtb2Nrc1xuICAgIG1vY2tlZEdvdC5wb3N0Lm1vY2tSZXNldCgpOyAvLyBSZXNldCBzcGVjaWZpY2FsbHkgZm9yIGdvdFxuICAgIG1vY2tlZEF4aW9zLnBvc3QubW9ja1Jlc2V0KCk7XG4gICAgbW9ja2VkQXhpb3MubW9ja1Jlc2V0KCk7IC8vIEZvciBvdGhlciBtZXRob2RzIGxpa2UgYXhpb3Moe30pXG4gICAgbW9ja09wZW5BSUNyZWF0ZUVtYmVkZGluZy5tb2NrUmVzZXQoKTtcbiAgICBtb2NrT3BlbkFJQ2hhdENvbXBsZXRpb25zQ3JlYXRlLm1vY2tSZXNldCgpO1xuICB9KTtcblxuICBkZXNjcmliZSgncmVzaWxpZW50R290UG9zdEhhc3VyYSAodGVzdGVkIHZpYSBhIGNvbnN1bWVyIGxpa2UgdXBzZXJ0Q29uZmVyZW5jZSknLCAoKSA9PiB7XG4gICAgLy8gV2UgdGVzdCByZXNpbGllbnRHb3RQb3N0SGFzdXJhIGluZGlyZWN0bHkgYnkgY2FsbGluZyBhIGZ1bmN0aW9uIHRoYXQgdXNlcyBpdC5cbiAgICAvLyBMZXQncyB1c2UgdXBzZXJ0Q29uZmVyZW5jZSBhcyBhbiBleGFtcGxlLlxuICAgIGNvbnN0IG1vY2tDb25mZXJlbmNlSW5wdXQgPSB7IGlkOiAnY29uZjEnLCBuYW1lOiAnVGVzdCBDb25mZXJlbmNlJyB9IGFzIGFueTtcbiAgICBjb25zdCB1cHNlcnRDb25mZXJlbmNlUXVlcnkgPSBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnVXBzZXJ0Q29uZmVyZW5jZScpO1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZWVkIG9uIHRoZSBmaXJzdCBhdHRlbXB0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogKCkgPT5cbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiB7IGluc2VydF9Db25mZXJlbmNlX29uZTogeyBpZDogJ2NvbmYxJyB9IH0gfSksXG4gICAgICB9IGFzIGFueSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwc2VydENvbmZlcmVuY2UobW9ja0NvbmZlcmVuY2VJbnB1dCk7XG4gICAgICBleHBlY3QocmVzdWx0Py5pZCkudG9CZSgnY29uZjEnKTtcbiAgICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAg4KS14KS44KWN4KSk4KWB4LKo4LK/4LK34LON4LKgX1VSTCwgLy8gVXNpbmcgdGhlIGFjdHVhbCBjb25zdGFudCBuYW1lIGZyb20gdGhlIGZpbGUgZm9yIGhhc3VyYUdyYXBoVXJsXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBqc29uOiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IHF1ZXJ5OiB1cHNlcnRDb25mZXJlbmNlUXVlcnkgfSksXG4gICAgICAgICAgdGltZW91dDogeyByZXF1ZXN0OiAxMDAwMCB9LFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0hhc3VyYSBjYWxsIGF0dGVtcHQgMSBmb3IgVXBzZXJ0Q29uZmVyZW5jZScpLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ0hhc3VyYSBjYWxsIFVwc2VydENvbmZlcmVuY2Ugc3VjY2Vzc2Z1bCBvbiBhdHRlbXB0IDEnXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZWVkIG9uIHRoZSBzZWNvbmQgYXR0ZW1wdCBhZnRlciBhIDUwMyBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEdvdC5wb3N0XG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGU6IDUwMyB9LFxuICAgICAgICAgIG1lc3NhZ2U6ICdTZXJ2aWNlIFVuYXZhaWxhYmxlJyxcbiAgICAgICAgICBpc0dvdEVycm9yOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBqc29uOiAoKSA9PlxuICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgZGF0YTogeyBpbnNlcnRfQ29uZmVyZW5jZV9vbmU6IHsgaWQ6ICdjb25mMScgfSB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdXBzZXJ0Q29uZmVyZW5jZShtb2NrQ29uZmVyZW5jZUlucHV0KTtcbiAgICAgIGV4cGVjdChyZXN1bHQ/LmlkKS50b0JlKCdjb25mMScpO1xuICAgICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICdIYXN1cmEgY2FsbCBhdHRlbXB0IDEgZm9yIFVwc2VydENvbmZlcmVuY2UgZmFpbGVkJ1xuICAgICAgICApLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ1dhaXRpbmcgMTAwMG1zIGJlZm9yZSBIYXN1cmEgcmV0cnkgMSBmb3IgVXBzZXJ0Q29uZmVyZW5jZSdcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICdIYXN1cmEgY2FsbCBVcHNlcnRDb25mZXJlbmNlIHN1Y2Nlc3NmdWwgb24gYXR0ZW1wdCAyJ1xuICAgICAgICApLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBhZnRlciBhbGwgcmV0cmllcyBmb3IgcGVyc2lzdGVudCA1MDAgZXJyb3JzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3RcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZSh7XG4gICAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZTogNTAwIH0sXG4gICAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIFNlcnZlciBFcnJvciAxJyxcbiAgICAgICAgICBpc0dvdEVycm9yOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHtcbiAgICAgICAgICByZXNwb25zZTogeyBzdGF0dXNDb2RlOiA1MDAgfSxcbiAgICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgU2VydmVyIEVycm9yIDInLFxuICAgICAgICAgIGlzR290RXJyb3I6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGU6IDUwMCB9LFxuICAgICAgICAgIG1lc3NhZ2U6ICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3IgMycsXG4gICAgICAgICAgaXNHb3RFcnJvcjogdHJ1ZSxcbiAgICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdCh1cHNlcnRDb25mZXJlbmNlKG1vY2tDb25mZXJlbmNlSW5wdXQpKS5yZWplY3RzLnRvVGhyb3coXG4gICAgICAgICdJbnRlcm5hbCBTZXJ2ZXIgRXJyb3IgMydcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygzKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICBcIkZhaWxlZCBIYXN1cmEgb3BlcmF0aW9uICdVcHNlcnRDb25mZXJlbmNlJyBhZnRlciAzIGF0dGVtcHRzLlwiXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBmYWlsIGltbWVkaWF0ZWx5IG9uIGEgbm9uLXJldHJ5YWJsZSA0MDAgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICByZXNwb25zZTogeyBzdGF0dXNDb2RlOiA0MDAgfSxcbiAgICAgICAgbWVzc2FnZTogJ0JhZCBSZXF1ZXN0JyxcbiAgICAgICAgaXNHb3RFcnJvcjogdHJ1ZSxcbiAgICAgIH0pO1xuXG4gICAgICBhd2FpdCBleHBlY3QodXBzZXJ0Q29uZmVyZW5jZShtb2NrQ29uZmVyZW5jZUlucHV0KSkucmVqZWN0cy50b1Rocm93KFxuICAgICAgICAnQmFkIFJlcXVlc3QnXG4gICAgICApO1xuICAgICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICAnTm9uLXJldHJ5YWJsZSBIVFRQIGVycm9yIDQwMCBmb3IgVXBzZXJ0Q29uZmVyZW5jZS4gQWJvcnRpbmcuJ1xuICAgICAgICApLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgIFwiRmFpbGVkIEhhc3VyYSBvcGVyYXRpb24gJ1Vwc2VydENvbmZlcmVuY2UnIGFmdGVyIDEgYXR0ZW1wdHMuXCJcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBHcmFwaFFMIGVycm9ycyBpbiByZXNwb25zZSAoYW5kIHJldHJ5IGJ5IGRlZmF1bHQpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3RcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKHsgZXJyb3JzOiBtb2NrR3JhcGhRTEVycm9ycyB9KSxcbiAgICAgICAgfSBhcyBhbnkpXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGpzb246ICgpID0+XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhOiB7IGluc2VydF9Db25mZXJlbmNlX29uZTogeyBpZDogJ2NvbmYxJyB9IH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cHNlcnRDb25mZXJlbmNlKG1vY2tDb25mZXJlbmNlSW5wdXQpO1xuICAgICAgZXhwZWN0KHJlc3VsdD8uaWQpLnRvQmUoJ2NvbmYxJyk7XG4gICAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ0hhc3VyYSBjYWxsIGF0dGVtcHQgMSBmb3IgVXBzZXJ0Q29uZmVyZW5jZSBmYWlsZWQnXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICBlcnJvcjogZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ0dyYXBoUUwgZXJyb3IgaW4gVXBzZXJ0Q29uZmVyZW5jZScpLFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpbWVvdXQgKEVUSU1FRE9VVCknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdFxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBjb2RlOiAnRVRJTUVET1VUJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiB0aW1lZCBvdXQnLFxuICAgICAgICAgIGlzR290RXJyb3I6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGpzb246ICgpID0+XG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgICBkYXRhOiB7IGluc2VydF9Db25mZXJlbmNlX29uZTogeyBpZDogJ2NvbmYxJyB9IH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB1cHNlcnRDb25mZXJlbmNlKG1vY2tDb25mZXJlbmNlSW5wdXQpO1xuICAgICAgZXhwZWN0KHJlc3VsdD8uaWQpLnRvQmUoJ2NvbmYxJyk7XG4gICAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ0hhc3VyYSBjYWxsIGF0dGVtcHQgMSBmb3IgVXBzZXJ0Q29uZmVyZW5jZSBmYWlsZWQnXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgY29kZTogJ0VUSU1FRE9VVCcgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIE1vcmUgdGVzdHMgd291bGQgZm9sbG93IGZvciByZWZyZXNoWm9vbVRva2VuLCBPcGVuQUkgY2FsbHMsIGFuZCBHb29nbGUgQVBJIGNhbGxzLi4uXG4gIC8vIEZvciBicmV2aXR5LCBJJ2xsIGFkZCBhIHBsYWNlaG9sZGVyIGZvciBvbmUgWm9vbSBhbmQgb25lIE9wZW5BSSBmdW5jdGlvbi5cblxuICBkZXNjcmliZSgncmVmcmVzaFpvb21Ub2tlbiAoYXhpb3MgcmVzaWxpZW5jZSknLCAoKSA9PiB7XG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gJ2R1bW15LXJlZnJlc2gtdG9rZW4nO1xuICAgIGNvbnN0IG1vY2tab29tU3VjY2VzcyA9IHtcbiAgICAgIGFjY2Vzc190b2tlbjogJ25ld196b29tX3Rva2VuJyxcbiAgICAgIGV4cGlyZXNfaW46IDM2MDAsXG4gICAgfTtcblxuICAgIGl0KCdzaG91bGQgc3VjY2VlZCBvbiBmaXJzdCBhdHRlbXB0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkQXhpb3MubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgZGF0YTogbW9ja1pvb21TdWNjZXNzIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFpvb21Ub2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrWm9vbVN1Y2Nlc3MpO1xuICAgICAgZXhwZWN0KG1vY2tlZEF4aW9zKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdBdHRlbXB0IDEgdG8gcmVmcmVzaFpvb21Ub2tlbicpLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0cnkgb24gNTAzIGFuZCB0aGVuIHN1Y2NlZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRBeGlvc1xuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBpc0F4aW9zRXJyb3I6IHRydWUsXG4gICAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzOiA1MDMgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IGRhdGE6IG1vY2tab29tU3VjY2VzcyB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVmcmVzaFpvb21Ub2tlbihyZWZyZXNoVG9rZW4pO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrWm9vbVN1Y2Nlc3MpO1xuICAgICAgZXhwZWN0KG1vY2tlZEF4aW9zKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdBdHRlbXB0IDEgZm9yIHJlZnJlc2hab29tVG9rZW4gZmFpbGVkJyksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICAnV2FpdGluZyAxMDAwbXMgYmVmb3JlIHJlZnJlc2hab29tVG9rZW4gcmV0cnkgMidcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhaWwgYWZ0ZXIgYWxsIHJldHJpZXMgZm9yIHBlcnNpc3RlbnQgNTAwIGVycm9ycycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tlZEF4aW9zLm1vY2tSZWplY3RlZFZhbHVlKHtcbiAgICAgICAgaXNBeGlvc0Vycm9yOiB0cnVlLFxuICAgICAgICByZXNwb25zZTogeyBzdGF0dXM6IDUwMCB9LFxuICAgICAgfSk7IC8vIEZhaWxzIGFsbCAzIHRpbWVzXG5cbiAgICAgIGF3YWl0IGV4cGVjdChyZWZyZXNoWm9vbVRva2VuKHJlZnJlc2hUb2tlbikpLnJlamVjdHMudG9UaHJvdygpO1xuICAgICAgZXhwZWN0KG1vY2tlZEF4aW9zKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnRmFpbGVkIHJlZnJlc2hab29tVG9rZW4gYWZ0ZXIgMyBhdHRlbXB0cycpLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2NvbnZlcnRFdmVudFRpdGxlVG9PcGVuQUlWZWN0b3IgKE9wZW5BSSByZXNpbGllbmNlKScsICgpID0+IHtcbiAgICBjb25zdCB0aXRsZSA9ICdUZXN0IEV2ZW50IFRpdGxlJztcbiAgICBjb25zdCBtb2NrRW1iZWRkaW5nID0gWzAuMSwgMC4yLCAwLjNdO1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZWVkIG9uIGZpcnN0IGF0dGVtcHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrT3BlbkFJQ3JlYXRlRW1iZWRkaW5nLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIGRhdGE6IFt7IGVtYmVkZGluZzogbW9ja0VtYmVkZGluZyB9XSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3Rvcih0aXRsZSk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tFbWJlZGRpbmcpO1xuICAgICAgZXhwZWN0KG1vY2tPcGVuQUlDcmVhdGVFbWJlZGRpbmcpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygxKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0cnkgb24gQVBJIGVycm9yIHRoZW4gc3VjY2VlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tPcGVuQUlDcmVhdGVFbWJlZGRpbmdcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZSh7XG4gICAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzOiA1MDAgfSxcbiAgICAgICAgICBtZXNzYWdlOiAnT3BlbkFJIHNlcnZlciBlcnJvcicsXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyBkYXRhOiBbeyBlbWJlZGRpbmc6IG1vY2tFbWJlZGRpbmcgfV0gfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnZlcnRFdmVudFRpdGxlVG9PcGVuQUlWZWN0b3IodGl0bGUpO1xuICAgICAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChtb2NrRW1iZWRkaW5nKTtcbiAgICAgIGV4cGVjdChtb2NrT3BlbkFJQ3JlYXRlRW1iZWRkaW5nKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdBdHRlbXB0IDEgZm9yIE9wZW5BSSBlbWJlZGRpbmcnKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIE5ldyB0ZXN0cyBmb3IgR29vZ2xlIENhbGVuZGFyIHJlbGF0ZWQgZnVuY3Rpb25zXG4gIGRlc2NyaWJlKCdyZWZyZXNoR29vZ2xlVG9rZW4gKHZpYSByZXNpbGllbnRHb3RHb29nbGVBdXRoKScsICgpID0+IHtcbiAgICBjb25zdCByZWZyZXNoVG9rZW4gPSAnZ29vZ2xlLXJlZnJlc2gtdG9rZW4nO1xuICAgIGNvbnN0IGNsaWVudFR5cGUgPSAnd2ViJztcbiAgICBjb25zdCBtb2NrR29vZ2xlU3VjY2VzcyA9IHtcbiAgICAgIGFjY2Vzc190b2tlbjogJ25ld19nb29nbGVfdG9rZW4nLFxuICAgICAgZXhwaXJlc19pbjogMzU5OSxcbiAgICAgIHNjb3BlOiAndGVzdF9zY29wZScsXG4gICAgICB0b2tlbl90eXBlOiAnQmVhcmVyJyxcbiAgICB9O1xuXG4gICAgaXQoJ3Nob3VsZCBzdWNjZWVkIG9uIHRoZSBmaXJzdCBhdHRlbXB0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3QubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tHb29nbGVTdWNjZXNzKSxcbiAgICAgIH0gYXMgYW55KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWlyZSgnLi9hcGktaGVscGVyJykucmVmcmVzaEdvb2dsZVRva2VuKFxuICAgICAgICByZWZyZXNoVG9rZW4sXG4gICAgICAgIGNsaWVudFR5cGVcbiAgICAgICk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKG1vY2tHb29nbGVTdWNjZXNzKTtcbiAgICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoJ29hdXRoMi92NC90b2tlbicpLCAvLyBnb29nbGVUb2tlblVybFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgICAgZm9ybTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgcmVmcmVzaF90b2tlbjogcmVmcmVzaFRva2VuLFxuICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRpbWVvdXQ6IHsgcmVxdWVzdDogMTAwMDAgfSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgIGBHb29nbGUgQXV0aCBjYWxsIGF0dGVtcHQgMSBmb3IgcmVmcmVzaEdvb2dsZVRva2VuICgke2NsaWVudFR5cGV9KWBcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgIGBHb29nbGUgQXV0aCBjYWxsIHJlZnJlc2hHb29nbGVUb2tlbiAoJHtjbGllbnRUeXBlfSkgc3VjY2Vzc2Z1bCBvbiBhdHRlbXB0IDFgXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSBvbiA1MDMgdGhlbiBzdWNjZWVkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3RcbiAgICAgICAgLm1vY2tSZWplY3RlZFZhbHVlT25jZSh7XG4gICAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZTogNTAzIH0sXG4gICAgICAgICAgbWVzc2FnZTogJ1NlcnZlciBFcnJvcicsXG4gICAgICAgICAgaXNHb3RFcnJvcjogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgICAgLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgICAganNvbjogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKG1vY2tHb29nbGVTdWNjZXNzKSxcbiAgICAgICAgfSBhcyBhbnkpO1xuXG4gICAgICBhd2FpdCByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5yZWZyZXNoR29vZ2xlVG9rZW4oXG4gICAgICAgIHJlZnJlc2hUb2tlbixcbiAgICAgICAgY2xpZW50VHlwZVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChtb2NrZWRHb3QucG9zdCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICBgR29vZ2xlIEF1dGggY2FsbCBhdHRlbXB0IDEgZm9yIHJlZnJlc2hHb29nbGVUb2tlbiAoJHtjbGllbnRUeXBlfSkgZmFpbGVkYFxuICAgICAgICApLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgYFdhaXRpbmcgMTAwMG1zIGJlZm9yZSBHb29nbGUgQXV0aCByZXRyeSAyIGZvciByZWZyZXNoR29vZ2xlVG9rZW4gKCR7Y2xpZW50VHlwZX0pYFxuICAgICAgICApLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgZmFpbCBhZnRlciBhbGwgcmV0cmllcyBmb3IgcGVyc2lzdGVudCA1MDAgZXJyb3InLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdC5tb2NrUmVqZWN0ZWRWYWx1ZSh7XG4gICAgICAgIHJlc3BvbnNlOiB7IHN0YXR1c0NvZGU6IDUwMCB9LFxuICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgRXJyb3InLFxuICAgICAgICBpc0dvdEVycm9yOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgcmVxdWlyZSgnLi9hcGktaGVscGVyJykucmVmcmVzaEdvb2dsZVRva2VuKHJlZnJlc2hUb2tlbiwgY2xpZW50VHlwZSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdJbnRlcm5hbCBFcnJvcicpO1xuICAgICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMyk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICBgRmFpbGVkIEdvb2dsZSBBdXRoIG9wZXJhdGlvbiAncmVmcmVzaEdvb2dsZVRva2VuJyAoJHtjbGllbnRUeXBlfSkgYWZ0ZXIgMyBhdHRlbXB0c2BcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGZhaWwgaW1tZWRpYXRlbHkgb24gNDAwIGVycm9yJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja2VkR290LnBvc3QubW9ja1JlamVjdGVkVmFsdWVPbmNlKHtcbiAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZTogNDAwLCBib2R5OiB7IGVycm9yOiAnaW52YWxpZF9ncmFudCcgfSB9LFxuICAgICAgICBtZXNzYWdlOiAnQmFkIFJlcXVlc3QnLFxuICAgICAgICBpc0dvdEVycm9yOiB0cnVlLFxuICAgICAgfSk7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgcmVxdWlyZSgnLi9hcGktaGVscGVyJykucmVmcmVzaEdvb2dsZVRva2VuKHJlZnJlc2hUb2tlbiwgY2xpZW50VHlwZSlcbiAgICAgICkucmVqZWN0cy50b1Rocm93KCdCYWQgUmVxdWVzdCcpO1xuICAgICAgZXhwZWN0KG1vY2tlZEdvdC5wb3N0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICBgTm9uLXJldHJ5YWJsZSBIVFRQIGVycm9yIDQwMCBmb3IgcmVmcmVzaEdvb2dsZVRva2VuICgke2NsaWVudFR5cGV9KS4gQWJvcnRpbmcuYFxuICAgICAgICApLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRpbWVvdXQgKEVUSU1FRE9VVCknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrZWRHb3QucG9zdFxuICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBjb2RlOiAnRVRJTUVET1VUJyxcbiAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiB0aW1lZCBvdXQnLFxuICAgICAgICAgIGlzR290RXJyb3I6IHRydWUsXG4gICAgICAgIH0pXG4gICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGpzb246ICgpID0+IFByb21pc2UucmVzb2x2ZShtb2NrR29vZ2xlU3VjY2VzcyksXG4gICAgICAgIH0gYXMgYW55KTtcblxuICAgICAgYXdhaXQgcmVxdWlyZSgnLi9hcGktaGVscGVyJykucmVmcmVzaEdvb2dsZVRva2VuKFxuICAgICAgICByZWZyZXNoVG9rZW4sXG4gICAgICAgIGNsaWVudFR5cGVcbiAgICAgICk7XG4gICAgICBleHBlY3QobW9ja2VkR290LnBvc3QpLnRvSGF2ZUJlZW5DYWxsZWRUaW1lcygyKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgYEdvb2dsZSBBdXRoIGNhbGwgYXR0ZW1wdCAxIGZvciByZWZyZXNoR29vZ2xlVG9rZW4gKCR7Y2xpZW50VHlwZX0pIGZhaWxlZGBcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoeyBjb2RlOiAnRVRJTUVET1VUJyB9KVxuICAgICAgKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2dldEdvb2dsZUFQSVRva2VuJywgKCkgPT4ge1xuICAgIGNvbnN0IHVzZXJJZCA9ICd0ZXN0LWctdXNlcic7XG4gICAgY29uc3QgbmFtZSA9ICdnb29nbGVfY2FsZW5kYXInOyAvLyBNYXRjaGVzIGNvbnN0YW50XG4gICAgY29uc3QgY2xpZW50VHlwZSA9ICd3ZWInO1xuICAgIGNvbnN0IG1vY2tWYWxpZEludGVncmF0aW9uID0ge1xuICAgICAgaWQ6ICdpbnRlZy1pZCcsXG4gICAgICB0b2tlbjogJ3ZhbGlkLXRva2VuJyxcbiAgICAgIGV4cGlyZXNBdDogZGF5anMoKS5hZGQoMSwgJ2hvdXInKS50b0lTT1N0cmluZygpLFxuICAgICAgcmVmcmVzaFRva2VuOiAndmFsaWQtcmVmcmVzaC10b2tlbicsXG4gICAgICBjbGllbnRUeXBlOiAnd2ViJyxcbiAgICB9O1xuICAgIGNvbnN0IG1vY2tFeHBpcmVkSW50ZWdyYXRpb24gPSB7XG4gICAgICAuLi5tb2NrVmFsaWRJbnRlZ3JhdGlvbixcbiAgICAgIHRva2VuOiAnZXhwaXJlZC10b2tlbicsXG4gICAgICBleHBpcmVzQXQ6IGRheWpzKCkuc3VidHJhY3QoMSwgJ2hvdXInKS50b0lTT1N0cmluZygpLFxuICAgIH07XG4gICAgY29uc3QgbW9ja0ludGVncmF0aW9uTm9Ub2tlbiA9IHtcbiAgICAgIC4uLm1vY2tWYWxpZEludGVncmF0aW9uLFxuICAgICAgdG9rZW46IG51bGwsIC8vIG9yIHVuZGVmaW5lZFxuICAgICAgZXhwaXJlc0F0OiBkYXlqcygpLmFkZCgxLCAnaG91cicpLnRvSVNPU3RyaW5nKCksXG4gICAgfTtcblxuICAgIGxldCBnZXRDYWxlbmRhckludGVncmF0aW9uQnlOYW1lTW9jazogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgcmVmcmVzaEdvb2dsZVRva2VuTW9jazogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBsZXQgdXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbk1vY2s6IGplc3QuU3B5SW5zdGFuY2U7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIC8vIE5lZWQgdG8gc3B5IG9uIGZ1bmN0aW9ucyB3aXRoaW4gdGhlIHNhbWUgbW9kdWxlXG4gICAgICBjb25zdCBhcGlIZWxwZXJNb2R1bGUgPSByZXF1aXJlKCcuL2FwaS1oZWxwZXInKTtcbiAgICAgIGdldENhbGVuZGFySW50ZWdyYXRpb25CeU5hbWVNb2NrID0gamVzdC5zcHlPbihcbiAgICAgICAgYXBpSGVscGVyTW9kdWxlLFxuICAgICAgICAnZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbkJ5TmFtZSdcbiAgICAgICk7XG4gICAgICByZWZyZXNoR29vZ2xlVG9rZW5Nb2NrID0gamVzdC5zcHlPbihcbiAgICAgICAgYXBpSGVscGVyTW9kdWxlLFxuICAgICAgICAncmVmcmVzaEdvb2dsZVRva2VuJ1xuICAgICAgKTtcbiAgICAgIHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb25Nb2NrID0gamVzdC5zcHlPbihcbiAgICAgICAgYXBpSGVscGVyTW9kdWxlLFxuICAgICAgICAndXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbidcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbkJ5TmFtZU1vY2subW9ja1Jlc3RvcmUoKTtcbiAgICAgIHJlZnJlc2hHb29nbGVUb2tlbk1vY2subW9ja1Jlc3RvcmUoKTtcbiAgICAgIHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb25Nb2NrLm1vY2tSZXN0b3JlKCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBleGlzdGluZyB2YWxpZCB0b2tlbiAoY2FjaGUgaGl0KScsIGFzeW5jICgpID0+IHtcbiAgICAgIGdldENhbGVuZGFySW50ZWdyYXRpb25CeU5hbWVNb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZShcbiAgICAgICAgbW9ja1ZhbGlkSW50ZWdyYXRpb25cbiAgICAgICk7XG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmdldEdvb2dsZUFQSVRva2VuKFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNsaWVudFR5cGVcbiAgICAgICk7XG4gICAgICBleHBlY3QodG9rZW4pLnRvQmUobW9ja1ZhbGlkSW50ZWdyYXRpb24udG9rZW4pO1xuICAgICAgZXhwZWN0KGdldENhbGVuZGFySW50ZWdyYXRpb25CeU5hbWVNb2NrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgdXNlcklkLFxuICAgICAgICBuYW1lXG4gICAgICApO1xuICAgICAgZXhwZWN0KHJlZnJlc2hHb29nbGVUb2tlbk1vY2spLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZygnRXhpc3RpbmcgdG9rZW4gaXMgdmFsaWQnKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJlZnJlc2ggdG9rZW4gaWYgZXhwaXJlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGdldENhbGVuZGFySW50ZWdyYXRpb25CeU5hbWVNb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZShcbiAgICAgICAgbW9ja0V4cGlyZWRJbnRlZ3JhdGlvblxuICAgICAgKTtcbiAgICAgIHJlZnJlc2hHb29nbGVUb2tlbk1vY2subW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiAnbmV3LXJlZnJlc2hlZC10b2tlbicsXG4gICAgICAgIGV4cGlyZXNfaW46IDM2MDAsXG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb25Nb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh1bmRlZmluZWQpO1xuXG4gICAgICBjb25zdCB0b2tlbiA9IGF3YWl0IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmdldEdvb2dsZUFQSVRva2VuKFxuICAgICAgICB1c2VySWQsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNsaWVudFR5cGVcbiAgICAgICk7XG4gICAgICBleHBlY3QodG9rZW4pLnRvQmUoJ25ldy1yZWZyZXNoZWQtdG9rZW4nKTtcbiAgICAgIGV4cGVjdChyZWZyZXNoR29vZ2xlVG9rZW5Nb2NrKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgbW9ja0V4cGlyZWRJbnRlZ3JhdGlvbi5yZWZyZXNoVG9rZW4sXG4gICAgICAgIGNsaWVudFR5cGVcbiAgICAgICk7XG4gICAgICBleHBlY3QodXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbk1vY2spLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrRXhwaXJlZEludGVncmF0aW9uLmlkLFxuICAgICAgICAnbmV3LXJlZnJlc2hlZC10b2tlbicsXG4gICAgICAgIDM2MDBcbiAgICAgICk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdUb2tlbiBleHBpcmVkIG9yIG1pc3NpbmcsIGF0dGVtcHRpbmcgcmVmcmVzaCcpLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmVmcmVzaCB0b2tlbiBpZiB0b2tlbiBpcyBtaXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbkJ5TmFtZU1vY2subW9ja1Jlc29sdmVkVmFsdWVPbmNlKFxuICAgICAgICBtb2NrSW50ZWdyYXRpb25Ob1Rva2VuXG4gICAgICApO1xuICAgICAgcmVmcmVzaEdvb2dsZVRva2VuTW9jay5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBhY2Nlc3NfdG9rZW46ICduZXctcmVmcmVzaGVkLXRva2VuLW5vLW9yaWdpbmFsJyxcbiAgICAgICAgZXhwaXJlc19pbjogMzYwMCxcbiAgICAgIH0pO1xuICAgICAgdXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbk1vY2subW9ja1Jlc29sdmVkVmFsdWVPbmNlKHVuZGVmaW5lZCk7XG5cbiAgICAgIGNvbnN0IHRva2VuID0gYXdhaXQgcmVxdWlyZSgnLi9hcGktaGVscGVyJykuZ2V0R29vZ2xlQVBJVG9rZW4oXG4gICAgICAgIHVzZXJJZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2xpZW50VHlwZVxuICAgICAgKTtcbiAgICAgIGV4cGVjdCh0b2tlbikudG9CZSgnbmV3LXJlZnJlc2hlZC10b2tlbi1uby1vcmlnaW5hbCcpO1xuICAgICAgZXhwZWN0KHJlZnJlc2hHb29nbGVUb2tlbk1vY2spLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBtb2NrSW50ZWdyYXRpb25Ob1Rva2VuLnJlZnJlc2hUb2tlbixcbiAgICAgICAgY2xpZW50VHlwZVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgdGhyb3cgYW5kIGF0dGVtcHQgdG8gZGlzYWJsZSBpbnRlZ3JhdGlvbiBpZiBnZXRDYWxlbmRhckludGVncmF0aW9uQnlOYW1lIHJldHVybnMgbm90aGluZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGdldENhbGVuZGFySW50ZWdyYXRpb25CeU5hbWVNb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZShudWxsKTsgLy8gTm8gaW50ZWdyYXRpb24gZm91bmRcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5nZXRHb29nbGVBUElUb2tlbih1c2VySWQsIG5hbWUsIGNsaWVudFR5cGUpXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnQ2FsZW5kYXIgaW50ZWdyYXRpb24gb3IgZXNzZW50aWFsIGRldGFpbHMgbm90IGZvdW5kJyk7XG4gICAgICBleHBlY3QodXBkYXRlQ2FsZW5kYXJJbnRlZ3JhdGlvbk1vY2spLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7IC8vIFNob3VsZCBub3QgYmUgY2FsbGVkIGlmIGludGVncmF0aW9uSWQgd2FzIG5ldmVyIHNldFxuICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ0NhbGVuZGFyIGludGVncmF0aW9uIG9yIGVzc2VudGlhbCBkZXRhaWxzIG5vdCBmb3VuZCdcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGFuZCBhdHRlbXB0IHRvIGRpc2FibGUgaW50ZWdyYXRpb24gaWYgcmVmcmVzaEdvb2dsZVRva2VuIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgZ2V0Q2FsZW5kYXJJbnRlZ3JhdGlvbkJ5TmFtZU1vY2subW9ja1Jlc29sdmVkVmFsdWVPbmNlKFxuICAgICAgICBtb2NrRXhwaXJlZEludGVncmF0aW9uXG4gICAgICApO1xuICAgICAgcmVmcmVzaEdvb2dsZVRva2VuTW9jay5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdSZWZyZXNoIGZhaWxlZCcpKTtcbiAgICAgIHVwZGF0ZUNhbGVuZGFySW50ZWdyYXRpb25Nb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh1bmRlZmluZWQpOyAvLyBNb2NrIGZvciBkaXNhYmxpbmdcblxuICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5nZXRHb29nbGVBUElUb2tlbih1c2VySWQsIG5hbWUsIGNsaWVudFR5cGUpXG4gICAgICApLnJlamVjdHMudG9UaHJvdygnUmVmcmVzaCBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdCh1cGRhdGVDYWxlbmRhckludGVncmF0aW9uTW9jaykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIG1vY2tFeHBpcmVkSW50ZWdyYXRpb24uaWQsXG4gICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdGYWlsZWQgdG8gZ2V0L3JlZnJlc2ggR29vZ2xlIEFQSSB0b2tlbicpLFxuICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ0F0dGVtcHRpbmcgdG8gZGlzYWJsZSBjYWxlbmRhciBpbnRlZ3JhdGlvbiBkdWUgdG8gZXJyb3InXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0R2xvYmFsQ2FsZW5kYXInLCAoKSA9PiB7XG4gICAgY29uc3QgdXNlcklkID0gJ3Rlc3QtdXNlci1nbG9iYWwtY2FsJztcbiAgICBjb25zdCBtb2NrQ2FsZW5kYXJEYXRhID0geyBpZDogJ2dsb2JhbC1jYWwtaWQnLCB0aXRsZTogJ0dsb2JhbCBQcmltYXJ5JyB9O1xuXG4gICAgLy8gTW9jayByZXNpbGllbnRHb3RQb3N0SGFzdXJhIGZvciB0aGVzZSB0ZXN0c1xuICAgIGxldCByZXNpbGllbnRHb3RQb3N0SGFzdXJhTW9jazogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGFwaUhlbHBlck1vZHVsZSA9IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpO1xuICAgICAgLy8gQ29ycmVjdGx5IG1vY2sgdGhlIHJlc2lsaWVudEdvdFBvc3RIYXN1cmEgaWYgaXQncyBub3QgYWxyZWFkeSBtb2NrZWQgZ2xvYmFsbHkgaW4gYSB3YXkgdGhhdCBhbGxvd3MgcGVyLXRlc3QgY29uZmlnXG4gICAgICAvLyBGb3IgdGhpcyBleGFtcGxlLCBhc3N1bWluZyBpdCdzIHBhcnQgb2YgdGhlIG9yaWdpbmFsIG1vZHVsZSBhbmQgd2UgY2FuIHNweSBvbiBpdC5cbiAgICAgIC8vIElmIGl0J3MgdHJpY2t5IGR1ZSB0byBtb2R1bGUgbG9hZGluZywgZGlyZWN0IG1vY2tpbmcgbGlrZSBgZ290YCBtaWdodCBiZSBuZWNlc3NhcnkuXG4gICAgICAvLyBGb3Igbm93LCBsZXQncyBhc3N1bWUgaXQncyBhdmFpbGFibGUgdG8gYmUgc3BpZWQgdXBvbiBvciB3ZSBoYXZlIGEgd2F5IHRvIGNvbnRyb2wgaXRzIGJlaGF2aW9yLlxuICAgICAgLy8gVGhpcyBtaWdodCByZXF1aXJlIGFkanVzdGluZyB0aGUgZ2xvYmFsIG1vY2sgc2V0dXAgZm9yICcuL2FwaS1oZWxwZXInXG4gICAgICAvLyBGb3Igc2ltcGxpY2l0eSBpbiB0aGlzIHNuaXBwZXQsIHdlJ2xsIGFzc3VtZSBhIGRpcmVjdCBtb2NrIHBhdGggb3IgdGhhdCBpdCdzIGluY2x1ZGVkIGluIHRoZSBzcGllZCBtb2R1bGUuXG4gICAgICAvLyBUaGlzIGlzIGEgY29tbW9uIEplc3QgY2hhbGxlbmdlIHdpdGggbW9kdWxlLWludGVybmFsIGZ1bmN0aW9uIGNhbGxzLlxuICAgICAgLy8gQSByb2J1c3Qgd2F5IGlzIHRvIGVuc3VyZSBgcmVzaWxpZW50R290UG9zdEhhc3VyYWAgaXMgYWxzbyBleHBvcnRlZCBhbmQgdGhlbiByZS1tb2NrZWQgaGVyZSxcbiAgICAgIC8vIG9yIGVuc3VyZSB0aGUgZ2xvYmFsIG1vY2sgb2YgJy4vYXBpLWhlbHBlcicgcHJvdmlkZXMgYSBqZXN0LmZuKCkgZm9yIGl0LlxuICAgICAgLy8gTGV0J3MgYXNzdW1lIHRoZSBnbG9iYWwgbW9jayBzZXR1cCBjYW4gYmUgYWRqdXN0ZWQgb3IgcmVzaWxpZW50R290UG9zdEhhc3VyYSBpcyBleHBvcnRlZC5cbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGFjdCBhcyBpZiB3ZSBjYW4gbW9jayBpdHMgYmVoYXZpb3IgZm9yIGdldEdsb2JhbENhbGVuZGFyLlxuICAgICAgcmVzaWxpZW50R290UG9zdEhhc3VyYU1vY2sgPSBqZXN0LnNweU9uKFxuICAgICAgICBhcGlIZWxwZXJNb2R1bGUsXG4gICAgICAgICdyZXNpbGllbnRHb3RQb3N0SGFzdXJhJ1xuICAgICAgKTtcbiAgICB9KTtcbiAgICBhZnRlckVhY2goKCkgPT4ge1xuICAgICAgcmVzaWxpZW50R290UG9zdEhhc3VyYU1vY2subW9ja1Jlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNhbGVuZGFyIGRhdGEgb24gc3VjY2Vzc2Z1bCBmZXRjaCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlc2lsaWVudEdvdFBvc3RIYXN1cmFNb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIENhbGVuZGFyOiBbbW9ja0NhbGVuZGFyRGF0YV0sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWlyZSgnLi9hcGktaGVscGVyJykuZ2V0R2xvYmFsQ2FsZW5kYXIodXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwobW9ja0NhbGVuZGFyRGF0YSk7XG4gICAgICBleHBlY3QocmVzaWxpZW50R290UG9zdEhhc3VyYU1vY2spLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAnZ2V0R2xvYmFsQ2FsZW5kYXInLFxuICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgIHsgdXNlcklkIH1cbiAgICAgICk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdnZXRHbG9iYWxDYWxlbmRhciBzdWNjZXNzZnVsIGZvciB1c2VyJyksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdW5kZWZpbmVkIGlmIG5vIGdsb2JhbCBjYWxlbmRhciBpcyBmb3VuZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJlc2lsaWVudEdvdFBvc3RIYXN1cmFNb2NrLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7IENhbGVuZGFyOiBbXSB9KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmdldEdsb2JhbENhbGVuZGFyKHVzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlVW5kZWZpbmVkKCk7XG4gICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuaW5mbykudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICdnZXRHbG9iYWxDYWxlbmRhcjogTm8gZ2xvYmFsIHByaW1hcnkgY2FsZW5kYXIgZm91bmQgZm9yIHVzZXInXG4gICAgICAgICksXG4gICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdW5kZWZpbmVkIGlmIENhbGVuZGFyIGZpZWxkIGlzIG1pc3NpbmcgKHVuZXhwZWN0ZWQgcmVzcG9uc2UpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmVzaWxpZW50R290UG9zdEhhc3VyYU1vY2subW9ja1Jlc29sdmVkVmFsdWVPbmNlKHt9KTsgLy8gTWlzc2luZyBDYWxlbmRhciBmaWVsZFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVxdWlyZSgnLi9hcGktaGVscGVyJykuZ2V0R2xvYmFsQ2FsZW5kYXIodXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5pbmZvKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgJ2dldEdsb2JhbENhbGVuZGFyOiBObyBnbG9iYWwgcHJpbWFyeSBjYWxlbmRhciBmb3VuZCBmb3IgdXNlcidcbiAgICAgICAgKSxcbiAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIHJlc2lsaWVudEdvdFBvc3RIYXN1cmEgdGhyb3dzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ0hhc3VyYSBmZXRjaCBmYWlsZWQnKTtcbiAgICAgIHJlc2lsaWVudEdvdFBvc3RIYXN1cmFNb2NrLm1vY2tSZWplY3RlZFZhbHVlT25jZShlcnJvcik7XG5cbiAgICAgIGF3YWl0IGV4cGVjdChcbiAgICAgICAgcmVxdWlyZSgnLi9hcGktaGVscGVyJykuZ2V0R2xvYmFsQ2FsZW5kYXIodXNlcklkKVxuICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ0hhc3VyYSBmZXRjaCBmYWlsZWQnKTtcbiAgICAgIGV4cGVjdChzcGllZExvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdFcnJvciBpbiBnZXRHbG9iYWxDYWxlbmRhciBmb3IgdXNlcicpLFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IGVycm9yOiAnSGFzdXJhIGZldGNoIGZhaWxlZCcgfSlcbiAgICAgICk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdHb29nbGUgQ2FsZW5kYXIgQVBJIEV2ZW50IEZ1bmN0aW9ucyAoY3JlYXRlLCBwYXRjaCwgZGVsZXRlKScsICgpID0+IHtcbiAgICBjb25zdCB1c2VySWQgPSAndGVzdC1nY2FsLXVzZXInO1xuICAgIGNvbnN0IGNhbGVuZGFySWQgPSAncHJpbWFyeSc7XG4gICAgY29uc3QgY2xpZW50VHlwZSA9ICd3ZWInO1xuICAgIGNvbnN0IG1vY2tHQ2FsRXZlbnRJZCA9ICdnY2FsLWV2ZW50LWlkLTEyMyc7XG4gICAgY29uc3QgbW9ja091ckV2ZW50SWQgPSBgJHttb2NrR0NhbEV2ZW50SWR9IyR7Y2FsZW5kYXJJZH1gO1xuXG4gICAgbGV0IGdldEdvb2dsZUFQSVRva2VuTW9jazogamVzdC5TcHlJbnN0YW5jZTtcbiAgICBjb25zdCBtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0ID0gamVzdC5mbigpO1xuICAgIGNvbnN0IG1vY2tHb29nbGVFdmVudHNQYXRjaCA9IGplc3QuZm4oKTtcbiAgICBjb25zdCBtb2NrR29vZ2xlRXZlbnRzRGVsZXRlID0gamVzdC5mbigpO1xuXG4gICAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgICBjb25zdCBhcGlIZWxwZXJNb2R1bGUgPSByZXF1aXJlKCcuL2FwaS1oZWxwZXInKTtcbiAgICAgIGdldEdvb2dsZUFQSVRva2VuTW9jayA9IGplc3Quc3B5T24oYXBpSGVscGVyTW9kdWxlLCAnZ2V0R29vZ2xlQVBJVG9rZW4nKTtcblxuICAgICAgLy8gTW9jayBnb29nbGVhcGlzXG4gICAgICBjb25zdCBnb29nbGUgPSByZXF1aXJlKCdnb29nbGVhcGlzJykuZ29vZ2xlO1xuICAgICAgZ29vZ2xlLmNhbGVuZGFyID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7XG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIGluc2VydDogbW9ja0dvb2dsZUV2ZW50c0luc2VydCxcbiAgICAgICAgICBwYXRjaDogbW9ja0dvb2dsZUV2ZW50c1BhdGNoLFxuICAgICAgICAgIGRlbGV0ZTogbW9ja0dvb2dsZUV2ZW50c0RlbGV0ZSxcbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIGdldEdvb2dsZUFQSVRva2VuTW9jay5tb2NrUmVzdG9yZSgpO1xuICAgICAgbW9ja0dvb2dsZUV2ZW50c0luc2VydC5tb2NrUmVzZXQoKTtcbiAgICAgIG1vY2tHb29nbGVFdmVudHNQYXRjaC5tb2NrUmVzZXQoKTtcbiAgICAgIG1vY2tHb29nbGVFdmVudHNEZWxldGUubW9ja1Jlc2V0KCk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY3JlYXRlR29vZ2xlRXZlbnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudFN1bW1hcnkgPSAnVGVzdCBFdmVudCBDcmVhdGlvbic7XG4gICAgICBjb25zdCBldmVudERhdGEgPSB7XG4gICAgICAgIHN1bW1hcnk6IGV2ZW50U3VtbWFyeSxcbiAgICAgICAgc3RhcnREYXRlVGltZTogZGF5anMoKS5hZGQoMSwgJ2RheScpLnRvSVNPU3RyaW5nKCksXG4gICAgICAgIGVuZERhdGVUaW1lOiBkYXlqcygpLmFkZCgxLCAnZGF5JykuYWRkKDEsICdob3VyJykudG9JU09TdHJpbmcoKSxcbiAgICAgICAgdGltZXpvbmU6ICdBbWVyaWNhL05ld19Zb3JrJyxcbiAgICAgIH07XG5cbiAgICAgIGl0KCdzaG91bGQgY3JlYXRlIGV2ZW50IHN1Y2Nlc3NmdWxseSBvbiBmaXJzdCBhdHRlbXB0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZXRHb29nbGVBUElUb2tlbk1vY2subW9ja1Jlc29sdmVkVmFsdWVPbmNlKCdmYWtlLWdvb2dsZS1hcGktdG9rZW4nKTtcbiAgICAgICAgbW9ja0dvb2dsZUV2ZW50c0luc2VydC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGRhdGE6IHsgaWQ6IG1vY2tHQ2FsRXZlbnRJZCwgc3VtbWFyeTogZXZlbnRTdW1tYXJ5IH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjYWxlbmRhcklkLFxuICAgICAgICAgIGNsaWVudFR5cGUsXG4gICAgICAgICAgbW9ja091ckV2ZW50SWQsXG4gICAgICAgICAgZXZlbnREYXRhLmVuZERhdGVUaW1lLFxuICAgICAgICAgIGV2ZW50RGF0YS5zdGFydERhdGVUaW1lLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGV2ZW50U3VtbWFyeSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgZXZlbnREYXRhLnRpbWV6b25lXG4gICAgICAgICk7XG5cbiAgICAgICAgZXhwZWN0KHJlc3VsdC5nb29nbGVFdmVudElkKS50b0JlKG1vY2tHQ2FsRXZlbnRJZCk7XG4gICAgICAgIGV4cGVjdChnZXRHb29nbGVBUElUb2tlbk1vY2spLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBleHBlY3QuYW55KFN0cmluZyksXG4gICAgICAgICAgY2xpZW50VHlwZVxuICAgICAgICApO1xuICAgICAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c0luc2VydCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c0luc2VydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IHN1bW1hcnk6IGV2ZW50U3VtbWFyeSB9KSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHRpbWVvdXQ6IDIwMDAwIH1cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICAgYEdvb2dsZSBDYWxlbmRhciBldmVudCBjcmVhdGVkIHN1Y2Nlc3NmdWxseSBvbiBhdHRlbXB0IDEgZm9yIHVzZXIgJHt1c2VySWR9YFxuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHJ5IG9uIDUwMCBlcnJvciB0aGVuIHN1Y2NlZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdldEdvb2dsZUFQSVRva2VuTW9jay5tb2NrUmVzb2x2ZWRWYWx1ZSgnZmFrZS1nb29nbGUtYXBpLXRva2VuJyk7XG4gICAgICAgIG1vY2tHb29nbGVFdmVudHNJbnNlcnRcbiAgICAgICAgICAubW9ja1JlamVjdGVkVmFsdWVPbmNlKHsgY29kZTogNTAwLCBtZXNzYWdlOiAnU2VydmVyIGVycm9yJyB9KVxuICAgICAgICAgIC5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgZGF0YTogeyBpZDogbW9ja0dDYWxFdmVudElkLCBzdW1tYXJ5OiBldmVudFN1bW1hcnkgfSxcbiAgICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5jcmVhdGVHb29nbGVFdmVudChcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICBjbGllbnRUeXBlLFxuICAgICAgICAgIG1vY2tPdXJFdmVudElkLFxuICAgICAgICAgIGV2ZW50RGF0YS5lbmREYXRlVGltZSxcbiAgICAgICAgICBldmVudERhdGEuc3RhcnREYXRlVGltZSxcbiAgICAgICAgICAxLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBldmVudFN1bW1hcnksXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGV2ZW50RGF0YS50aW1lem9uZVxuICAgICAgICApO1xuXG4gICAgICAgIGV4cGVjdChtb2NrR29vZ2xlRXZlbnRzSW5zZXJ0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMik7XG4gICAgICAgIGV4cGVjdChzcGllZExvZ2dlci53YXJuKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBleHBlY3Quc3RyaW5nQ29udGFpbmluZyhcbiAgICAgICAgICAgIGBBdHRlbXB0IDEgdG8gY3JlYXRlIEdvb2dsZSBldmVudCBmb3IgdXNlciAke3VzZXJJZH0gZmFpbGVkYFxuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLndhcm4pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICAgYFJldHJ5aW5nIEdvb2dsZSBldmVudCBjcmVhdGlvbiBmb3IgdXNlciAke3VzZXJJZH0sIGF0dGVtcHQgMmBcbiAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBmYWlsIGltbWVkaWF0ZWx5IG9uIDQwMSBlcnJvcicsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5Nb2NrLm1vY2tSZXNvbHZlZFZhbHVlKCdmYWtlLWdvb2dsZS1hcGktdG9rZW4nKTtcbiAgICAgICAgbW9ja0dvb2dsZUV2ZW50c0luc2VydC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgIGNvZGU6IDQwMSxcbiAgICAgICAgICBtZXNzYWdlOiAnVW5hdXRob3JpemVkJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICAgIHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICAgIGNsaWVudFR5cGUsXG4gICAgICAgICAgICBtb2NrT3VyRXZlbnRJZCxcbiAgICAgICAgICAgIGV2ZW50RGF0YS5lbmREYXRlVGltZSxcbiAgICAgICAgICAgIGV2ZW50RGF0YS5zdGFydERhdGVUaW1lLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2ZW50U3VtbWFyeSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2ZW50RGF0YS50aW1lem9uZVxuICAgICAgICAgIClcbiAgICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ1VuYXV0aG9yaXplZCcpO1xuICAgICAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c0luc2VydCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKCdGYWlsZWQgdG8gY3JlYXRlIEdvb2dsZSBldmVudCBmb3IgdXNlcicpLFxuICAgICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICAgIGl0KCdzaG91bGQgZmFpbCBpZiBnZXRHb29nbGVBUElUb2tlbiBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5Nb2NrLm1vY2tSZWplY3RlZFZhbHVlT25jZShcbiAgICAgICAgICBuZXcgRXJyb3IoJ1Rva2VuIGZldGNoIGZhaWxlZCcpXG4gICAgICAgICk7XG5cbiAgICAgICAgYXdhaXQgZXhwZWN0KFxuICAgICAgICAgIHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmNyZWF0ZUdvb2dsZUV2ZW50KFxuICAgICAgICAgICAgdXNlcklkLFxuICAgICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICAgIGNsaWVudFR5cGUsXG4gICAgICAgICAgICBtb2NrT3VyRXZlbnRJZCxcbiAgICAgICAgICAgIGV2ZW50RGF0YS5lbmREYXRlVGltZSxcbiAgICAgICAgICAgIGV2ZW50RGF0YS5zdGFydERhdGVUaW1lLFxuICAgICAgICAgICAgMSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2ZW50U3VtbWFyeSxcbiAgICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV2ZW50RGF0YS50aW1lem9uZVxuICAgICAgICAgIClcbiAgICAgICAgKS5yZWplY3RzLnRvVGhyb3coJ1Rva2VuIGZldGNoIGZhaWxlZCcpO1xuICAgICAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c0luc2VydCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3BhdGNoR29vZ2xlRXZlbnQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudFN1bW1hcnlVcGRhdGUgPSAnVXBkYXRlZCBUZXN0IEV2ZW50JztcbiAgICAgIGNvbnN0IHBhdGNoRGF0YSA9IHsgc3VtbWFyeTogZXZlbnRTdW1tYXJ5VXBkYXRlIH07XG5cbiAgICAgIGl0KCdzaG91bGQgcGF0Y2ggZXZlbnQgc3VjY2Vzc2Z1bGx5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBnZXRHb29nbGVBUElUb2tlbk1vY2subW9ja1Jlc29sdmVkVmFsdWUoJ2Zha2UtZ29vZ2xlLWFwaS10b2tlbicpO1xuICAgICAgICBtb2NrR29vZ2xlRXZlbnRzUGF0Y2gubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICBkYXRhOiB7IGlkOiBtb2NrR0NhbEV2ZW50SWQsIHN1bW1hcnk6IGV2ZW50U3VtbWFyeVVwZGF0ZSB9LFxuICAgICAgICB9KTtcblxuICAgICAgICBhd2FpdCByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5wYXRjaEdvb2dsZUV2ZW50KFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjYWxlbmRhcklkLFxuICAgICAgICAgIG1vY2tHQ2FsRXZlbnRJZCxcbiAgICAgICAgICBjbGllbnRUeXBlLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgMSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGV2ZW50U3VtbWFyeVVwZGF0ZVxuICAgICAgICApO1xuICAgICAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c1BhdGNoKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrR29vZ2xlRXZlbnRzUGF0Y2gpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHtcbiAgICAgICAgICAgIGNhbGVuZGFySWQsXG4gICAgICAgICAgICBldmVudElkOiBtb2NrR0NhbEV2ZW50SWQsXG4gICAgICAgICAgICByZXF1ZXN0Qm9keTogZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcocGF0Y2hEYXRhKSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgICB7IHRpbWVvdXQ6IDIwMDAwIH1cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICAgYEdvb2dsZSBDYWxlbmRhciBldmVudCAke21vY2tHQ2FsRXZlbnRJZH0gcGF0Y2hlZCBzdWNjZXNzZnVsbHkgb24gYXR0ZW1wdCAxYFxuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHJ5IG9uIDQwMyByYXRlTGltaXRFeGNlZWRlZCB0aGVuIHN1Y2NlZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGdldEdvb2dsZUFQSVRva2VuTW9jay5tb2NrUmVzb2x2ZWRWYWx1ZSgnZmFrZS1nb29nbGUtYXBpLXRva2VuJyk7XG4gICAgICAgIG1vY2tHb29nbGVFdmVudHNQYXRjaFxuICAgICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICAgICAgY29kZTogNDAzLFxuICAgICAgICAgICAgZXJyb3JzOiBbeyByZWFzb246ICdyYXRlTGltaXRFeGNlZWRlZCcgfV0sXG4gICAgICAgICAgICBtZXNzYWdlOiAnUmF0ZSBsaW1pdCcsXG4gICAgICAgICAgfSlcbiAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgICAgIGRhdGE6IHsgaWQ6IG1vY2tHQ2FsRXZlbnRJZCwgc3VtbWFyeTogZXZlbnRTdW1tYXJ5VXBkYXRlIH0sXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgcmVxdWlyZSgnLi9hcGktaGVscGVyJykucGF0Y2hHb29nbGVFdmVudChcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICBtb2NrR0NhbEV2ZW50SWQsXG4gICAgICAgICAgY2xpZW50VHlwZSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIDEsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIHVuZGVmaW5lZCxcbiAgICAgICAgICBldmVudFN1bW1hcnlVcGRhdGVcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KG1vY2tHb29nbGVFdmVudHNQYXRjaCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICBleHBlY3Qoc3BpZWRMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgICBgQXR0ZW1wdCAxIHRvIHBhdGNoIEdvb2dsZSBldmVudCAke21vY2tHQ2FsRXZlbnRJZH0gZm9yIHVzZXIgJHt1c2VySWR9IGZhaWxlZGBcbiAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdkZWxldGVHb29nbGVFdmVudCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgZGVsZXRlIGV2ZW50IHN1Y2Nlc3NmdWxseScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5Nb2NrLm1vY2tSZXNvbHZlZFZhbHVlKCdmYWtlLWdvb2dsZS1hcGktdG9rZW4nKTtcbiAgICAgICAgbW9ja0dvb2dsZUV2ZW50c0RlbGV0ZS5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe30pOyAvLyBEZWxldGUgb2Z0ZW4gcmV0dXJucyBlbXB0eSByZXNwb25zZVxuXG4gICAgICAgIGF3YWl0IHJlcXVpcmUoJy4vYXBpLWhlbHBlcicpLmRlbGV0ZUdvb2dsZUV2ZW50KFxuICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICBjYWxlbmRhcklkLFxuICAgICAgICAgIG1vY2tHQ2FsRXZlbnRJZCxcbiAgICAgICAgICBjbGllbnRUeXBlXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChtb2NrR29vZ2xlRXZlbnRzRGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICAgIGV4cGVjdChtb2NrR29vZ2xlRXZlbnRzRGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IGNhbGVuZGFySWQsIGV2ZW50SWQ6IG1vY2tHQ2FsRXZlbnRJZCB9KSxcbiAgICAgICAgICB7IHRpbWVvdXQ6IDIwMDAwIH1cbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICAgYEdvb2dsZSBDYWxlbmRhciBldmVudCAke21vY2tHQ2FsRXZlbnRJZH0gZGVsZXRlZCBzdWNjZXNzZnVsbHkgb24gYXR0ZW1wdCAxYFxuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGZhaWwgaW1tZWRpYXRlbHkgb24gNDA0IChldmVudCBub3QgZm91bmQpIGlmIG5vdCByZXRyaWVkIGJ5IHBvbGljeSAodGhvdWdoIGN1cnJlbnQgcG9saWN5IG1pZ2h0IHJldHJ5IDQwNCAtIHZlcmlmeSknLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IHJldHJ5IHBvbGljeSBpbiBkZWxldGVHb29nbGVFdmVudCAqZG9lcyogcmV0cnkgNDA0LlxuICAgICAgICAvLyBUbyB0ZXN0IGltbWVkaWF0ZSBiYWlsIG9uIDQwNCwgdGhlIHBvbGljeSBpbiB0aGUgbWFpbiBjb2RlIHdvdWxkIG5lZWQgdG8gY2hhbmdlLlxuICAgICAgICAvLyBGb3Igbm93LCBsZXQncyB0ZXN0IHRoYXQgaXQgKmRvZXMqIHJldHJ5IDQwNCBhbmQgdGhlbiBjb3VsZCBzdWNjZWVkIG9yIGZhaWwgYmFzZWQgb24gbW9jay5cbiAgICAgICAgZ2V0R29vZ2xlQVBJVG9rZW5Nb2NrLm1vY2tSZXNvbHZlZFZhbHVlKCdmYWtlLWdvb2dsZS1hcGktdG9rZW4nKTtcbiAgICAgICAgbW9ja0dvb2dsZUV2ZW50c0RlbGV0ZVxuICAgICAgICAgIC5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UoeyBjb2RlOiA0MDQsIG1lc3NhZ2U6ICdOb3QgRm91bmQnIH0pIC8vIEZpcnN0IGF0dGVtcHQgZmFpbHMgd2l0aCA0MDRcbiAgICAgICAgICAubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHt9KTsgLy8gU2Vjb25kIGF0dGVtcHQgc3VjY2VlZHNcblxuICAgICAgICBhd2FpdCByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5kZWxldGVHb29nbGVFdmVudChcbiAgICAgICAgICB1c2VySWQsXG4gICAgICAgICAgY2FsZW5kYXJJZCxcbiAgICAgICAgICBtb2NrR0NhbEV2ZW50SWQsXG4gICAgICAgICAgY2xpZW50VHlwZVxuICAgICAgICApO1xuICAgICAgICBleHBlY3QobW9ja0dvb2dsZUV2ZW50c0RlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDIpO1xuICAgICAgICBleHBlY3Qoc3BpZWRMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgICBgQXR0ZW1wdCAxIHRvIGRlbGV0ZSBHb29nbGUgZXZlbnQgJHttb2NrR0NhbEV2ZW50SWR9IGZvciB1c2VyICR7dXNlcklkfSBmYWlsZWRgXG4gICAgICAgICAgKSxcbiAgICAgICAgICBleHBlY3QuYW55dGhpbmcoKVxuICAgICAgICApO1xuICAgICAgICBleHBlY3Qoc3BpZWRMb2dnZXIud2FybikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgZXhwZWN0LnN0cmluZ0NvbnRhaW5pbmcoXG4gICAgICAgICAgICBgUmV0cnlpbmcgR29vZ2xlIGV2ZW50IGRlbGV0ZSBmb3IgZXZlbnQgJHttb2NrR0NhbEV2ZW50SWR9YFxuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICAgKTtcbiAgICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmluZm8pLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICAgYEdvb2dsZSBDYWxlbmRhciBldmVudCAke21vY2tHQ2FsRXZlbnRJZH0gZGVsZXRlZCBzdWNjZXNzZnVsbHkgb24gYXR0ZW1wdCAyYFxuICAgICAgICAgICksXG4gICAgICAgICAgZXhwZWN0LmFueXRoaW5nKClcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnTGFuY2VEQi9PcGVuU2VhcmNoIGFuZCBvdGhlciB1dGlsaXRpZXMgd2l0aCBsb2dnZXIgY2hhbmdlcycsICgpID0+IHtcbiAgICAvLyBNb2NrIGxhbmNlZGJfc2VydmljZSBmdW5jdGlvbnMgaWYgdGhleSBhcmUgY2FsbGVkIGRpcmVjdGx5IGJ5IHRoZSBmdW5jdGlvbnMgdW5kZXIgdGVzdFxuICAgIC8vIEZvciBub3csIGFzc3VtZSB0aGV5IHRocm93IGVycm9ycyBmb3IgdGVzdGluZyBlcnJvciBwYXRocy5cbiAgICBjb25zdCBtb2NrU2VhcmNoRXZlbnRzID0gamVzdC5mbigpO1xuICAgIGNvbnN0IG1vY2tHZXRTZWFyY2hDbGllbnQgPSBqZXN0LmZuKCk7IC8vIEZvciBwdXREYXRhSW5UcmFpbkV2ZW50SW5kZXhJbk9wZW5TZWFyY2hcblxuICAgIGplc3QubW9jaygnQGZ1bmN0aW9ucy9fdXRpbHMvbGFuY2VkYl9zZXJ2aWNlJywgKCkgPT4gKHtcbiAgICAgIC4uLmplc3QucmVxdWlyZUFjdHVhbCgnQGZ1bmN0aW9ucy9fdXRpbHMvbGFuY2VkYl9zZXJ2aWNlJyksIC8vIEtlZXAgb3JpZ2luYWwgZm9yIG5vbi1tb2NrZWQgcGFydHNcbiAgICAgIHNlYXJjaEV2ZW50czogbW9ja1NlYXJjaEV2ZW50cyxcbiAgICAgIC8vIEFkZCBvdGhlciBsYW5jZWRiX3NlcnZpY2UgbW9ja3MgaWYgbmVlZGVkIGJ5IG90aGVyIGZ1bmN0aW9uc1xuICAgIH0pKTtcblxuICAgIC8vIE1vY2sgZm9yIHB1dERhdGFJblRyYWluRXZlbnRJbmRleEluT3BlblNlYXJjaCdzIGdldFNlYXJjaENsaWVudFxuICAgIC8vIFRoaXMgaXMgbW9yZSBjb21wbGV4IGlmIGdldFNlYXJjaENsaWVudCBpcyBub3QgZWFzaWx5IG1vY2thYmxlIG9yIGhhcyBzaWRlIGVmZmVjdHMuXG4gICAgLy8gRm9yIHRoaXMgZXhhbXBsZSwgd2UnbGwgYXNzdW1lIGEgc2ltcGxpZmllZCBwYXRoIG9yIHRoYXQgaXQncyBoYW5kbGVkIGlmIG5lZWRlZC5cblxuICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgbW9ja1NlYXJjaEV2ZW50cy5tb2NrUmVzZXQoKTtcbiAgICAgIG1vY2tHZXRTZWFyY2hDbGllbnQubW9ja1Jlc2V0KCk7XG4gICAgICAvLyBSZXNldCBhbnkgb3RoZXIgbW9ja3MgZm9yIHRoaXMgc3VpdGVcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdzZWFyY2hTaW5nbGVFdmVudEJ5VmVjdG9yTGFuY2VEYicsICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJZCA9ICdsYW5jZS11c2VyJztcbiAgICAgIGNvbnN0IHZlY3RvciA9IFswLjEsIDAuMl07XG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGFuZCBsb2cgZXJyb3Igd2hlbiBzZWFyY2hFdmVudHMgdGhyb3dzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignTGFuY2VEQiBjb25uZWN0aW9uIGZhaWxlZCcpO1xuICAgICAgICBtb2NrU2VhcmNoRXZlbnRzLm1vY2tSZWplY3RlZFZhbHVlT25jZShlcnJvcik7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID1cbiAgICAgICAgICBhd2FpdCByZXF1aXJlKCcuL2FwaS1oZWxwZXInKS5zZWFyY2hTaW5nbGVFdmVudEJ5VmVjdG9yTGFuY2VEYihcbiAgICAgICAgICAgIHVzZXJJZCxcbiAgICAgICAgICAgIHZlY3RvclxuICAgICAgICAgICk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVOdWxsKCk7IC8vIEFzIHBlciBvcmlnaW5hbCBsb2dpYywgaXQgY2F0Y2hlcyBhbmQgcmV0dXJucyBudWxsXG4gICAgICAgIGV4cGVjdChzcGllZExvZ2dlci5lcnJvcikudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICAgJ0Vycm9yIGluIHNlYXJjaFNpbmdsZUV2ZW50QnlWZWN0b3JMYW5jZURiJyxcbiAgICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IHVzZXJJZCwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2V4dHJhcG9sYXRlRGF0ZUZyb21KU09ORGF0YScsICgpID0+IHtcbiAgICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgdmVyeSBjb21wbGV4LiBXZSdsbCBkbyBhIGJhc2ljIHRlc3QgdG8gZW5zdXJlIGl0IHJ1bnMgYW5kIGEgZGVidWcgbG9nIGlzIGhpdC5cbiAgICAgIGl0KCdzaG91bGQgcnVuIGFuZCBtYWtlIGEgZGVidWcgbG9nIGNhbGwnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gJzIwMjMtMTAtMjZUMTA6MDA6MDBaJztcbiAgICAgICAgY29uc3QgdGltZXpvbmUgPSAnQW1lcmljYS9OZXdfWW9yayc7XG4gICAgICAgIC8vIENhbGwgd2l0aCBzb21lIGJhc2ljIGRhdGEsIGFjdHVhbCByZXN1bHQgaXNuJ3QgdGhlIGZvY3VzLCBqdXN0IHRoYXQgaXQgcnVucyBhbmQgbG9ncy5cbiAgICAgICAgcmVxdWlyZSgnLi9hcGktaGVscGVyJykuZXh0cmFwb2xhdGVEYXRlRnJvbUpTT05EYXRhKFxuICAgICAgICAgIGN1cnJlbnRUaW1lLFxuICAgICAgICAgIHRpbWV6b25lLFxuICAgICAgICAgICcyMDIzJyxcbiAgICAgICAgICAnMTAnLFxuICAgICAgICAgICcyNicsXG4gICAgICAgICAgbnVsbCxcbiAgICAgICAgICAxNCxcbiAgICAgICAgICAzMCxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgbnVsbFxuICAgICAgICApO1xuICAgICAgICBleHBlY3Qoc3BpZWRMb2dnZXIuZGVidWcpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgICAgJ1tleHRyYXBvbGF0ZURhdGVGcm9tSlNPTkRhdGFdIEluaXRpYWwgcGFyYW1zOidcbiAgICAgICAgICApLFxuICAgICAgICAgIGV4cGVjdC5hbnl0aGluZygpXG4gICAgICAgICk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdnZW5lcmF0ZUpTT05EYXRhRnJvbVVzZXJJbnB1dCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHVzZXJJbnB1dCA9ICdzY2hlZHVsZSBhIG1lZXRpbmcgZm9yIHRvbW9ycm93JztcbiAgICAgIGNvbnN0IHVzZXJDdXJyZW50VGltZSA9ICdNb25kYXksIDIwMjMtMTAtMzBUMTA6MDA6MDAtMDQ6MDAnO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiB1bmRlZmluZWQgYW5kIGxvZyBlcnJvciBpZiBPcGVuQUkgY2FsbCBmYWlscycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgLy8gTW9jayB0aGUgaW50ZXJuYWwgY2FsbE9wZW5BSVdpdGhNZXNzYWdlSGlzdG9yeU9ubHkgdG8gdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgLy8gVGhpcyByZXF1aXJlcyBjYWxsT3BlbkFJV2l0aE1lc3NhZ2VIaXN0b3J5T25seSB0byBiZSBtb2NrYWJsZSwgbWlnaHQgbmVlZCB0byBhZGp1c3QgZ2xvYmFsIG1vY2sgc2V0dXBcbiAgICAgICAgY29uc3QgYXBpSGVscGVyTW9kdWxlID0gcmVxdWlyZSgnLi9hcGktaGVscGVyJyk7XG4gICAgICAgIGNvbnN0IGNhbGxPcGVuQUlNb2NrID0gamVzdC5zcHlPbihcbiAgICAgICAgICBhcGlIZWxwZXJNb2R1bGUsXG4gICAgICAgICAgJ2NhbGxPcGVuQUlXaXRoTWVzc2FnZUhpc3RvcnlPbmx5J1xuICAgICAgICApO1xuICAgICAgICBjYWxsT3BlbkFJTW9jay5tb2NrUmVqZWN0ZWRWYWx1ZU9uY2UobmV3IEVycm9yKCdPcGVuQUkgQVBJIEVycm9yJykpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFwaUhlbHBlck1vZHVsZS5nZW5lcmF0ZUpTT05EYXRhRnJvbVVzZXJJbnB1dChcbiAgICAgICAgICB1c2VySW5wdXQsXG4gICAgICAgICAgdXNlckN1cnJlbnRUaW1lXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmVVbmRlZmluZWQoKTtcbiAgICAgICAgZXhwZWN0KHNwaWVkTG9nZ2VyLmVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgICAgICAnVW5hYmxlIHRvIGdlbmVyYXRlIEpTT04gZGF0YSBmcm9tIHVzZXIgaW5wdXQnLFxuICAgICAgICAgIGV4cGVjdC5vYmplY3RDb250YWluaW5nKHsgdXNlcklucHV0LCBlcnJvcjogJ09wZW5BSSBBUEkgRXJyb3InIH0pXG4gICAgICAgICk7XG4gICAgICAgIGNhbGxPcGVuQUlNb2NrLm1vY2tSZXN0b3JlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59KTtcbiJdfQ==