// atomic-docker/project/functions/atom-agent/sharedAgentState.ts
// Import dbService functions
import { addPendingJob, getPendingJob, deletePendingJob,
// updatePendingJobStatus, // Optional: if we want to expose status updates via sharedAgentState
 } from '../_utils/dbService'; // Adjust path as needed if _utils is elsewhere
// Using console for logging within this file if no central logger is passed around.
const logger = {
    info: console.log,
    error: console.error,
    warn: console.warn,
};
// The in-memory map is now removed. Logic is delegated to dbService.
export async function storePendingRequest(jobInfo) {
    logger.info(`[sharedAgentState.storePendingRequest] Storing job with fileKey: ${jobInfo.fileKey}`);
    try {
        // The addPendingJob function in dbService expects a PendingRequestInfo object
        // that aligns with the DB schema (e.g., submittedAt should be Date or ISO string).
        // The status is handled by dbService internally (defaults to 'PENDING').
        await addPendingJob(jobInfo);
        logger.info(`[sharedAgentState.storePendingRequest] Successfully stored job with fileKey: ${jobInfo.fileKey}`);
    }
    catch (error) {
        logger.error(`[sharedAgentState.storePendingRequest] Error storing job with fileKey ${jobInfo.fileKey}:`, error);
        // Re-throw or handle as appropriate for the application's error handling strategy
        throw error;
    }
}
export async function retrievePendingRequest(fileKey) {
    logger.info(`[sharedAgentState.retrievePendingRequest] Retrieving job with fileKey: ${fileKey}`);
    try {
        // getPendingJob from dbService returns PendingRequestInfo | null
        // and specifically fetches jobs with status = 'PENDING'.
        const jobInfo = await getPendingJob(fileKey);
        if (jobInfo) {
            logger.info(`[sharedAgentState.retrievePendingRequest] Successfully retrieved job with fileKey: ${fileKey}`);
        }
        else {
            logger.info(`[sharedAgentState.retrievePendingRequest] No 'PENDING' job found with fileKey: ${fileKey}`);
        }
        return jobInfo;
    }
    catch (error) {
        logger.error(`[sharedAgentState.retrievePendingRequest] Error retrieving job with fileKey ${fileKey}:`, error);
        throw error;
    }
}
export async function removePendingRequest(fileKey) {
    logger.info(`[sharedAgentState.removePendingRequest] Removing job with fileKey: ${fileKey}`);
    try {
        await deletePendingJob(fileKey);
        // deletePendingJob in dbService already logs success/failure to delete.
        // No specific success confirmation needed here unless different logic is required.
    }
    catch (error) {
        logger.error(`[sharedAgentState.removePendingRequest] Error removing job with fileKey ${fileKey}:`, error);
        throw error;
    }
}
// Optional: Expose status update if needed by application logic directly through sharedAgentState
// import { updatePendingJobStatus as dbUpdateStatus } from '../_utils/dbService'; // Alias if needed
// export async function updateStatusForPendingRequest(fileKey: string, status: string): Promise<void> {
//   logger.info(`[sharedAgentState.updateStatusForPendingRequest] Updating status to '${status}' for fileKey: ${fileKey}`);
//   try {
//     await dbUpdateStatus(fileKey, status);
//   } catch (error) {
//     logger.error(`[sharedAgentState.updateStatusForPendingRequest] Error updating status for fileKey ${fileKey}:`, error);
//     throw error;
//   }
// }
// (Could add other shared state management functions here in the future if needed)
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkQWdlbnRTdGF0ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInNoYXJlZEFnZW50U3RhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUVBQWlFO0FBRWpFLDZCQUE2QjtBQUM3QixPQUFPLEVBQ0wsYUFBYSxFQUNiLGFBQWEsRUFDYixnQkFBZ0I7QUFDaEIsZ0dBQWdHO0VBQ2pHLE1BQU0scUJBQXFCLENBQUMsQ0FBQywrQ0FBK0M7QUFnQjdFLG9GQUFvRjtBQUNwRixNQUFNLE1BQU0sR0FBRztJQUNiLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRztJQUNqQixLQUFLLEVBQUUsT0FBTyxDQUFDLEtBQUs7SUFDcEIsSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO0NBQ25CLENBQUM7QUFFRixxRUFBcUU7QUFFckUsTUFBTSxDQUFDLEtBQUssVUFBVSxtQkFBbUIsQ0FDdkMsT0FBMkI7SUFFM0IsTUFBTSxDQUFDLElBQUksQ0FDVCxvRUFBb0UsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUN0RixDQUFDO0lBQ0YsSUFBSSxDQUFDO1FBQ0gsOEVBQThFO1FBQzlFLG1GQUFtRjtRQUNuRix5RUFBeUU7UUFDekUsTUFBTSxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDN0IsTUFBTSxDQUFDLElBQUksQ0FDVCxnRkFBZ0YsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUNsRyxDQUFDO0lBQ0osQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDZixNQUFNLENBQUMsS0FBSyxDQUNWLHlFQUF5RSxPQUFPLENBQUMsT0FBTyxHQUFHLEVBQzNGLEtBQUssQ0FDTixDQUFDO1FBQ0Ysa0ZBQWtGO1FBQ2xGLE1BQU0sS0FBSyxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUM7QUFFRCxNQUFNLENBQUMsS0FBSyxVQUFVLHNCQUFzQixDQUMxQyxPQUFlO0lBRWYsTUFBTSxDQUFDLElBQUksQ0FDVCwwRUFBMEUsT0FBTyxFQUFFLENBQ3BGLENBQUM7SUFDRixJQUFJLENBQUM7UUFDSCxpRUFBaUU7UUFDakUseURBQXlEO1FBQ3pELE1BQU0sT0FBTyxHQUFHLE1BQU0sYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzdDLElBQUksT0FBTyxFQUFFLENBQUM7WUFDWixNQUFNLENBQUMsSUFBSSxDQUNULHNGQUFzRixPQUFPLEVBQUUsQ0FDaEcsQ0FBQztRQUNKLENBQUM7YUFBTSxDQUFDO1lBQ04sTUFBTSxDQUFDLElBQUksQ0FDVCxrRkFBa0YsT0FBTyxFQUFFLENBQzVGLENBQUM7UUFDSixDQUFDO1FBQ0QsT0FBTyxPQUFPLENBQUM7SUFDakIsQ0FBQztJQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7UUFDZixNQUFNLENBQUMsS0FBSyxDQUNWLCtFQUErRSxPQUFPLEdBQUcsRUFDekYsS0FBSyxDQUNOLENBQUM7UUFDRixNQUFNLEtBQUssQ0FBQztJQUNkLENBQUM7QUFDSCxDQUFDO0FBRUQsTUFBTSxDQUFDLEtBQUssVUFBVSxvQkFBb0IsQ0FBQyxPQUFlO0lBQ3hELE1BQU0sQ0FBQyxJQUFJLENBQ1Qsc0VBQXNFLE9BQU8sRUFBRSxDQUNoRixDQUFDO0lBQ0YsSUFBSSxDQUFDO1FBQ0gsTUFBTSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNoQyx3RUFBd0U7UUFDeEUsbUZBQW1GO0lBQ3JGLENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2YsTUFBTSxDQUFDLEtBQUssQ0FDViwyRUFBMkUsT0FBTyxHQUFHLEVBQ3JGLEtBQUssQ0FDTixDQUFDO1FBQ0YsTUFBTSxLQUFLLENBQUM7SUFDZCxDQUFDO0FBQ0gsQ0FBQztBQUVELGtHQUFrRztBQUNsRyxxR0FBcUc7QUFDckcsd0dBQXdHO0FBQ3hHLDRIQUE0SDtBQUM1SCxVQUFVO0FBQ1YsNkNBQTZDO0FBQzdDLHNCQUFzQjtBQUN0Qiw2SEFBNkg7QUFDN0gsbUJBQW1CO0FBQ25CLE1BQU07QUFDTixJQUFJO0FBRUosbUZBQW1GIiwic291cmNlc0NvbnRlbnQiOlsiLy8gYXRvbWljLWRvY2tlci9wcm9qZWN0L2Z1bmN0aW9ucy9hdG9tLWFnZW50L3NoYXJlZEFnZW50U3RhdGUudHNcblxuLy8gSW1wb3J0IGRiU2VydmljZSBmdW5jdGlvbnNcbmltcG9ydCB7XG4gIGFkZFBlbmRpbmdKb2IsXG4gIGdldFBlbmRpbmdKb2IsXG4gIGRlbGV0ZVBlbmRpbmdKb2IsXG4gIC8vIHVwZGF0ZVBlbmRpbmdKb2JTdGF0dXMsIC8vIE9wdGlvbmFsOiBpZiB3ZSB3YW50IHRvIGV4cG9zZSBzdGF0dXMgdXBkYXRlcyB2aWEgc2hhcmVkQWdlbnRTdGF0ZVxufSBmcm9tICcuLi9fdXRpbHMvZGJTZXJ2aWNlJzsgLy8gQWRqdXN0IHBhdGggYXMgbmVlZGVkIGlmIF91dGlscyBpcyBlbHNld2hlcmVcblxuLy8gRm9yIHN0b3JpbmcgaW5mb3JtYXRpb24gYWJvdXQgcGVuZGluZyBzY2hlZHVsaW5nIHJlcXVlc3RzXG4vLyBUaGlzIGludGVyZmFjZSBkZWZpbmVzIHRoZSBzdHJ1Y3R1cmUgb2YgdGhlIGRhdGEgcGFzc2VkIGFyb3VuZCBpbiB0aGUgYXBwbGljYXRpb24gbG9naWMuXG4vLyBUaGUgZGJTZXJ2aWNlIHdpbGwgaGFuZGxlIG1hcHBpbmcgdGhpcyB0by9mcm9tIHRoZSBkYXRhYmFzZSBzY2hlbWEuXG5leHBvcnQgaW50ZXJmYWNlIFBlbmRpbmdSZXF1ZXN0SW5mbyB7XG4gIGZpbGVLZXk6IHN0cmluZztcbiAgdXNlcklkOiBzdHJpbmc7IC8vIEFnZW50J3MgaW50ZXJuYWwgdXNlcklkIHdobyBtYWRlIHRoZSBvcmlnaW5hbCByZXF1ZXN0XG4gIGhvc3RJZDogc3RyaW5nOyAvLyBob3N0SWQgc2VudCB0byB0aGUgc2NoZWR1bGVyXG4gIHNpbmdsZXRvbklkOiBzdHJpbmc7IC8vIHNpbmdsZXRvbklkIHNlbnQgdG8gdGhlIHNjaGVkdWxlclxuICBvcmlnaW5hbFF1ZXJ5Pzogc3RyaW5nOyAvLyBPcHRpb25hbDogdGhlIHVzZXIncyBvcmlnaW5hbCBuYXR1cmFsIGxhbmd1YWdlIHF1ZXJ5XG4gIHN1Ym1pdHRlZEF0OiBEYXRlO1xuICAvLyBzdGF0dXM/OiBzdHJpbmc7IC8vIFN0YXR1cyBpcyBtYW5hZ2VkIGluIHRoZSBEQiBsYXllciwgbm90IHR5cGljYWxseSBwYXJ0IG9mIHRoaXMgYXBwLWxldmVsIGluZm8gb2JqZWN0XG4gIC8vIHdoZW4gaW5pdGlhbGx5IHN0b3JpbmcuIEl0J3MgbW9yZSBvZiBhIERCIGNvbHVtbi5cbn1cblxuLy8gVXNpbmcgY29uc29sZSBmb3IgbG9nZ2luZyB3aXRoaW4gdGhpcyBmaWxlIGlmIG5vIGNlbnRyYWwgbG9nZ2VyIGlzIHBhc3NlZCBhcm91bmQuXG5jb25zdCBsb2dnZXIgPSB7XG4gIGluZm86IGNvbnNvbGUubG9nLFxuICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgd2FybjogY29uc29sZS53YXJuLFxufTtcblxuLy8gVGhlIGluLW1lbW9yeSBtYXAgaXMgbm93IHJlbW92ZWQuIExvZ2ljIGlzIGRlbGVnYXRlZCB0byBkYlNlcnZpY2UuXG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzdG9yZVBlbmRpbmdSZXF1ZXN0KFxuICBqb2JJbmZvOiBQZW5kaW5nUmVxdWVzdEluZm9cbik6IFByb21pc2U8dm9pZD4ge1xuICBsb2dnZXIuaW5mbyhcbiAgICBgW3NoYXJlZEFnZW50U3RhdGUuc3RvcmVQZW5kaW5nUmVxdWVzdF0gU3RvcmluZyBqb2Igd2l0aCBmaWxlS2V5OiAke2pvYkluZm8uZmlsZUtleX1gXG4gICk7XG4gIHRyeSB7XG4gICAgLy8gVGhlIGFkZFBlbmRpbmdKb2IgZnVuY3Rpb24gaW4gZGJTZXJ2aWNlIGV4cGVjdHMgYSBQZW5kaW5nUmVxdWVzdEluZm8gb2JqZWN0XG4gICAgLy8gdGhhdCBhbGlnbnMgd2l0aCB0aGUgREIgc2NoZW1hIChlLmcuLCBzdWJtaXR0ZWRBdCBzaG91bGQgYmUgRGF0ZSBvciBJU08gc3RyaW5nKS5cbiAgICAvLyBUaGUgc3RhdHVzIGlzIGhhbmRsZWQgYnkgZGJTZXJ2aWNlIGludGVybmFsbHkgKGRlZmF1bHRzIHRvICdQRU5ESU5HJykuXG4gICAgYXdhaXQgYWRkUGVuZGluZ0pvYihqb2JJbmZvKTtcbiAgICBsb2dnZXIuaW5mbyhcbiAgICAgIGBbc2hhcmVkQWdlbnRTdGF0ZS5zdG9yZVBlbmRpbmdSZXF1ZXN0XSBTdWNjZXNzZnVsbHkgc3RvcmVkIGpvYiB3aXRoIGZpbGVLZXk6ICR7am9iSW5mby5maWxlS2V5fWBcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihcbiAgICAgIGBbc2hhcmVkQWdlbnRTdGF0ZS5zdG9yZVBlbmRpbmdSZXF1ZXN0XSBFcnJvciBzdG9yaW5nIGpvYiB3aXRoIGZpbGVLZXkgJHtqb2JJbmZvLmZpbGVLZXl9OmAsXG4gICAgICBlcnJvclxuICAgICk7XG4gICAgLy8gUmUtdGhyb3cgb3IgaGFuZGxlIGFzIGFwcHJvcHJpYXRlIGZvciB0aGUgYXBwbGljYXRpb24ncyBlcnJvciBoYW5kbGluZyBzdHJhdGVneVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyaWV2ZVBlbmRpbmdSZXF1ZXN0KFxuICBmaWxlS2V5OiBzdHJpbmdcbik6IFByb21pc2U8UGVuZGluZ1JlcXVlc3RJbmZvIHwgbnVsbD4ge1xuICBsb2dnZXIuaW5mbyhcbiAgICBgW3NoYXJlZEFnZW50U3RhdGUucmV0cmlldmVQZW5kaW5nUmVxdWVzdF0gUmV0cmlldmluZyBqb2Igd2l0aCBmaWxlS2V5OiAke2ZpbGVLZXl9YFxuICApO1xuICB0cnkge1xuICAgIC8vIGdldFBlbmRpbmdKb2IgZnJvbSBkYlNlcnZpY2UgcmV0dXJucyBQZW5kaW5nUmVxdWVzdEluZm8gfCBudWxsXG4gICAgLy8gYW5kIHNwZWNpZmljYWxseSBmZXRjaGVzIGpvYnMgd2l0aCBzdGF0dXMgPSAnUEVORElORycuXG4gICAgY29uc3Qgam9iSW5mbyA9IGF3YWl0IGdldFBlbmRpbmdKb2IoZmlsZUtleSk7XG4gICAgaWYgKGpvYkluZm8pIHtcbiAgICAgIGxvZ2dlci5pbmZvKFxuICAgICAgICBgW3NoYXJlZEFnZW50U3RhdGUucmV0cmlldmVQZW5kaW5nUmVxdWVzdF0gU3VjY2Vzc2Z1bGx5IHJldHJpZXZlZCBqb2Igd2l0aCBmaWxlS2V5OiAke2ZpbGVLZXl9YFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nZ2VyLmluZm8oXG4gICAgICAgIGBbc2hhcmVkQWdlbnRTdGF0ZS5yZXRyaWV2ZVBlbmRpbmdSZXF1ZXN0XSBObyAnUEVORElORycgam9iIGZvdW5kIHdpdGggZmlsZUtleTogJHtmaWxlS2V5fWBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBqb2JJbmZvO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZ2dlci5lcnJvcihcbiAgICAgIGBbc2hhcmVkQWdlbnRTdGF0ZS5yZXRyaWV2ZVBlbmRpbmdSZXF1ZXN0XSBFcnJvciByZXRyaWV2aW5nIGpvYiB3aXRoIGZpbGVLZXkgJHtmaWxlS2V5fTpgLFxuICAgICAgZXJyb3JcbiAgICApO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZW1vdmVQZW5kaW5nUmVxdWVzdChmaWxlS2V5OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgbG9nZ2VyLmluZm8oXG4gICAgYFtzaGFyZWRBZ2VudFN0YXRlLnJlbW92ZVBlbmRpbmdSZXF1ZXN0XSBSZW1vdmluZyBqb2Igd2l0aCBmaWxlS2V5OiAke2ZpbGVLZXl9YFxuICApO1xuICB0cnkge1xuICAgIGF3YWl0IGRlbGV0ZVBlbmRpbmdKb2IoZmlsZUtleSk7XG4gICAgLy8gZGVsZXRlUGVuZGluZ0pvYiBpbiBkYlNlcnZpY2UgYWxyZWFkeSBsb2dzIHN1Y2Nlc3MvZmFpbHVyZSB0byBkZWxldGUuXG4gICAgLy8gTm8gc3BlY2lmaWMgc3VjY2VzcyBjb25maXJtYXRpb24gbmVlZGVkIGhlcmUgdW5sZXNzIGRpZmZlcmVudCBsb2dpYyBpcyByZXF1aXJlZC5cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2dnZXIuZXJyb3IoXG4gICAgICBgW3NoYXJlZEFnZW50U3RhdGUucmVtb3ZlUGVuZGluZ1JlcXVlc3RdIEVycm9yIHJlbW92aW5nIGpvYiB3aXRoIGZpbGVLZXkgJHtmaWxlS2V5fTpgLFxuICAgICAgZXJyb3JcbiAgICApO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIE9wdGlvbmFsOiBFeHBvc2Ugc3RhdHVzIHVwZGF0ZSBpZiBuZWVkZWQgYnkgYXBwbGljYXRpb24gbG9naWMgZGlyZWN0bHkgdGhyb3VnaCBzaGFyZWRBZ2VudFN0YXRlXG4vLyBpbXBvcnQgeyB1cGRhdGVQZW5kaW5nSm9iU3RhdHVzIGFzIGRiVXBkYXRlU3RhdHVzIH0gZnJvbSAnLi4vX3V0aWxzL2RiU2VydmljZSc7IC8vIEFsaWFzIGlmIG5lZWRlZFxuLy8gZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVN0YXR1c0ZvclBlbmRpbmdSZXF1ZXN0KGZpbGVLZXk6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbi8vICAgbG9nZ2VyLmluZm8oYFtzaGFyZWRBZ2VudFN0YXRlLnVwZGF0ZVN0YXR1c0ZvclBlbmRpbmdSZXF1ZXN0XSBVcGRhdGluZyBzdGF0dXMgdG8gJyR7c3RhdHVzfScgZm9yIGZpbGVLZXk6ICR7ZmlsZUtleX1gKTtcbi8vICAgdHJ5IHtcbi8vICAgICBhd2FpdCBkYlVwZGF0ZVN0YXR1cyhmaWxlS2V5LCBzdGF0dXMpO1xuLy8gICB9IGNhdGNoIChlcnJvcikge1xuLy8gICAgIGxvZ2dlci5lcnJvcihgW3NoYXJlZEFnZW50U3RhdGUudXBkYXRlU3RhdHVzRm9yUGVuZGluZ1JlcXVlc3RdIEVycm9yIHVwZGF0aW5nIHN0YXR1cyBmb3IgZmlsZUtleSAke2ZpbGVLZXl9OmAsIGVycm9yKTtcbi8vICAgICB0aHJvdyBlcnJvcjtcbi8vICAgfVxuLy8gfVxuXG4vLyAoQ291bGQgYWRkIG90aGVyIHNoYXJlZCBzdGF0ZSBtYW5hZ2VtZW50IGZ1bmN0aW9ucyBoZXJlIGluIHRoZSBmdXR1cmUgaWYgbmVlZGVkKVxuIl19