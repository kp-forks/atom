// Manages the state of the conversation with the Atom agent
const IDLE_TIMEOUT_MS = 30 * 1000; // 30 seconds
const MAX_TURN_HISTORY_LENGTH = 10; // Limit for STM turn history
// In-memory store for conversation states, keyed by InterfaceType.
const conversationStates = new Map();
function getOrCreateConversationState(interfaceType) {
    if (!conversationStates.has(interfaceType)) {
        conversationStates.set(interfaceType, {
            isActive: false,
            isAgentResponding: false,
            lastInteractionTime: null,
            conversationHistory: [],
            idleTimer: null,
            currentIntent: null,
            identifiedEntities: null,
            userGoal: null,
            turnHistory: [],
            ltmContext: null,
        });
    }
    return conversationStates.get(interfaceType);
}
function log(interfaceType, message) {
    console.log(`[ConversationState][${interfaceType}] ${new Date().toISOString()}: ${message}`);
}
export function getConversationStateSnapshot(interfaceType) {
    const state = getOrCreateConversationState(interfaceType);
    // Return a copy to prevent direct modification of the state object
    return JSON.parse(JSON.stringify(state));
}
function clearIdleTimer(interfaceType) {
    const state = getOrCreateConversationState(interfaceType);
    if (state.idleTimer) {
        clearTimeout(state.idleTimer);
        state.idleTimer = null;
    }
}
export function setAgentResponding(interfaceType, isResponding) {
    const state = getOrCreateConversationState(interfaceType);
    state.isAgentResponding = isResponding;
    log(interfaceType, `Agent responding state set to: ${isResponding}`);
    if (isResponding) {
        // If agent starts responding, we might want to temporarily pause the idle timer,
        // or handle it such that user can interrupt without idle timeout issues.
        // For now, an explicit interrupt signal will be the primary mechanism.
        // clearIdleTimer(interfaceType); // Option: clear idle timer when agent starts responding
    }
    else {
        // If agent finished responding and conversation is still active, restart idle timer
        if (state.isActive) {
            startIdleTimer(interfaceType);
        }
    }
}
export function checkIfAgentIsResponding(interfaceType) {
    const state = getOrCreateConversationState(interfaceType);
    return state.isAgentResponding;
}
export function deactivateConversation(interfaceType, reason = 'timeout') {
    clearIdleTimer(interfaceType);
    const state = getOrCreateConversationState(interfaceType);
    if (state.isActive || state.isAgentResponding) {
        state.isActive = false;
        state.isAgentResponding = false; // Ensure this is also reset
        state.lastInteractionTime = null;
        state.ltmContext = null; // Reset LTM context
        log(interfaceType, `Conversation deactivated due to ${reason}. LTM context cleared.`);
    }
}
function startIdleTimer(interfaceType) {
    clearIdleTimer(interfaceType);
    const state = getOrCreateConversationState(interfaceType);
    // Only start idle timer if agent is NOT responding, and conversation IS active
    if (!state.isAgentResponding && state.isActive) {
        state.idleTimer = setTimeout(() => {
            const currentState = getOrCreateConversationState(interfaceType); // Re-fetch current state
            if (currentState.isActive && !currentState.isAgentResponding) {
                // Double check state
                deactivateConversation(interfaceType, 'idle_timeout');
            }
        }, IDLE_TIMEOUT_MS);
        log(interfaceType, `Idle timer started for ${IDLE_TIMEOUT_MS / 1000} seconds.`);
    }
    else if (state.isAgentResponding) {
        log(interfaceType, 'Idle timer not started because agent is currently responding.');
    }
    else if (!state.isActive) {
        log(interfaceType, 'Idle timer not started because conversation is not active.');
    }
}
export function activateConversation(interfaceType) {
    const state = getOrCreateConversationState(interfaceType);
    const wasActive = state.isActive;
    state.isActive = true;
    state.isAgentResponding = false; // Agent is not responding at point of activation
    state.lastInteractionTime = Date.now();
    state.ltmContext = null; // Reset LTM context on new activation
    startIdleTimer(interfaceType);
    if (!wasActive) {
        log(interfaceType, 'Conversation activated. LTM context cleared.');
        return { status: 'Conversation activated.', active: true };
    }
    else {
        log(interfaceType, 'Conversation was already active. Interaction time and timer reset. Agent responding state ensured false. LTM context cleared.');
        return {
            status: 'Conversation was already active. State reset for new interaction.',
            active: true,
        };
    }
}
export function recordUserInteraction(interfaceType, text) {
    const state = getOrCreateConversationState(interfaceType);
    if (!state.isActive) {
        log(interfaceType, "Interaction recorded (text received) while conversation is inactive. This shouldn't lead to processing by agent logic.");
        return; // Don't update interaction time or restart timer if not active
    }
    // If user speaks, it implies they are interrupting or starting new turn.
    // Agent should no longer be considered "responding" from this point for this new input.
    // However, the /interrupt endpoint is the more explicit way to stop agent actions.
    // This function primarily resets the idle timer for the user's current speech.
    state.lastInteractionTime = Date.now();
    startIdleTimer(interfaceType);
    log(interfaceType, `User interaction recorded. Time and timer reset. Text: "${text.substring(0, 50)}..."`);
}
export function recordAgentResponse(interfaceType, userText, agentResponse, intent, entities) {
    const state = getOrCreateConversationState(interfaceType);
    // Record to existing conversationHistory
    state.conversationHistory.push({
        user: userText,
        agent: agentResponse,
        timestamp: Date.now(),
    });
    if (state.conversationHistory.length > 20) {
        // Existing limit
        state.conversationHistory.shift();
    }
    log(interfaceType, 'Agent response recorded in detailed history.');
    // Update new turnHistory for STM
    const turn = {
        userInput: userText,
        agentResponse: agentResponse, // Or a summary/specific part of it
        intent: intent,
        entities: entities,
        timestamp: Date.now(),
    };
    state.turnHistory.push(turn);
    if (state.turnHistory.length > MAX_TURN_HISTORY_LENGTH) {
        state.turnHistory.shift();
    }
    log(interfaceType, `Turn recorded in STM history. Current STM history length: ${state.turnHistory.length}`);
    // Potentially update currentIntent and identifiedEntities from the latest turn
    if (intent) {
        state.currentIntent = intent;
        log(interfaceType, `Current intent updated to: ${intent}`);
    }
    if (entities) {
        state.identifiedEntities = entities;
        log(interfaceType, `Identified entities updated.`);
    }
}
export function updateIntentAndEntities(interfaceType, intent, entities) {
    const state = getOrCreateConversationState(interfaceType);
    state.currentIntent = intent;
    state.identifiedEntities = entities;
    log(interfaceType, `Intent and entities updated: Intent - ${intent}, Entities - ${JSON.stringify(entities)}`);
}
export function updateUserGoal(interfaceType, goal) {
    const state = getOrCreateConversationState(interfaceType);
    state.userGoal = goal;
    log(interfaceType, `User goal updated to: ${goal}`);
}
export function updateLTMContext(interfaceType, context) {
    const state = getOrCreateConversationState(interfaceType);
    state.ltmContext = context;
    if (context) {
        log(interfaceType, `LTM context updated with ${context.length} items.`);
    }
    else {
        log(interfaceType, 'LTM context cleared.');
    }
}
export function isConversationActive(interfaceType) {
    const state = getOrCreateConversationState(interfaceType);
    return state.isActive;
}
export function getConversationHistory(interfaceType) {
    const state = getOrCreateConversationState(interfaceType);
    return state.conversationHistory;
}
// Example of how to expose a function to manually set state for testing (as requested)
// This would typically be part of a testing setup, not production code.
export function _test_setConversationActive(interfaceType, active) {
    if (active) {
        activateConversation(interfaceType);
    }
    else {
        deactivateConversation(interfaceType, 'manual test override');
    }
    log(interfaceType, `Conversation state manually set to active: ${active} for testing.`);
}
log('text', 'Conversation state manager initialized for text interface.');
log('voice', 'Conversation state manager initialized for voice interface.');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udmVyc2F0aW9uU3RhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjb252ZXJzYXRpb25TdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw0REFBNEQ7QUFJNUQsTUFBTSxlQUFlLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxDQUFDLGFBQWE7QUFDaEQsTUFBTSx1QkFBdUIsR0FBRyxFQUFFLENBQUMsQ0FBQyw2QkFBNkI7QUE2QmpFLG1FQUFtRTtBQUNuRSxNQUFNLGtCQUFrQixHQUFHLElBQUksR0FBRyxFQUFvQyxDQUFDO0FBRXZFLFNBQVMsNEJBQTRCLENBQ25DLGFBQTRCO0lBRTVCLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQztRQUMzQyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFO1lBQ3BDLFFBQVEsRUFBRSxLQUFLO1lBQ2YsaUJBQWlCLEVBQUUsS0FBSztZQUN4QixtQkFBbUIsRUFBRSxJQUFJO1lBQ3pCLG1CQUFtQixFQUFFLEVBQUU7WUFDdkIsU0FBUyxFQUFFLElBQUk7WUFDZixhQUFhLEVBQUUsSUFBSTtZQUNuQixrQkFBa0IsRUFBRSxJQUFJO1lBQ3hCLFFBQVEsRUFBRSxJQUFJO1lBQ2QsV0FBVyxFQUFFLEVBQUU7WUFDZixVQUFVLEVBQUUsSUFBSTtTQUNqQixDQUFDLENBQUM7SUFDTCxDQUFDO0lBQ0QsT0FBTyxrQkFBa0IsQ0FBQyxHQUFHLENBQUMsYUFBYSxDQUFFLENBQUM7QUFDaEQsQ0FBQztBQUVELFNBQVMsR0FBRyxDQUFDLGFBQTRCLEVBQUUsT0FBZTtJQUN4RCxPQUFPLENBQUMsR0FBRyxDQUNULHVCQUF1QixhQUFhLEtBQUssSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLEVBQUUsQ0FDaEYsQ0FBQztBQUNKLENBQUM7QUFFRCxNQUFNLFVBQVUsNEJBQTRCLENBQzFDLGFBQTRCO0lBRTVCLE1BQU0sS0FB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QUFDO0lBQ2hFLENBQUM7SUFDRCxHQUFHLENBQ0QsYUFBYSxFQUNiLDhDQUE4QyxNQUFNLGVBQWUsQ0FDcEUsQ0FBQztBQUNKLENBQUM7QUFFRCxHQUFHLENBQUMsTUFBTSxFQUFFLDREQUE0RCxDQUFDLENBQUM7QUFDMUUsR0FBRyxDQUFDLE9BQU8sRUFBRSw2REFBNkQsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTWFuYWdlcyB0aGUgc3RhdGUgb2YgdGhlIGNvbnZlcnNhdGlvbiB3aXRoIHRoZSBBdG9tIGFnZW50XG5cbmltcG9ydCB7IEhhbmRsZU1lc3NhZ2VSZXNwb25zZSB9IGZyb20gJy4vaGFuZGxlcic7IC8vIEFzc3VtaW5nIGhhbmRsZXIudHMgZXhwb3J0cyB0aGlzXG5cbmNvbnN0IElETEVfVElNRU9VVF9NUyA9IDMwICogMTAwMDsgLy8gMzAgc2Vjb25kc1xuY29uc3QgTUFYX1RVUk5fSElTVE9SWV9MRU5HVEggPSAxMDsgLy8gTGltaXQgZm9yIFNUTSB0dXJuIGhpc3RvcnlcblxuZXhwb3J0IHR5cGUgSW50ZXJmYWNlVHlwZSA9ICd0ZXh0JyB8ICd2b2ljZSc7XG5cbmludGVyZmFjZSBDb252ZXJzYXRpb25TdGF0ZSB7XG4gIGlzQWN0aXZlOiBib29sZWFuO1xuICBpc0FnZW50UmVzcG9uZGluZzogYm9vbGVhbjsgLy8gTmV3IHN0YXRlOiB0cnVlIGlmIGFnZW50IGlzIGN1cnJlbnRseSBcInNwZWFraW5nXCIgb3IgcHJvY2Vzc2luZyBhIHJlc3BvbnNlXG4gIGxhc3RJbnRlcmFjdGlvblRpbWU6IG51bWJlciB8IG51bGw7XG4gIGNvbnZlcnNhdGlvbkhpc3Rvcnk6IEFycmF5PHtcbiAgICB1c2VyOiBzdHJpbmc7XG4gICAgYWdlbnQ6IEhhbmRsZU1lc3NhZ2VSZXNwb25zZTtcbiAgICB0aW1lc3RhbXA6IG51bWJlcjtcbiAgfT47IC8vIFJldGFpbmVkIGZvciBleGlzdGluZyBkZXRhaWxlZCBoaXN0b3J5XG4gIGlkbGVUaW1lcjogTm9kZUpTLlRpbWVvdXQgfCBudWxsO1xuXG4gIC8vIE5ldyBTVE0gZmllbGRzXG4gIGN1cnJlbnRJbnRlbnQ6IHN0cmluZyB8IG51bGw7XG4gIGlkZW50aWZpZWRFbnRpdGllczogUmVjb3JkPHN0cmluZywgYW55PiB8IG51bGw7XG4gIHVzZXJHb2FsOiBzdHJpbmcgfCBudWxsO1xuICB0dXJuSGlzdG9yeTogQXJyYXk8e1xuICAgIHVzZXJJbnB1dDogc3RyaW5nO1xuICAgIGFnZW50UmVzcG9uc2U6IGFueTsgLy8gQ29uc2lkZXIgdXNpbmcgYSBtb3JlIHNwZWNpZmljIHR5cGUgaWYgYXZhaWxhYmxlLCBsaWtlIEhhbmRsZU1lc3NhZ2VSZXNwb25zZVxuICAgIGludGVudD86IHN0cmluZztcbiAgICBlbnRpdGllcz86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gICAgdGltZXN0YW1wOiBudW1iZXI7XG4gIH0+O1xuICBsdG1Db250ZXh0OiBhbnlbXSB8IG51bGw7IC8vIEZvciBzdG9yaW5nIHJlc3VsdHMgZnJvbSBMVE0gcXVlcmllc1xufVxuXG4vLyBJbi1tZW1vcnkgc3RvcmUgZm9yIGNvbnZlcnNhdGlvbiBzdGF0ZXMsIGtleWVkIGJ5IEludGVyZmFjZVR5cGUuXG5jb25zdCBjb252ZXJzYXRpb25TdGF0ZXMgPSBuZXcgTWFwPEludGVyZmFjZVR5cGUsIENvbnZlcnNhdGlvblN0YXRlPigpO1xuXG5mdW5jdGlvbiBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKFxuICBpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlXG4pOiBDb252ZXJzYXRpb25TdGF0ZSB7XG4gIGlmICghY29udmVyc2F0aW9uU3RhdGVzLmhhcyhpbnRlcmZhY2VUeXBlKSkge1xuICAgIGNvbnZlcnNhdGlvblN0YXRlcy5zZXQoaW50ZXJmYWNlVHlwZSwge1xuICAgICAgaXNBY3RpdmU6IGZhbHNlLFxuICAgICAgaXNBZ2VudFJlc3BvbmRpbmc6IGZhbHNlLFxuICAgICAgbGFzdEludGVyYWN0aW9uVGltZTogbnVsbCxcbiAgICAgIGNvbnZlcnNhdGlvbkhpc3Rvcnk6IFtdLFxuICAgICAgaWRsZVRpbWVyOiBudWxsLFxuICAgICAgY3VycmVudEludGVudDogbnVsbCxcbiAgICAgIGlkZW50aWZpZWRFbnRpdGllczogbnVsbCxcbiAgICAgIHVzZXJHb2FsOiBudWxsLFxuICAgICAgdHVybkhpc3Rvcnk6IFtdLFxuICAgICAgbHRtQ29udGV4dDogbnVsbCxcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29udmVyc2F0aW9uU3RhdGVzLmdldChpbnRlcmZhY2VUeXBlKSE7XG59XG5cbmZ1bmN0aW9uIGxvZyhpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlLCBtZXNzYWdlOiBzdHJpbmcpIHtcbiAgY29uc29sZS5sb2coXG4gICAgYFtDb252ZXJzYXRpb25TdGF0ZV1bJHtpbnRlcmZhY2VUeXBlfV0gJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9OiAke21lc3NhZ2V9YFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uU3RhdGVTbmFwc2hvdChcbiAgaW50ZXJmYWNlVHlwZTogSW50ZXJmYWNlVHlwZVxuKTogUmVhZG9ubHk8Q29udmVyc2F0aW9uU3RhdGU+IHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKGludGVyZmFjZVR5cGUpO1xuICAvLyBSZXR1cm4gYSBjb3B5IHRvIHByZXZlbnQgZGlyZWN0IG1vZGlmaWNhdGlvbiBvZiB0aGUgc3RhdGUgb2JqZWN0XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHN0YXRlKSk7XG59XG5cbmZ1bmN0aW9uIGNsZWFySWRsZVRpbWVyKGludGVyZmFjZVR5cGU6IEludGVyZmFjZVR5cGUpIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKGludGVyZmFjZVR5cGUpO1xuICBpZiAoc3RhdGUuaWRsZVRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHN0YXRlLmlkbGVUaW1lcik7XG4gICAgc3RhdGUuaWRsZVRpbWVyID0gbnVsbDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0QWdlbnRSZXNwb25kaW5nKFxuICBpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlLFxuICBpc1Jlc3BvbmRpbmc6IGJvb2xlYW5cbikge1xuICBjb25zdCBzdGF0ZSA9IGdldE9yQ3JlYXRlQ29udmVyc2F0aW9uU3RhdGUoaW50ZXJmYWNlVHlwZSk7XG4gIHN0YXRlLmlzQWdlbnRSZXNwb25kaW5nID0gaXNSZXNwb25kaW5nO1xuICBsb2coaW50ZXJmYWNlVHlwZSwgYEFnZW50IHJlc3BvbmRpbmcgc3RhdGUgc2V0IHRvOiAke2lzUmVzcG9uZGluZ31gKTtcbiAgaWYgKGlzUmVzcG9uZGluZykge1xuICAgIC8vIElmIGFnZW50IHN0YXJ0cyByZXNwb25kaW5nLCB3ZSBtaWdodCB3YW50IHRvIHRlbXBvcmFyaWx5IHBhdXNlIHRoZSBpZGxlIHRpbWVyLFxuICAgIC8vIG9yIGhhbmRsZSBpdCBzdWNoIHRoYXQgdXNlciBjYW4gaW50ZXJydXB0IHdpdGhvdXQgaWRsZSB0aW1lb3V0IGlzc3Vlcy5cbiAgICAvLyBGb3Igbm93LCBhbiBleHBsaWNpdCBpbnRlcnJ1cHQgc2lnbmFsIHdpbGwgYmUgdGhlIHByaW1hcnkgbWVjaGFuaXNtLlxuICAgIC8vIGNsZWFySWRsZVRpbWVyKGludGVyZmFjZVR5cGUpOyAvLyBPcHRpb246IGNsZWFyIGlkbGUgdGltZXIgd2hlbiBhZ2VudCBzdGFydHMgcmVzcG9uZGluZ1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFnZW50IGZpbmlzaGVkIHJlc3BvbmRpbmcgYW5kIGNvbnZlcnNhdGlvbiBpcyBzdGlsbCBhY3RpdmUsIHJlc3RhcnQgaWRsZSB0aW1lclxuICAgIGlmIChzdGF0ZS5pc0FjdGl2ZSkge1xuICAgICAgc3RhcnRJZGxlVGltZXIoaW50ZXJmYWNlVHlwZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0lmQWdlbnRJc1Jlc3BvbmRpbmcoXG4gIGludGVyZmFjZVR5cGU6IEludGVyZmFjZVR5cGVcbik6IGJvb2xlYW4ge1xuICBjb25zdCBzdGF0ZSA9IGdldE9yQ3JlYXRlQ29udmVyc2F0aW9uU3RhdGUoaW50ZXJmYWNlVHlwZSk7XG4gIHJldHVybiBzdGF0ZS5pc0FnZW50UmVzcG9uZGluZztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYWN0aXZhdGVDb252ZXJzYXRpb24oXG4gIGludGVyZmFjZVR5cGU6IEludGVyZmFjZVR5cGUsXG4gIHJlYXNvbjogc3RyaW5nID0gJ3RpbWVvdXQnXG4pIHtcbiAgY2xlYXJJZGxlVGltZXIoaW50ZXJmYWNlVHlwZSk7XG4gIGNvbnN0IHN0YXRlID0gZ2V0T3JDcmVhdGVDb252ZXJzYXRpb25TdGF0ZShpbnRlcmZhY2VUeXBlKTtcbiAgaWYgKHN0YXRlLmlzQWN0aXZlIHx8IHN0YXRlLmlzQWdlbnRSZXNwb25kaW5nKSB7XG4gICAgc3RhdGUuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5pc0FnZW50UmVzcG9uZGluZyA9IGZhbHNlOyAvLyBFbnN1cmUgdGhpcyBpcyBhbHNvIHJlc2V0XG4gICAgc3RhdGUubGFzdEludGVyYWN0aW9uVGltZSA9IG51bGw7XG4gICAgc3RhdGUubHRtQ29udGV4dCA9IG51bGw7IC8vIFJlc2V0IExUTSBjb250ZXh0XG4gICAgbG9nKFxuICAgICAgaW50ZXJmYWNlVHlwZSxcbiAgICAgIGBDb252ZXJzYXRpb24gZGVhY3RpdmF0ZWQgZHVlIHRvICR7cmVhc29ufS4gTFRNIGNvbnRleHQgY2xlYXJlZC5gXG4gICAgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydElkbGVUaW1lcihpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlKSB7XG4gIGNsZWFySWRsZVRpbWVyKGludGVyZmFjZVR5cGUpO1xuICBjb25zdCBzdGF0ZSA9IGdldE9yQ3JlYXRlQ29udmVyc2F0aW9uU3RhdGUoaW50ZXJmYWNlVHlwZSk7XG4gIC8vIE9ubHkgc3RhcnQgaWRsZSB0aW1lciBpZiBhZ2VudCBpcyBOT1QgcmVzcG9uZGluZywgYW5kIGNvbnZlcnNhdGlvbiBJUyBhY3RpdmVcbiAgaWYgKCFzdGF0ZS5pc0FnZW50UmVzcG9uZGluZyAmJiBzdGF0ZS5pc0FjdGl2ZSkge1xuICAgIHN0YXRlLmlkbGVUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgY29uc3QgY3VycmVudFN0YXRlID0gZ2V0T3JDcmVhdGVDb252ZXJzYXRpb25TdGF0ZShpbnRlcmZhY2VUeXBlKTsgLy8gUmUtZmV0Y2ggY3VycmVudCBzdGF0ZVxuICAgICAgaWYgKGN1cnJlbnRTdGF0ZS5pc0FjdGl2ZSAmJiAhY3VycmVudFN0YXRlLmlzQWdlbnRSZXNwb25kaW5nKSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayBzdGF0ZVxuICAgICAgICBkZWFjdGl2YXRlQ29udmVyc2F0aW9uKGludGVyZmFjZVR5cGUsICdpZGxlX3RpbWVvdXQnKTtcbiAgICAgIH1cbiAgICB9LCBJRExFX1RJTUVPVVRfTVMpO1xuICAgIGxvZyhcbiAgICAgIGludGVyZmFjZVR5cGUsXG4gICAgICBgSWRsZSB0aW1lciBzdGFydGVkIGZvciAke0lETEVfVElNRU9VVF9NUyAvIDEwMDB9IHNlY29uZHMuYFxuICAgICk7XG4gIH0gZWxzZSBpZiAoc3RhdGUuaXNBZ2VudFJlc3BvbmRpbmcpIHtcbiAgICBsb2coXG4gICAgICBpbnRlcmZhY2VUeXBlLFxuICAgICAgJ0lkbGUgdGltZXIgbm90IHN0YXJ0ZWQgYmVjYXVzZSBhZ2VudCBpcyBjdXJyZW50bHkgcmVzcG9uZGluZy4nXG4gICAgKTtcbiAgfSBlbHNlIGlmICghc3RhdGUuaXNBY3RpdmUpIHtcbiAgICBsb2coXG4gICAgICBpbnRlcmZhY2VUeXBlLFxuICAgICAgJ0lkbGUgdGltZXIgbm90IHN0YXJ0ZWQgYmVjYXVzZSBjb252ZXJzYXRpb24gaXMgbm90IGFjdGl2ZS4nXG4gICAgKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWN0aXZhdGVDb252ZXJzYXRpb24oaW50ZXJmYWNlVHlwZTogSW50ZXJmYWNlVHlwZSk6IHtcbiAgc3RhdHVzOiBzdHJpbmc7XG4gIGFjdGl2ZTogYm9vbGVhbjtcbn0ge1xuICBjb25zdCBzdGF0ZSA9IGdldE9yQ3JlYXRlQ29udmVyc2F0aW9uU3RhdGUoaW50ZXJmYWNlVHlwZSk7XG4gIGNvbnN0IHdhc0FjdGl2ZSA9IHN0YXRlLmlzQWN0aXZlO1xuICBzdGF0ZS5pc0FjdGl2ZSA9IHRydWU7XG4gIHN0YXRlLmlzQWdlbnRSZXNwb25kaW5nID0gZmFsc2U7IC8vIEFnZW50IGlzIG5vdCByZXNwb25kaW5nIGF0IHBvaW50IG9mIGFjdGl2YXRpb25cbiAgc3RhdGUubGFzdEludGVyYWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gIHN0YXRlLmx0bUNvbnRleHQgPSBudWxsOyAvLyBSZXNldCBMVE0gY29udGV4dCBvbiBuZXcgYWN0aXZhdGlvblxuICBzdGFydElkbGVUaW1lcihpbnRlcmZhY2VUeXBlKTtcblxuICBpZiAoIXdhc0FjdGl2ZSkge1xuICAgIGxvZyhpbnRlcmZhY2VUeXBlLCAnQ29udmVyc2F0aW9uIGFjdGl2YXRlZC4gTFRNIGNvbnRleHQgY2xlYXJlZC4nKTtcbiAgICByZXR1cm4geyBzdGF0dXM6ICdDb252ZXJzYXRpb24gYWN0aXZhdGVkLicsIGFjdGl2ZTogdHJ1ZSB9O1xuICB9IGVsc2Uge1xuICAgIGxvZyhcbiAgICAgIGludGVyZmFjZVR5cGUsXG4gICAgICAnQ29udmVyc2F0aW9uIHdhcyBhbHJlYWR5IGFjdGl2ZS4gSW50ZXJhY3Rpb24gdGltZSBhbmQgdGltZXIgcmVzZXQuIEFnZW50IHJlc3BvbmRpbmcgc3RhdGUgZW5zdXJlZCBmYWxzZS4gTFRNIGNvbnRleHQgY2xlYXJlZC4nXG4gICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOlxuICAgICAgICAnQ29udmVyc2F0aW9uIHdhcyBhbHJlYWR5IGFjdGl2ZS4gU3RhdGUgcmVzZXQgZm9yIG5ldyBpbnRlcmFjdGlvbi4nLFxuICAgICAgYWN0aXZlOiB0cnVlLFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY29yZFVzZXJJbnRlcmFjdGlvbihcbiAgaW50ZXJmYWNlVHlwZTogSW50ZXJmYWNlVHlwZSxcbiAgdGV4dDogc3RyaW5nXG4pIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKGludGVyZmFjZVR5cGUpO1xuICBpZiAoIXN0YXRlLmlzQWN0aXZlKSB7XG4gICAgbG9nKFxuICAgICAgaW50ZXJmYWNlVHlwZSxcbiAgICAgIFwiSW50ZXJhY3Rpb24gcmVjb3JkZWQgKHRleHQgcmVjZWl2ZWQpIHdoaWxlIGNvbnZlcnNhdGlvbiBpcyBpbmFjdGl2ZS4gVGhpcyBzaG91bGRuJ3QgbGVhZCB0byBwcm9jZXNzaW5nIGJ5IGFnZW50IGxvZ2ljLlwiXG4gICAgKTtcbiAgICByZXR1cm47IC8vIERvbid0IHVwZGF0ZSBpbnRlcmFjdGlvbiB0aW1lIG9yIHJlc3RhcnQgdGltZXIgaWYgbm90IGFjdGl2ZVxuICB9XG4gIC8vIElmIHVzZXIgc3BlYWtzLCBpdCBpbXBsaWVzIHRoZXkgYXJlIGludGVycnVwdGluZyBvciBzdGFydGluZyBuZXcgdHVybi5cbiAgLy8gQWdlbnQgc2hvdWxkIG5vIGxvbmdlciBiZSBjb25zaWRlcmVkIFwicmVzcG9uZGluZ1wiIGZyb20gdGhpcyBwb2ludCBmb3IgdGhpcyBuZXcgaW5wdXQuXG4gIC8vIEhvd2V2ZXIsIHRoZSAvaW50ZXJydXB0IGVuZHBvaW50IGlzIHRoZSBtb3JlIGV4cGxpY2l0IHdheSB0byBzdG9wIGFnZW50IGFjdGlvbnMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gcHJpbWFyaWx5IHJlc2V0cyB0aGUgaWRsZSB0aW1lciBmb3IgdGhlIHVzZXIncyBjdXJyZW50IHNwZWVjaC5cbiAgc3RhdGUubGFzdEludGVyYWN0aW9uVGltZSA9IERhdGUubm93KCk7XG4gIHN0YXJ0SWRsZVRpbWVyKGludGVyZmFjZVR5cGUpO1xuICBsb2coXG4gICAgaW50ZXJmYWNlVHlwZSxcbiAgICBgVXNlciBpbnRlcmFjdGlvbiByZWNvcmRlZC4gVGltZSBhbmQgdGltZXIgcmVzZXQuIFRleHQ6IFwiJHt0ZXh0LnN1YnN0cmluZygwLCA1MCl9Li4uXCJgXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWNvcmRBZ2VudFJlc3BvbnNlKFxuICBpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlLFxuICB1c2VyVGV4dDogc3RyaW5nLFxuICBhZ2VudFJlc3BvbnNlOiBIYW5kbGVNZXNzYWdlUmVzcG9uc2UsXG4gIGludGVudD86IHN0cmluZyxcbiAgZW50aXRpZXM/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+XG4pIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKGludGVyZmFjZVR5cGUpO1xuICAvLyBSZWNvcmQgdG8gZXhpc3RpbmcgY29udmVyc2F0aW9uSGlzdG9yeVxuICBzdGF0ZS5jb252ZXJzYXRpb25IaXN0b3J5LnB1c2goe1xuICAgIHVzZXI6IHVzZXJUZXh0LFxuICAgIGFnZW50OiBhZ2VudFJlc3BvbnNlLFxuICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgfSk7XG4gIGlmIChzdGF0ZS5jb252ZXJzYXRpb25IaXN0b3J5Lmxlbmd0aCA+IDIwKSB7XG4gICAgLy8gRXhpc3RpbmcgbGltaXRcbiAgICBzdGF0ZS5jb252ZXJzYXRpb25IaXN0b3J5LnNoaWZ0KCk7XG4gIH1cbiAgbG9nKGludGVyZmFjZVR5cGUsICdBZ2VudCByZXNwb25zZSByZWNvcmRlZCBpbiBkZXRhaWxlZCBoaXN0b3J5LicpO1xuXG4gIC8vIFVwZGF0ZSBuZXcgdHVybkhpc3RvcnkgZm9yIFNUTVxuICBjb25zdCB0dXJuID0ge1xuICAgIHVzZXJJbnB1dDogdXNlclRleHQsXG4gICAgYWdlbnRSZXNwb25zZTogYWdlbnRSZXNwb25zZSwgLy8gT3IgYSBzdW1tYXJ5L3NwZWNpZmljIHBhcnQgb2YgaXRcbiAgICBpbnRlbnQ6IGludGVudCxcbiAgICBlbnRpdGllczogZW50aXRpZXMsXG4gICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICB9O1xuICBzdGF0ZS50dXJuSGlzdG9yeS5wdXNoKHR1cm4pO1xuICBpZiAoc3RhdGUudHVybkhpc3RvcnkubGVuZ3RoID4gTUFYX1RVUk5fSElTVE9SWV9MRU5HVEgpIHtcbiAgICBzdGF0ZS50dXJuSGlzdG9yeS5zaGlmdCgpO1xuICB9XG4gIGxvZyhcbiAgICBpbnRlcmZhY2VUeXBlLFxuICAgIGBUdXJuIHJlY29yZGVkIGluIFNUTSBoaXN0b3J5LiBDdXJyZW50IFNUTSBoaXN0b3J5IGxlbmd0aDogJHtzdGF0ZS50dXJuSGlzdG9yeS5sZW5ndGh9YFxuICApO1xuXG4gIC8vIFBvdGVudGlhbGx5IHVwZGF0ZSBjdXJyZW50SW50ZW50IGFuZCBpZGVudGlmaWVkRW50aXRpZXMgZnJvbSB0aGUgbGF0ZXN0IHR1cm5cbiAgaWYgKGludGVudCkge1xuICAgIHN0YXRlLmN1cnJlbnRJbnRlbnQgPSBpbnRlbnQ7XG4gICAgbG9nKGludGVyZmFjZVR5cGUsIGBDdXJyZW50IGludGVudCB1cGRhdGVkIHRvOiAke2ludGVudH1gKTtcbiAgfVxuICBpZiAoZW50aXRpZXMpIHtcbiAgICBzdGF0ZS5pZGVudGlmaWVkRW50aXRpZXMgPSBlbnRpdGllcztcbiAgICBsb2coaW50ZXJmYWNlVHlwZSwgYElkZW50aWZpZWQgZW50aXRpZXMgdXBkYXRlZC5gKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlSW50ZW50QW5kRW50aXRpZXMoXG4gIGludGVyZmFjZVR5cGU6IEludGVyZmFjZVR5cGUsXG4gIGludGVudDogc3RyaW5nIHwgbnVsbCxcbiAgZW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCBudWxsXG4pIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKGludGVyZmFjZVR5cGUpO1xuICBzdGF0ZS5jdXJyZW50SW50ZW50ID0gaW50ZW50O1xuICBzdGF0ZS5pZGVudGlmaWVkRW50aXRpZXMgPSBlbnRpdGllcztcbiAgbG9nKFxuICAgIGludGVyZmFjZVR5cGUsXG4gICAgYEludGVudCBhbmQgZW50aXRpZXMgdXBkYXRlZDogSW50ZW50IC0gJHtpbnRlbnR9LCBFbnRpdGllcyAtICR7SlNPTi5zdHJpbmdpZnkoZW50aXRpZXMpfWBcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVVzZXJHb2FsKFxuICBpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlLFxuICBnb2FsOiBzdHJpbmcgfCBudWxsXG4pIHtcbiAgY29uc3Qgc3RhdGUgPSBnZXRPckNyZWF0ZUNvbnZlcnNhdGlvblN0YXRlKGludGVyZmFjZVR5cGUpO1xuICBzdGF0ZS51c2VyR29hbCA9IGdvYWw7XG4gIGxvZyhpbnRlcmZhY2VUeXBlLCBgVXNlciBnb2FsIHVwZGF0ZWQgdG86ICR7Z29hbH1gKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUxUTUNvbnRleHQoXG4gIGludGVyZmFjZVR5cGU6IEludGVyZmFjZVR5cGUsXG4gIGNvbnRleHQ6IGFueVtdIHwgbnVsbFxuKSB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0T3JDcmVhdGVDb252ZXJzYXRpb25TdGF0ZShpbnRlcmZhY2VUeXBlKTtcbiAgc3RhdGUubHRtQ29udGV4dCA9IGNvbnRleHQ7XG4gIGlmIChjb250ZXh0KSB7XG4gICAgbG9nKGludGVyZmFjZVR5cGUsIGBMVE0gY29udGV4dCB1cGRhdGVkIHdpdGggJHtjb250ZXh0Lmxlbmd0aH0gaXRlbXMuYCk7XG4gIH0gZWxzZSB7XG4gICAgbG9nKGludGVyZmFjZVR5cGUsICdMVE0gY29udGV4dCBjbGVhcmVkLicpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbnZlcnNhdGlvbkFjdGl2ZShpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0T3JDcmVhdGVDb252ZXJzYXRpb25TdGF0ZShpbnRlcmZhY2VUeXBlKTtcbiAgcmV0dXJuIHN0YXRlLmlzQWN0aXZlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29udmVyc2F0aW9uSGlzdG9yeShcbiAgaW50ZXJmYWNlVHlwZTogSW50ZXJmYWNlVHlwZVxuKTogUmVhZG9ubHk8XG4gIEFycmF5PHsgdXNlcjogc3RyaW5nOyBhZ2VudDogSGFuZGxlTWVzc2FnZVJlc3BvbnNlOyB0aW1lc3RhbXA6IG51bWJlciB9PlxuPiB7XG4gIGNvbnN0IHN0YXRlID0gZ2V0T3JDcmVhdGVDb252ZXJzYXRpb25TdGF0ZShpbnRlcmZhY2VUeXBlKTtcbiAgcmV0dXJuIHN0YXRlLmNvbnZlcnNhdGlvbkhpc3Rvcnk7XG59XG5cbi8vIEV4YW1wbGUgb2YgaG93IHRvIGV4cG9zZSBhIGZ1bmN0aW9uIHRvIG1hbnVhbGx5IHNldCBzdGF0ZSBmb3IgdGVzdGluZyAoYXMgcmVxdWVzdGVkKVxuLy8gVGhpcyB3b3VsZCB0eXBpY2FsbHkgYmUgcGFydCBvZiBhIHRlc3Rpbmcgc2V0dXAsIG5vdCBwcm9kdWN0aW9uIGNvZGUuXG5leHBvcnQgZnVuY3Rpb24gX3Rlc3Rfc2V0Q29udmVyc2F0aW9uQWN0aXZlKFxuICBpbnRlcmZhY2VUeXBlOiBJbnRlcmZhY2VUeXBlLFxuICBhY3RpdmU6IGJvb2xlYW5cbikge1xuICBpZiAoYWN0aXZlKSB7XG4gICAgYWN0aXZhdGVDb252ZXJzYXRpb24oaW50ZXJmYWNlVHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgZGVhY3RpdmF0ZUNvbnZlcnNhdGlvbihpbnRlcmZhY2VUeXBlLCAnbWFudWFsIHRlc3Qgb3ZlcnJpZGUnKTtcbiAgfVxuICBsb2coXG4gICAgaW50ZXJmYWNlVHlwZSxcbiAgICBgQ29udmVyc2F0aW9uIHN0YXRlIG1hbnVhbGx5IHNldCB0byBhY3RpdmU6ICR7YWN0aXZlfSBmb3IgdGVzdGluZy5gXG4gICk7XG59XG5cbmxvZygndGV4dCcsICdDb252ZXJzYXRpb24gc3RhdGUgbWFuYWdlciBpbml0aWFsaXplZCBmb3IgdGV4dCBpbnRlcmZhY2UuJyk7XG5sb2coJ3ZvaWNlJywgJ0NvbnZlcnNhdGlvbiBzdGF0ZSBtYW5hZ2VyIGluaXRpYWxpemVkIGZvciB2b2ljZSBpbnRlcmZhY2UuJyk7XG4iXX0=