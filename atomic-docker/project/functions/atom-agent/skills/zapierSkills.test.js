import * as zapierSkills from './zapierSkills';
describe('Zapier Skills', () => {
    describe('triggerZap', () => {
        it('should return a success response with zapName and runId for a valid trigger', async () => {
            const zapName = 'TestZap';
            const data = { testKey: 'testValue' };
            const response = await zapierSkills.triggerZap(zapName, data);
            expect(response.success).toBe(true);
            expect(response.zapName).toBe(zapName);
            expect(response.runId).toBeDefined();
            expect(typeof response.runId).toBe('string');
            expect(response.message).toContain(`Zap "${zapName}" triggered successfully (mock).`);
        });
        it('should handle triggering a Zap with empty data', async () => {
            const zapName = 'ZapWithNoData';
            const data = {};
            const response = await zapierSkills.triggerZap(zapName, data);
            expect(response.success).toBe(true);
            expect(response.zapName).toBe(zapName);
            expect(response.runId).toBeDefined();
            expect(response.message).toContain(`Zap "${zapName}" triggered successfully (mock).`);
        });
        it('should return a failure response if zapName is missing', async () => {
            // Test with zapName as empty string, null, or undefined as per JS/TS practices
            // The skill currently checks for !zapName, which covers empty string.
            const data = { key: 'value' };
            const response = await zapierSkills.triggerZap('', data); // Empty string for zapName
            expect(response.success).toBe(false);
            expect(response.message).toBe('Zap name is required.');
            expect(response.runId).toBeUndefined();
            expect(response.zapName).toBeUndefined(); // Or it might be the empty string depending on implementation
        });
        // Example of console log spying if needed, though less critical for mock functions
        it('should log the zapName and data', async () => {
            const consoleSpy = jest.spyOn(console, 'log');
            const zapName = 'LoggingTestZap';
            const data = { item: 'logging item' };
            await zapierSkills.triggerZap(zapName, data);
            expect(consoleSpy).toHaveBeenCalledWith(`Triggering Zap: "${zapName}" with data:`, data);
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining(`Mock Zap "${zapName}" triggered successfully. Run ID:`));
            consoleSpy.mockRestore(); // Clean up spy
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiemFwaWVyU2tpbGxzLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJ6YXBpZXJTa2lsbHMudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEtBQUssWUFBWSxNQUFNLGdCQUFnQixDQUFDO0FBRy9DLFFBQVEsQ0FBQyxlQUFlLEVBQUUsR0FBRyxFQUFFO0lBQzdCLFFBQVEsQ0FBQyxZQUFZLEVBQUUsR0FBRyxFQUFFO1FBQzFCLEVBQUUsQ0FBQyw2RUFBNkUsRUFBRSxLQUFLLElBQUksRUFBRTtZQUMzRixNQUFNLE9BQU8sR0FBRyxTQUFTLENBQUM7WUFDMUIsTUFBTSxJQUFJLEdBQXlCLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxDQUFDO1lBRTVELE1BQU0sUUFBUSxHQUFHLE1BQU0sWUFBWSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFOUQsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDcEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDdkMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNyQyxNQUFNLENBQUMsT0FBTyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzdDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsU0FBUyxDQUNoQyxRQUFRLE9BQU8sa0NBQWtDLENBQ2xELENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxnREFBZ0QsRUFBRSxLQUFLLElBQUksRUFBRTtZQUM5RCxNQUFNLE9BQU8sR0FBRyxlQUFlLENBQUM7WUFDaEMsTUFBTSxJQUFJLEdBQXlCLEVBQUUsQ0FBQztZQUV0QyxNQUFNLFFBQVEsR0FBRyxNQUFNLFlBQVksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRTlELE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ3BDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7WUFDckMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxTQUFTLENBQ2hDLFFBQVEsT0FBTyxrQ0FBa0MsQ0FDbEQsQ0FBQztRQUNKLENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLHdEQUF3RCxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQ3RFLCtFQUErRTtZQUMvRSxzRUFBc0U7WUFDdEUsTUFBTSxJQUFJLEdBQXlCLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDO1lBRXBELE1BQU0sUUFBUSxHQUFHLE1BQU0sWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQywyQkFBMkI7WUFFckYsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDckMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQztZQUN2RCxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDO1lBQ3ZDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUMsYUFBYSxFQUFFLENBQUMsQ0FBQyw4REFBOEQ7UUFDMUcsQ0FBQyxDQUFDLENBQUM7UUFFSCxtRkFBbUY7UUFDbkYsRUFBRSxDQUFDLGlDQUFpQyxFQUFFLEtBQUssSUFBSSxFQUFFO1lBQy9DLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDO1lBQzlDLE1BQU0sT0FBTyxHQUFHLGdCQUFnQixDQUFDO1lBQ2pDLE1BQU0sSUFBSSxHQUFHLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBRSxDQUFDO1lBRXRDLE1BQU0sWUFBWSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFN0MsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLG9CQUFvQixDQUNyQyxvQkFBb0IsT0FBTyxjQUFjLEVBQ3pDLElBQUksQ0FDTCxDQUFDO1lBQ0YsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLG9CQUFvQixDQUNyQyxNQUFNLENBQUMsZ0JBQWdCLENBQ3JCLGFBQWEsT0FBTyxtQ0FBbUMsQ0FDeEQsQ0FDRixDQUFDO1lBRUYsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUMsZUFBZTtRQUMzQyxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB6YXBpZXJTa2lsbHMgZnJvbSAnLi96YXBpZXJTa2lsbHMnO1xuaW1wb3J0IHsgWmFwVHJpZ2dlclJlc3BvbnNlIH0gZnJvbSAnLi4vdHlwZXMnOyAvLyBBc3N1bWluZyBaYXBEYXRhIGlzIGRlZmluZWQgd2l0aGluIHphcGllclNraWxscyBvciBub3QgZXhwbGljaXRseSB0eXBlZCBmb3IgcmVzcG9uc2VcblxuZGVzY3JpYmUoJ1phcGllciBTa2lsbHMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCd0cmlnZ2VyWmFwJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGEgc3VjY2VzcyByZXNwb25zZSB3aXRoIHphcE5hbWUgYW5kIHJ1bklkIGZvciBhIHZhbGlkIHRyaWdnZXInLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB6YXBOYW1lID0gJ1Rlc3RaYXAnO1xuICAgICAgY29uc3QgZGF0YTogemFwaWVyU2tpbGxzLlphcERhdGEgPSB7IHRlc3RLZXk6ICd0ZXN0VmFsdWUnIH07XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgemFwaWVyU2tpbGxzLnRyaWdnZXJaYXAoemFwTmFtZSwgZGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlLnphcE5hbWUpLnRvQmUoemFwTmFtZSk7XG4gICAgICBleHBlY3QocmVzcG9uc2UucnVuSWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QodHlwZW9mIHJlc3BvbnNlLnJ1bklkKS50b0JlKCdzdHJpbmcnKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5tZXNzYWdlKS50b0NvbnRhaW4oXG4gICAgICAgIGBaYXAgXCIke3phcE5hbWV9XCIgdHJpZ2dlcmVkIHN1Y2Nlc3NmdWxseSAobW9jaykuYFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIHRyaWdnZXJpbmcgYSBaYXAgd2l0aCBlbXB0eSBkYXRhJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgemFwTmFtZSA9ICdaYXBXaXRoTm9EYXRhJztcbiAgICAgIGNvbnN0IGRhdGE6IHphcGllclNraWxscy5aYXBEYXRhID0ge307XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgemFwaWVyU2tpbGxzLnRyaWdnZXJaYXAoemFwTmFtZSwgZGF0YSk7XG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlLnphcE5hbWUpLnRvQmUoemFwTmFtZSk7XG4gICAgICBleHBlY3QocmVzcG9uc2UucnVuSWQpLnRvQmVEZWZpbmVkKCk7XG4gICAgICBleHBlY3QocmVzcG9uc2UubWVzc2FnZSkudG9Db250YWluKFxuICAgICAgICBgWmFwIFwiJHt6YXBOYW1lfVwiIHRyaWdnZXJlZCBzdWNjZXNzZnVsbHkgKG1vY2spLmBcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBhIGZhaWx1cmUgcmVzcG9uc2UgaWYgemFwTmFtZSBpcyBtaXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgLy8gVGVzdCB3aXRoIHphcE5hbWUgYXMgZW1wdHkgc3RyaW5nLCBudWxsLCBvciB1bmRlZmluZWQgYXMgcGVyIEpTL1RTIHByYWN0aWNlc1xuICAgICAgLy8gVGhlIHNraWxsIGN1cnJlbnRseSBjaGVja3MgZm9yICF6YXBOYW1lLCB3aGljaCBjb3ZlcnMgZW1wdHkgc3RyaW5nLlxuICAgICAgY29uc3QgZGF0YTogemFwaWVyU2tpbGxzLlphcERhdGEgPSB7IGtleTogJ3ZhbHVlJyB9O1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHphcGllclNraWxscy50cmlnZ2VyWmFwKCcnLCBkYXRhKTsgLy8gRW1wdHkgc3RyaW5nIGZvciB6YXBOYW1lXG5cbiAgICAgIGV4cGVjdChyZXNwb25zZS5zdWNjZXNzKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5tZXNzYWdlKS50b0JlKCdaYXAgbmFtZSBpcyByZXF1aXJlZC4nKTtcbiAgICAgIGV4cGVjdChyZXNwb25zZS5ydW5JZCkudG9CZVVuZGVmaW5lZCgpO1xuICAgICAgZXhwZWN0KHJlc3BvbnNlLnphcE5hbWUpLnRvQmVVbmRlZmluZWQoKTsgLy8gT3IgaXQgbWlnaHQgYmUgdGhlIGVtcHR5IHN0cmluZyBkZXBlbmRpbmcgb24gaW1wbGVtZW50YXRpb25cbiAgICB9KTtcblxuICAgIC8vIEV4YW1wbGUgb2YgY29uc29sZSBsb2cgc3B5aW5nIGlmIG5lZWRlZCwgdGhvdWdoIGxlc3MgY3JpdGljYWwgZm9yIG1vY2sgZnVuY3Rpb25zXG4gICAgaXQoJ3Nob3VsZCBsb2cgdGhlIHphcE5hbWUgYW5kIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjb25zb2xlU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJyk7XG4gICAgICBjb25zdCB6YXBOYW1lID0gJ0xvZ2dpbmdUZXN0WmFwJztcbiAgICAgIGNvbnN0IGRhdGEgPSB7IGl0ZW06ICdsb2dnaW5nIGl0ZW0nIH07XG5cbiAgICAgIGF3YWl0IHphcGllclNraWxscy50cmlnZ2VyWmFwKHphcE5hbWUsIGRhdGEpO1xuXG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGBUcmlnZ2VyaW5nIFphcDogXCIke3phcE5hbWV9XCIgd2l0aCBkYXRhOmAsXG4gICAgICAgIGRhdGFcbiAgICAgICk7XG4gICAgICBleHBlY3QoY29uc29sZVNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGV4cGVjdC5zdHJpbmdDb250YWluaW5nKFxuICAgICAgICAgIGBNb2NrIFphcCBcIiR7emFwTmFtZX1cIiB0cmlnZ2VyZWQgc3VjY2Vzc2Z1bGx5LiBSdW4gSUQ6YFxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBjb25zb2xlU3B5Lm1vY2tSZXN0b3JlKCk7IC8vIENsZWFuIHVwIHNweVxuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19