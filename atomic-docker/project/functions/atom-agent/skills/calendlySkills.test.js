import { listCalendlyEventTypes, listCalendlyScheduledEvents, } from './calendlySkills';
import * as constants from '../_libs/constants';
import { Calendly } from '@calendly/api-client';
// Mock the Calendly SDK and constants
jest.mock('@calendly/api-client');
jest.mock('../_libs/constants', () => ({
    ATOM_CALENDLY_PERSONAL_ACCESS_TOKEN: 'test-pat-token', // Default mock value
}));
// Declare mock functions for Calendly client methods
let mockGetCurrentUser;
let mockListEventTypes;
let mockListScheduledEvents;
// Spy on console.error and console.log
let consoleErrorSpy;
let consoleLogSpy;
describe('calendlySkills', () => {
    const callingUserId = 'test-user-123';
    const mockUserUri = 'https://api.calendly.com/users/mockuseruri';
    beforeEach(() => {
        // It's important to be able to change ATOM_CALENDLY_PERSONAL_ACCESS_TOKEN for specific tests.
        // The jest.mock above sets a default. To change it per test, we can spyOn the getter or re-mock.
        // For simplicity, we'll ensure tests that need an empty token set it directly via the spy.
        // The default 'test-pat-token' will be used unless a test overrides it.
        jest
            .spyOn(constants, 'ATOM_CALENDLY_PERSONAL_ACCESS_TOKEN', 'get')
            .mockReturnValue('test-pat-token');
        mockGetCurrentUser = jest.fn();
        mockListEventTypes = jest.fn();
        mockListScheduledEvents = jest.fn();
        Calendly.mockImplementation(() => ({
            users: { getCurrent: mockGetCurrentUser },
            eventTypes: { list: mockListEventTypes },
            scheduledEvents: { list: mockListScheduledEvents },
        }));
        consoleErrorSpy = jest.spyOn(console, 'error').mockImplementation(() => { });
        consoleLogSpy = jest.spyOn(console, 'log').mockImplementation(() => { });
    });
    afterEach(() => {
        jest.clearAllMocks();
        consoleErrorSpy.mockRestore();
        consoleLogSpy.mockRestore();
    });
    describe('listCalendlyEventTypes', () => {
        it('should list event types successfully', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({
                resource: { uri: mockUserUri },
            });
            const mockEventTypes = [
                { name: 'Test Event Type', uri: 'event_type_uri_1' },
            ];
            const mockPagination = {
                count: 1,
                next_page_token: null,
            };
            mockListEventTypes.mockResolvedValueOnce({
                collection: mockEventTypes,
                pagination: mockPagination,
            });
            const result = await listCalendlyEventTypes(callingUserId);
            expect(result.ok).toBe(true);
            expect(result.collection).toEqual(mockEventTypes);
            expect(result.pagination).toEqual(mockPagination);
            expect(mockGetCurrentUser).toHaveBeenCalledTimes(1);
            expect(mockListEventTypes).toHaveBeenCalledWith({
                user: mockUserUri,
                active: true,
                count: 100,
            });
            expect(consoleLogSpy).toHaveBeenCalledWith(`listCalendlyEventTypes called by userId: ${callingUserId}`);
        });
        it('should return error if token is missing', async () => {
            jest
                .spyOn(constants, 'ATOM_CALENDLY_PERSONAL_ACCESS_TOKEN', 'get')
                .mockReturnValue('');
            const result = await listCalendlyEventTypes(callingUserId);
            expect(result).toEqual({
                ok: false,
                error: 'Calendly Personal Access Token not configured.',
            });
            expect(mockGetCurrentUser).not.toHaveBeenCalled();
            expect(mockListEventTypes).not.toHaveBeenCalled();
            expect(consoleErrorSpy).toHaveBeenCalledWith('Calendly Personal Access Token not configured.');
        });
        it('should return error if getCurrentUser fails to return URI', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({ resource: {} }); // Missing URI
            const result = await listCalendlyEventTypes(callingUserId);
            expect(result.ok).toBe(false);
            expect(result.error).toBe('Failed to retrieve current user URI from Calendly.');
        });
        it('should handle API error from getCurrentUser', async () => {
            const apiError = new Error('User API Error');
            mockGetCurrentUser.mockRejectedValueOnce(apiError);
            const result = await listCalendlyEventTypes(callingUserId);
            expect(result.ok).toBe(false);
            expect(result.error).toContain('User API Error');
            expect(consoleErrorSpy).toHaveBeenCalledWith(`Error listing Calendly event types for userId ${callingUserId}:`, apiError.message);
        });
        it('should handle API error from listEventTypes', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({
                resource: { uri: mockUserUri },
            });
            const apiError = new Error('Event Type API Error');
            mockListEventTypes.mockRejectedValueOnce(apiError);
            const result = await listCalendlyEventTypes(callingUserId);
            expect(result.ok).toBe(false);
            expect(result.error).toContain('Event Type API Error');
        });
    });
    describe('listCalendlyScheduledEvents', () => {
        it('should list scheduled events successfully (no options)', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({
                resource: { uri: mockUserUri },
            });
            const mockEvents = [
                { name: 'Scheduled Meeting', uri: 'scheduled_event_uri_1' },
            ];
            const mockPagination = {
                count: 1,
                next_page_token: null,
            };
            mockListScheduledEvents.mockResolvedValueOnce({
                collection: mockEvents,
                pagination: mockPagination,
            });
            const result = await listCalendlyScheduledEvents(callingUserId);
            expect(result.ok).toBe(true);
            expect(result.collection).toEqual(mockEvents);
            expect(result.pagination).toEqual(mockPagination);
            expect(mockGetCurrentUser).toHaveBeenCalledTimes(1);
            expect(mockListScheduledEvents).toHaveBeenCalledWith(expect.objectContaining({ user: mockUserUri }));
            expect(consoleLogSpy).toHaveBeenCalledWith(`listCalendlyScheduledEvents called by userId: ${callingUserId} with options:`, undefined);
        });
        it('should list scheduled events with options correctly passed', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({
                resource: { uri: mockUserUri },
            });
            mockListScheduledEvents.mockResolvedValueOnce({
                collection: [],
                pagination: {},
            });
            const options = {
                count: 5,
                status: 'active',
                sort: 'start_time:desc',
                pageToken: 'next_token', // Changed from page_token to pageToken to match skill
                min_start_time: '2024-01-01T00:00:00Z',
                max_start_time: '2024-01-31T23:59:59Z',
            };
            // What the SDK call should receive based on the skill's mapping
            const expectedApiOptions = {
                user: mockUserUri,
                count: 5,
                status: 'active',
                sort: 'start_time:desc',
                page_token: 'next_token', // Skill maps pageToken to page_token
                min_start_time: '2024-01-01T00:00:00Z',
                max_start_time: '2024-01-31T23:59:59Z',
            };
            await listCalendlyScheduledEvents(callingUserId, options);
            expect(mockListScheduledEvents).toHaveBeenCalledWith(expectedApiOptions);
            expect(consoleLogSpy).toHaveBeenCalledWith(`listCalendlyScheduledEvents called by userId: ${callingUserId} with options:`, options);
        });
        it('should return error if token is missing', async () => {
            jest
                .spyOn(constants, 'ATOM_CALENDLY_PERSONAL_ACCESS_TOKEN', 'get')
                .mockReturnValue('');
            const result = await listCalendlyScheduledEvents(callingUserId);
            expect(result).toEqual({
                ok: false,
                error: 'Calendly Personal Access Token not configured.',
            });
            expect(mockGetCurrentUser).not.toHaveBeenCalled();
        });
        it('should return error if getCurrentUser fails to return URI', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({ resource: {} }); // Missing URI
            const result = await listCalendlyScheduledEvents(callingUserId);
            expect(result.ok).toBe(false);
            expect(result.error).toBe('Failed to retrieve current user URI from Calendly.');
        });
        it('should handle API error from getCurrentUser', async () => {
            const apiError = new Error('User API Error for Scheduled Events');
            mockGetCurrentUser.mockRejectedValueOnce(apiError);
            const result = await listCalendlyScheduledEvents(callingUserId);
            expect(result.ok).toBe(false);
            expect(result.error).toContain('User API Error for Scheduled Events');
            expect(consoleErrorSpy).toHaveBeenCalledWith(`Error listing Calendly scheduled events for userId ${callingUserId}:`, apiError.message);
        });
        it('should handle API error from listScheduledEvents', async () => {
            mockGetCurrentUser.mockResolvedValueOnce({
                resource: { uri: mockUserUri },
            });
            const apiError = new Error('Scheduled Events API Error');
            mockListScheduledEvents.mockRejectedValueOnce(apiError);
            const result = await listCalendlyScheduledEvents(callingUserId);
            expect(result.ok).toBe(false);
            expect(result.error).toContain('Scheduled Events API Error');
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kbHlTa2lsbHMudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNhbGVuZGx5U2tpbGxzLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLHNCQUFzQixFQUN0QiwyQkFBMkIsR0FDNUIsTUFBTSxrQkFBa0IsQ0FBQztBQUMxQixPQUFPLEtBQUssU0FBUyxNQUFNLG9CQUFvQixDQUFDO0FBQ2hELE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQU9oRCxzQ0FBc0M7QUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBQ2xDLElBQUksQ0FBQyxJQUFJLENBQUMsb0JBQW9CLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUNyQyxtQ0FBbUMsRUFBRSxnQkFBZ0IsRUFBRSxxQkFBcUI7Q0FDN0UsQ0FBQyxDQUFDLENBQUM7QUFFSixxREFBcUQ7QUFDckQsSUFBSSxrQkFBNkIsQ0FBQztBQUNsQyxJQUFJLGtCQUE2QixDQUFDO0FBQ2xDLElBQUksdUJBQWtDLENBQUM7QUFFdkMsdUNBQXVDO0FBQ3ZDLElBQUksZUFBaUMsQ0FBQztBQUN0QyxJQUFJLGFBQStCLENBQUM7QUFFcEMsUUFBUSxDQUFDLGdCQUFnQixFQUFFLEdBQUcsRUFBRTtJQUM5QixNQUFNLGFBQWEsR0FBRyxlQUFlLENBQUM7SUFDdEMsTUFBTSxXQUFXLEdBQUcsNENBQTRDLENBQUM7SUFFakUsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLDhGQUE4RjtRQUM5RixpR0FBaUc7UUFDakcsMkZBQTJGO1FBQzNGLHdFQUF3RTtRQUN4RSxJQUFJO2FBQ0QsS0FBSyxDQUFDLFNBQVMsRUFBRSxxQ0FBcUMsRUFBRSxLQUFLLENBQUM7YUFDOUQsZUFBZSxDQUFDLGdCQUFnQixDQUFDLENBQUM7UUFFckMsa0JBQWtCLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQy9CLGtCQUFrQixHQUFH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RUFBRTthQUMvQixDQUFDLENBQUM7WUFDSCxNQUFNLFFBQVEsR0FBRyxJQUFJLEtBQUssQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO1lBQ3pELHVCQUF1QixDQUFDLHFCQUFxQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQ3hELE1BQU0sTUFBTSxHQUFHLE1BQU0sMkJBQTJCLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDaEUsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDOUIsTUFBTSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxTQUFTLENBQUMsNEJBQTRCLENBQUMsQ0FBQztRQUMvRCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBsaXN0Q2FsZW5kbHlFdmVudFR5cGVzLFxuICBsaXN0Q2FsZW5kbHlTY2hlZHVsZWRFdmVudHMsXG59IGZyb20gJy4vY2FsZW5kbHlTa2lsbHMnO1xuaW1wb3J0ICogYXMgY29uc3RhbnRzIGZyb20gJy4uL19saWJzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDYWxlbmRseSB9IGZyb20gJ0BjYWxlbmRseS9hcGktY2xpZW50JztcbmltcG9ydCB7XG4gIENhbGVuZGx5RXZlbnRUeXBlLFxuICBDYWxlbmRseVNjaGVkdWxlZEV2ZW50LFxuICBDYWxlbmRseVBhZ2luYXRpb24sXG59IGZyb20gJy4uL3R5cGVzJzsgLy8gVXNpbmcgb3VyIHR5cGVzIGZvciBleHBlY3RlZCByZXN1bHRzXG5cbi8vIE1vY2sgdGhlIENhbGVuZGx5IFNESyBhbmQgY29uc3RhbnRzXG5qZXN0Lm1vY2soJ0BjYWxlbmRseS9hcGktY2xpZW50Jyk7XG5qZXN0Lm1vY2soJy4uL19saWJzL2NvbnN0YW50cycsICgpID0+ICh7XG4gIEFUT01fQ0FMRU5ETFlfUEVSU09OQUxfQUNDRVNTX1RPS0VOOiAndGVzdC1wYXQtdG9rZW4nLCAvLyBEZWZhdWx0IG1vY2sgdmFsdWVcbn0pKTtcblxuLy8gRGVjbGFyZSBtb2NrIGZ1bmN0aW9ucyBmb3IgQ2FsZW5kbHkgY2xpZW50IG1ldGhvZHNcbmxldCBtb2NrR2V0Q3VycmVudFVzZXI6IGplc3QuTW9jaztcbmxldCBtb2NrTGlzdEV2ZW50VHlwZXM6IGplc3QuTW9jaztcbmxldCBtb2NrTGlzdFNjaGVkdWxlZEV2ZW50czogamVzdC5Nb2NrO1xuXG4vLyBTcHkgb24gY29uc29sZS5lcnJvciBhbmQgY29uc29sZS5sb2dcbmxldCBjb25zb2xlRXJyb3JTcHk6IGplc3QuU3B5SW5zdGFuY2U7XG5sZXQgY29uc29sZUxvZ1NweTogamVzdC5TcHlJbnN0YW5jZTtcblxuZGVzY3JpYmUoJ2NhbGVuZGx5U2tpbGxzJywgKCkgPT4ge1xuICBjb25zdCBjYWxsaW5nVXNlcklkID0gJ3Rlc3QtdXNlci0xMjMnO1xuICBjb25zdCBtb2NrVXNlclVyaSA9ICdodHRwczovL2FwaS5jYWxlbmRseS5jb20vdXNlcnMvbW9ja3VzZXJ1cmknO1xuXG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIGJlIGFibGUgdG8gY2hhbmdlIEFUT01fQ0FMRU5ETFlfUEVSU09OQUxfQUNDRVNTX1RPS0VOIGZvciBzcGVjaWZpYyB0ZXN0cy5cbiAgICAvLyBUaGUgamVzdC5tb2NrIGFib3ZlIHNldHMgYSBkZWZhdWx0LiBUbyBjaGFuZ2UgaXQgcGVyIHRlc3QsIHdlIGNhbiBzcHlPbiB0aGUgZ2V0dGVyIG9yIHJlLW1vY2suXG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHdlJ2xsIGVuc3VyZSB0ZXN0cyB0aGF0IG5lZWQgYW4gZW1wdHkgdG9rZW4gc2V0IGl0IGRpcmVjdGx5IHZpYSB0aGUgc3B5LlxuICAgIC8vIFRoZSBkZWZhdWx0ICd0ZXN0LXBhdC10b2tlbicgd2lsbCBiZSB1c2VkIHVubGVzcyBhIHRlc3Qgb3ZlcnJpZGVzIGl0LlxuICAgIGplc3RcbiAgICAgIC5zcHlPbihjb25zdGFudHMsICdBVE9NX0NBTEVORExZX1BFUlNPTkFMX0FDQ0VTU19UT0tFTicsICdnZXQnKVxuICAgICAgLm1vY2tSZXR1cm5WYWx1ZSgndGVzdC1wYXQtdG9rZW4nKTtcblxuICAgIG1vY2tHZXRDdXJyZW50VXNlciA9IGplc3QuZm4oKTtcbiAgICBtb2NrTGlzdEV2ZW50VHlwZXMgPSBqZXN0LmZuKCk7XG4gICAgbW9ja0xpc3RTY2hlZHVsZWRFdmVudHMgPSBqZXN0LmZuKCk7XG5cbiAgICAoQ2FsZW5kbHkgYXMgamVzdC5Nb2NrKS5tb2NrSW1wbGVtZW50YXRpb24oKCkgPT4gKHtcbiAgICAgIHVzZXJzOiB7IGdldEN1cnJlbnQ6IG1vY2tHZXRDdXJyZW50VXNlciB9LFxuICAgICAgZXZlbnRUeXBlczogeyBsaXN0OiBtb2NrTGlzdEV2ZW50VHlwZXMgfSxcbiAgICAgIHNjaGVkdWxlZEV2ZW50czogeyBsaXN0OiBtb2NrTGlzdFNjaGVkdWxlZEV2ZW50cyB9LFxuICAgIH0pKTtcblxuICAgIGNvbnNvbGVFcnJvclNweSA9IGplc3Quc3B5T24oY29uc29sZSwgJ2Vycm9yJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgICBjb25zb2xlTG9nU3B5ID0gamVzdC5zcHlPbihjb25zb2xlLCAnbG9nJykubW9ja0ltcGxlbWVudGF0aW9uKCgpID0+IHt9KTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBqZXN0LmNsZWFyQWxsTW9ja3MoKTtcbiAgICBjb25zb2xlRXJyb3JTcHkubW9ja1Jlc3RvcmUoKTtcbiAgICBjb25zb2xlTG9nU3B5Lm1vY2tSZXN0b3JlKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdsaXN0Q2FsZW5kbHlFdmVudFR5cGVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgbGlzdCBldmVudCB0eXBlcyBzdWNjZXNzZnVsbHknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrR2V0Q3VycmVudFVzZXIubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgcmVzb3VyY2U6IHsgdXJpOiBtb2NrVXNlclVyaSB9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBtb2NrRXZlbnRUeXBlczogUGFydGlhbDxDYWxlbmRseUV2ZW50VHlwZT5bXSA9IFtcbiAgICAgICAgeyBuYW1lOiAnVGVzdCBFdmVudCBUeXBlJywgdXJpOiAnZXZlbnRfdHlwZV91cmlfMScgfSxcbiAgICAgIF07XG4gICAgICBjb25zdCBtb2NrUGFnaW5hdGlvbjogUGFydGlhbDxDYWxlbmRseVBhZ2luYXRpb24+ID0ge1xuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgbmV4dF9wYWdlX3Rva2VuOiBudWxsLFxuICAgICAgfTtcbiAgICAgIG1vY2tMaXN0RXZlbnRUeXBlcy5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICBjb2xsZWN0aW9uOiBtb2NrRXZlbnRUeXBlcyxcbiAgICAgICAgcGFnaW5hdGlvbjogbW9ja1BhZ2luYXRpb24sXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdENhbGVuZGx5RXZlbnRUeXBlcyhjYWxsaW5nVXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5vaykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29sbGVjdGlvbikudG9FcXVhbChtb2NrRXZlbnRUeXBlcyk7XG4gICAgICBleHBlY3QocmVzdWx0LnBhZ2luYXRpb24pLnRvRXF1YWwobW9ja1BhZ2luYXRpb24pO1xuICAgICAgZXhwZWN0KG1vY2tHZXRDdXJyZW50VXNlcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgICAgZXhwZWN0KG1vY2tMaXN0RXZlbnRUeXBlcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgICB1c2VyOiBtb2NrVXNlclVyaSxcbiAgICAgICAgYWN0aXZlOiB0cnVlLFxuICAgICAgICBjb3VudDogMTAwLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QoY29uc29sZUxvZ1NweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgIGBsaXN0Q2FsZW5kbHlFdmVudFR5cGVzIGNhbGxlZCBieSB1c2VySWQ6ICR7Y2FsbGluZ1VzZXJJZH1gXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZXJyb3IgaWYgdG9rZW4gaXMgbWlzc2luZycsIGFzeW5jICgpID0+IHtcbiAgICAgIGplc3RcbiAgICAgICAgLnNweU9uKGNvbnN0YW50cywgJ0FUT01fQ0FMRU5ETFlfUEVSU09OQUxfQUNDRVNTX1RPS0VOJywgJ2dldCcpXG4gICAgICAgIC5tb2NrUmV0dXJuVmFsdWUoJycpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdENhbGVuZGx5RXZlbnRUeXBlcyhjYWxsaW5nVXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoe1xuICAgICAgICBvazogZmFsc2UsXG4gICAgICAgIGVycm9yOiAnQ2FsZW5kbHkgUGVyc29uYWwgQWNjZXNzIFRva2VuIG5vdCBjb25maWd1cmVkLicsXG4gICAgICB9KTtcbiAgICAgIGV4cGVjdChtb2NrR2V0Q3VycmVudFVzZXIpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgICBleHBlY3QobW9ja0xpc3RFdmVudFR5cGVzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVFcnJvclNweSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoXG4gICAgICAgICdDYWxlbmRseSBQZXJzb25hbCBBY2Nlc3MgVG9rZW4gbm90IGNvbmZpZ3VyZWQuJ1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGVycm9yIGlmIGdldEN1cnJlbnRVc2VyIGZhaWxzIHRvIHJldHVybiBVUkknLCBhc3luYyAoKSA9PiB7XG4gICAgICBtb2NrR2V0Q3VycmVudFVzZXIubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHsgcmVzb3VyY2U6IHt9IH0pOyAvLyBNaXNzaW5nIFVSSVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbGlzdENhbGVuZGx5RXZlbnRUeXBlcyhjYWxsaW5nVXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQub2spLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9CZShcbiAgICAgICAgJ0ZhaWxlZCB0byByZXRyaWV2ZSBjdXJyZW50IHVzZXIgVVJJIGZyb20gQ2FsZW5kbHkuJ1xuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEFQSSBlcnJvciBmcm9tIGdldEN1cnJlbnRVc2VyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgRXJyb3IoJ1VzZXIgQVBJIEVycm9yJyk7XG4gICAgICBtb2NrR2V0Q3VycmVudFVzZXIubW9ja1JlamVjdGVkVmFsdWVPbmNlKGFwaUVycm9yKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RDYWxlbmRseUV2ZW50VHlwZXMoY2FsbGluZ1VzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0Lm9rKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignVXNlciBBUEkgRXJyb3InKTtcbiAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgRXJyb3IgbGlzdGluZyBDYWxlbmRseSBldmVudCB0eXBlcyBmb3IgdXNlcklkICR7Y2FsbGluZ1VzZXJJZH06YCxcbiAgICAgICAgYXBpRXJyb3IubWVzc2FnZVxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgaGFuZGxlIEFQSSBlcnJvciBmcm9tIGxpc3RFdmVudFR5cGVzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0dldEN1cnJlbnRVc2VyLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHJlc291cmNlOiB7IHVyaTogbW9ja1VzZXJVcmkgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYXBpRXJyb3IgPSBuZXcgRXJyb3IoJ0V2ZW50IFR5cGUgQVBJIEVycm9yJyk7XG4gICAgICBtb2NrTGlzdEV2ZW50VHlwZXMubW9ja1JlamVjdGVkVmFsdWVPbmNlKGFwaUVycm9yKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RDYWxlbmRseUV2ZW50VHlwZXMoY2FsbGluZ1VzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0Lm9rKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignRXZlbnQgVHlwZSBBUEkgRXJyb3InKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ2xpc3RDYWxlbmRseVNjaGVkdWxlZEV2ZW50cycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGxpc3Qgc2NoZWR1bGVkIGV2ZW50cyBzdWNjZXNzZnVsbHkgKG5vIG9wdGlvbnMpJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0dldEN1cnJlbnRVc2VyLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHJlc291cmNlOiB7IHVyaTogbW9ja1VzZXJVcmkgfSxcbiAgICAgIH0pO1xuICAgICAgY29uc3QgbW9ja0V2ZW50czogUGFydGlhbDxDYWxlbmRseVNjaGVkdWxlZEV2ZW50PltdID0gW1xuICAgICAgICB7IG5hbWU6ICdTY2hlZHVsZWQgTWVldGluZycsIHVyaTogJ3NjaGVkdWxlZF9ldmVudF91cmlfMScgfSxcbiAgICAgIF07XG4gICAgICBjb25zdCBtb2NrUGFnaW5hdGlvbjogUGFydGlhbDxDYWxlbmRseVBhZ2luYXRpb24+ID0ge1xuICAgICAgICBjb3VudDogMSxcbiAgICAgICAgbmV4dF9wYWdlX3Rva2VuOiBudWxsLFxuICAgICAgfTtcbiAgICAgIG1vY2tMaXN0U2NoZWR1bGVkRXZlbnRzLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIGNvbGxlY3Rpb246IG1vY2tFdmVudHMsXG4gICAgICAgIHBhZ2luYXRpb246IG1vY2tQYWdpbmF0aW9uLFxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RDYWxlbmRseVNjaGVkdWxlZEV2ZW50cyhjYWxsaW5nVXNlcklkKTtcblxuICAgICAgZXhwZWN0KHJlc3VsdC5vaykudG9CZSh0cnVlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuY29sbGVjdGlvbikudG9FcXVhbChtb2NrRXZlbnRzKTtcbiAgICAgIGV4cGVjdChyZXN1bHQucGFnaW5hdGlvbikudG9FcXVhbChtb2NrUGFnaW5hdGlvbik7XG4gICAgICBleHBlY3QobW9ja0dldEN1cnJlbnRVc2VyKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgICBleHBlY3QobW9ja0xpc3RTY2hlZHVsZWRFdmVudHMpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7IHVzZXI6IG1vY2tVc2VyVXJpIH0pXG4gICAgICApO1xuICAgICAgZXhwZWN0KGNvbnNvbGVMb2dTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgbGlzdENhbGVuZGx5U2NoZWR1bGVkRXZlbnRzIGNhbGxlZCBieSB1c2VySWQ6ICR7Y2FsbGluZ1VzZXJJZH0gd2l0aCBvcHRpb25zOmAsXG4gICAgICAgIHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgbGlzdCBzY2hlZHVsZWQgZXZlbnRzIHdpdGggb3B0aW9ucyBjb3JyZWN0bHkgcGFzc2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbW9ja0dldEN1cnJlbnRVc2VyLm1vY2tSZXNvbHZlZFZhbHVlT25jZSh7XG4gICAgICAgIHJlc291cmNlOiB7IHVyaTogbW9ja1VzZXJVcmkgfSxcbiAgICAgIH0pO1xuICAgICAgbW9ja0xpc3RTY2hlZHVsZWRFdmVudHMubW9ja1Jlc29sdmVkVmFsdWVPbmNlKHtcbiAgICAgICAgY29sbGVjdGlvbjogW10sXG4gICAgICAgIHBhZ2luYXRpb246IHt9LFxuICAgICAgfSk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBjb3VudDogNSxcbiAgICAgICAgc3RhdHVzOiAnYWN0aXZlJyBhcyBjb25zdCxcbiAgICAgICAgc29ydDogJ3N0YXJ0X3RpbWU6ZGVzYycsXG4gICAgICAgIHBhZ2VUb2tlbjogJ25leHRfdG9rZW4nLCAvLyBDaGFuZ2VkIGZyb20gcGFnZV90b2tlbiB0byBwYWdlVG9rZW4gdG8gbWF0Y2ggc2tpbGxcbiAgICAgICAgbWluX3N0YXJ0X3RpbWU6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIG1heF9zdGFydF90aW1lOiAnMjAyNC0wMS0zMVQyMzo1OTo1OVonLFxuICAgICAgfTtcblxuICAgICAgLy8gV2hhdCB0aGUgU0RLIGNhbGwgc2hvdWxkIHJlY2VpdmUgYmFzZWQgb24gdGhlIHNraWxsJ3MgbWFwcGluZ1xuICAgICAgY29uc3QgZXhwZWN0ZWRBcGlPcHRpb25zID0ge1xuICAgICAgICB1c2VyOiBtb2NrVXNlclVyaSxcbiAgICAgICAgY291bnQ6IDUsXG4gICAgICAgIHN0YXR1czogJ2FjdGl2ZScsXG4gICAgICAgIHNvcnQ6ICdzdGFydF90aW1lOmRlc2MnLFxuICAgICAgICBwYWdlX3Rva2VuOiAnbmV4dF90b2tlbicsIC8vIFNraWxsIG1hcHMgcGFnZVRva2VuIHRvIHBhZ2VfdG9rZW5cbiAgICAgICAgbWluX3N0YXJ0X3RpbWU6ICcyMDI0LTAxLTAxVDAwOjAwOjAwWicsXG4gICAgICAgIG1heF9zdGFydF90aW1lOiAnMjAyNC0wMS0zMVQyMzo1OTo1OVonLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgbGlzdENhbGVuZGx5U2NoZWR1bGVkRXZlbnRzKGNhbGxpbmdVc2VySWQsIG9wdGlvbnMpO1xuICAgICAgZXhwZWN0KG1vY2tMaXN0U2NoZWR1bGVkRXZlbnRzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChleHBlY3RlZEFwaU9wdGlvbnMpO1xuICAgICAgZXhwZWN0KGNvbnNvbGVMb2dTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgbGlzdENhbGVuZGx5U2NoZWR1bGVkRXZlbnRzIGNhbGxlZCBieSB1c2VySWQ6ICR7Y2FsbGluZ1VzZXJJZH0gd2l0aCBvcHRpb25zOmAsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBlcnJvciBpZiB0b2tlbiBpcyBtaXNzaW5nJywgYXN5bmMgKCkgPT4ge1xuICAgICAgamVzdFxuICAgICAgICAuc3B5T24oY29uc3RhbnRzLCAnQVRPTV9DQUxFTkRMWV9QRVJTT05BTF9BQ0NFU1NfVE9LRU4nLCAnZ2V0JylcbiAgICAgICAgLm1vY2tSZXR1cm5WYWx1ZSgnJyk7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0Q2FsZW5kbHlTY2hlZHVsZWRFdmVudHMoY2FsbGluZ1VzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0KS50b0VxdWFsKHtcbiAgICAgICAgb2s6IGZhbHNlLFxuICAgICAgICBlcnJvcjogJ0NhbGVuZGx5IFBlcnNvbmFsIEFjY2VzcyBUb2tlbiBub3QgY29uZmlndXJlZC4nLFxuICAgICAgfSk7XG4gICAgICBleHBlY3QobW9ja0dldEN1cnJlbnRVc2VyKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gZXJyb3IgaWYgZ2V0Q3VycmVudFVzZXIgZmFpbHMgdG8gcmV0dXJuIFVSSScsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tHZXRDdXJyZW50VXNlci5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2UoeyByZXNvdXJjZToge30gfSk7IC8vIE1pc3NpbmcgVVJJXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0Q2FsZW5kbHlTY2hlZHVsZWRFdmVudHMoY2FsbGluZ1VzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0Lm9rKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQmUoXG4gICAgICAgICdGYWlsZWQgdG8gcmV0cmlldmUgY3VycmVudCB1c2VyIFVSSSBmcm9tIENhbGVuZGx5LidcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGhhbmRsZSBBUEkgZXJyb3IgZnJvbSBnZXRDdXJyZW50VXNlcicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKCdVc2VyIEFQSSBFcnJvciBmb3IgU2NoZWR1bGVkIEV2ZW50cycpO1xuICAgICAgbW9ja0dldEN1cnJlbnRVc2VyLm1vY2tSZWplY3RlZFZhbHVlT25jZShhcGlFcnJvcik7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0Q2FsZW5kbHlTY2hlZHVsZWRFdmVudHMoY2FsbGluZ1VzZXJJZCk7XG4gICAgICBleHBlY3QocmVzdWx0Lm9rKS50b0JlKGZhbHNlKTtcbiAgICAgIGV4cGVjdChyZXN1bHQuZXJyb3IpLnRvQ29udGFpbignVXNlciBBUEkgRXJyb3IgZm9yIFNjaGVkdWxlZCBFdmVudHMnKTtcbiAgICAgIGV4cGVjdChjb25zb2xlRXJyb3JTcHkpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKFxuICAgICAgICBgRXJyb3IgbGlzdGluZyBDYWxlbmRseSBzY2hlZHVsZWQgZXZlbnRzIGZvciB1c2VySWQgJHtjYWxsaW5nVXNlcklkfTpgLFxuICAgICAgICBhcGlFcnJvci5tZXNzYWdlXG4gICAgICApO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBoYW5kbGUgQVBJIGVycm9yIGZyb20gbGlzdFNjaGVkdWxlZEV2ZW50cycsIGFzeW5jICgpID0+IHtcbiAgICAgIG1vY2tHZXRDdXJyZW50VXNlci5tb2NrUmVzb2x2ZWRWYWx1ZU9uY2Uoe1xuICAgICAgICByZXNvdXJjZTogeyB1cmk6IG1vY2tVc2VyVXJpIH0sXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGFwaUVycm9yID0gbmV3IEVycm9yKCdTY2hlZHVsZWQgRXZlbnRzIEFQSSBFcnJvcicpO1xuICAgICAgbW9ja0xpc3RTY2hlZHVsZWRFdmVudHMubW9ja1JlamVjdGVkVmFsdWVPbmNlKGFwaUVycm9yKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxpc3RDYWxlbmRseVNjaGVkdWxlZEV2ZW50cyhjYWxsaW5nVXNlcklkKTtcbiAgICAgIGV4cGVjdChyZXN1bHQub2spLnRvQmUoZmFsc2UpO1xuICAgICAgZXhwZWN0KHJlc3VsdC5lcnJvcikudG9Db250YWluKCdTY2hlZHVsZWQgRXZlbnRzIEFQSSBFcnJvcicpO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19