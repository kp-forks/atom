// Manages the interaction between Short-Term Memory (STM) and Long-Term Memory (LTM) stored in LanceDB.
import { addRecord, searchTable } from './lanceDBManager'; // Import DB interaction functions
import { v4 as uuidv4 } from 'uuid'; // For generating unique IDs
import OpenAI from 'openai'; // Added OpenAI import
// NOTE: DEFAULT_VECTOR_DIMENSION is 768 here, but was changed to 1536 in lanceDBManager.ts
// This needs to be consistent. Assuming 1536 is the target.
const DEFAULT_VECTOR_DIMENSION = 1536;
// Initialize OpenAI Client
const openaiApiKey = process.env.OPENAI_API_KEY;
let openaiClient = null;
if (openaiApiKey) {
    openaiClient = new OpenAI({ apiKey: openaiApiKey });
    console.log('[MemoryManager] OpenAI client initialized.');
}
else {
    console.error('[MemoryManager] OPENAI_API_KEY not found in environment variables. Real embeddings will not be generated by TS side MemoryManager.');
}
function log(message, level = 'info', data) {
    const prefix = `[MemoryManager] ${new Date().toISOString()}`;
    if (level === 'error') {
        console.error(`${prefix} [ERROR]: ${message}`, data || '');
    }
    else {
        console.log(`${prefix}: ${message}`, data || '');
    }
}
/**
 * Placeholder for generating embeddings.
 * In a real implementation, this would call an actual embedding model.
 * @param text The text to embed.
 * @returns A promise that resolves to a vector (array of numbers) or null if an error occurs.
 */
export async function generateEmbedding(text) {
    if (!openaiClient) {
        log('[MemoryManager] OpenAI client not initialized. Cannot generate real embedding. Returning null.', 'error');
        return null;
    }
    if (!text || text.trim() === '') {
        log('[MemoryManager] generateEmbedding called with empty or whitespace-only text. Returning null.', 'warn');
        return null;
    }
    const trimmedText = text.trim();
    log(`Generating OpenAI embedding for text (first 50 chars): "${trimmedText.substring(0, 50)}..."`);
    try {
        const response = await openaiClient.embeddings.create({
            model: 'text-embedding-ada-002', // This model outputs 1536 dimensions
            input: trimmedText,
        });
        if (response.data &&
            response.data.length > 0 &&
            response.data[0].embedding) {
            log(`Successfully generated OpenAI embedding. Dimension: ${response.data[0].embedding.length}`);
            if (response.data[0].embedding.length !== DEFAULT_VECTOR_DIMENSION) {
                log(`[MemoryManager] WARNING: OpenAI embedding dimension (${response.data[0].embedding.length}) does not match DEFAULT_VECTOR_DIMENSION (${DEFAULT_VECTOR_DIMENSION}). Check model and config.`, 'warn');
            }
            return response.data[0].embedding;
        }
        else {
            log('[MemoryManager] OpenAI embedding response is missing expected data.', 'error', response);
            return null;
        }
    }
    catch (error) {
        log('[MemoryManager] Error generating OpenAI embedding:', 'error', error);
        return null;
    }
}
/**
 * Processes Short-Term Memory (STM) and decides what to store in Long-Term Memory (LTM).
 * If successful, resolves the promise. If a critical error occurs during LTM storage (e.g., DB error),
 * the promise is rejected. Failure to generate an embedding logs an error but does not cause a rejection.
 * @param userId The ID of the user.
 * @param conversation The current conversation state.
 * @param db The LanceDB connection object.
 * @returns A promise that resolves if processing is successful or if embedding fails (with logged error),
 *          and rejects if there's a critical error during LTM storage.
 */
export async function processSTMToLTM(userId, conversation, db) {
    log(`Processing STM to LTM for user: ${userId}`);
    // log('Current conversation state received:', conversation); // Can be too verbose
    if (!db) {
        log('LanceDB connection not provided to processSTMToLTM.', 'error');
        return Promise.reject(new Error('LanceDB connection not provided.'));
    }
    let summary = '';
    if (conversation.userGoal) {
        summary += `User Goal: ${conversation.userGoal}. `;
    }
    const recentTurns = conversation.turnHistory.slice(-2); // Last 2 turns
    if (recentTurns.length > 0) {
        summary += recentTurns
            .map((turn) => `User: ${turn.userInput} | Agent: ${JSON.stringify(turn.agentResponse).substring(0, 150)}...`)
            .join('; ');
    }
    if (!summary.trim()) {
        log('No significant information found in STM to process for LTM.');
        return;
    }
    log(`Generated summary for LTM: "${summary.substring(0, 200)}..."`);
    try {
        const embedding = await generateEmbedding(summary);
        if (!embedding) {
            log('Failed to generate embedding for STM summary. Skipping LTM storage for this cycle.', 'error');
            // If embedding generation itself fails, we might not want to reject the whole process,
            // as it could be a transient issue with the embedding service.
            // However, if processing stops here, the caller won't know unless inspecting logs.
            // For now, returning (not rejecting) to maintain previous behavior for this specific case.
            return;
        }
        const currentTime = new Date().toISOString();
        const kbData = {
            fact_id: uuidv4(),
            text_content: summary,
            text_content_embedding: embedding,
            source: `user_interaction_${userId}`,
            metadata: JSON.stringify({
                type: 'user_interaction_summary',
                userId: userId,
                goal: conversation.userGoal || null,
                turnCount: conversation.turnHistory.length,
            }),
            created_at: currentTime,
            updated_at: currentTime,
        };
        log('Adding user interaction summary to knowledge_base LTM.', kbData);
        await addRecord(db, 'knowledge_base', kbData); // This returns Promise.reject on failure
        log('Successfully processed and stored STM snapshot to LTM knowledge_base.');
    }
    catch (error) {
        log('Error during STM to LTM processing or LanceDB operation.', 'error', error);
        // Re-throw the error to allow the caller to handle LTM storage failures.
        return Promise.reject(error);
    }
}
/**
 * Retrieves relevant information from Long-Term Memory (LTM) based on a query.
 * Supports basic keyword filtering and optional recency boosting for results.
 * @param queryText The query text to search for.
 * @param userId The ID of the user, for context (can be null if not user-specific).
 * @param db The LanceDB connection object.
 * @param options Optional parameters to control retrieval:
 *   @param table - The LTM table to search (default: 'knowledge_base').
 *   @param topK - The number of results to return (default: 5).
 *   @param keywords - An array of keywords to filter by (uses LIKE '%keyword%'). Applied alongside vector search.
 *                     Primarily effective on 'text_content' (knowledge_base) or 'summary' (research_findings).
 *   @param boostRecency - If true, re-ranks results to balance similarity and recency (default: false).
 *   @param recencyWeight - Weight for recency score during re-ranking (0 to 1, default: 0.3). Only if boostRecency is true.
 *   @param similarityWeight - Weight for similarity score during re-ranking (0 to 1, default: 0.7). Only if boostRecency is true.
 * @returns A promise that resolves to an array of LTM query results, sorted by relevance.
 */
export async function retrieveRelevantLTM(queryText, userId, db, options) {
    log(`Retrieving relevant LTM for query: "${queryText}" (User: ${userId || 'N/A'})`, options);
    if (!db) {
        log('LanceDB connection not provided to retrieveRelevantLTM.', 'error');
        return Promise.reject(new Error('LanceDB connection not provided.'));
    }
    if (!queryText.trim()) {
        log('Query text is empty, skipping LTM retrieval.');
        return [];
    }
    try {
        const queryEmbedding = await generateEmbedding(queryText);
        if (!queryEmbedding) {
            log('Failed to generate query embedding. Cannot retrieve from LTM.', 'error');
            return [];
        }
        const initialTopK = options?.topK || 5;
        // If boosting recency, fetch more results initially for re-ranking
        const fetchTopK = options?.boostRecency ? initialTopK * 3 : initialTopK;
        let targetTable = options?.table || 'knowledge_base';
        let vectorColumnName = 'text_content_embedding'; // Default for knowledge_base
        let baseFilter = undefined;
        // Determine base filter and vector column based on table
        if (targetTable === 'user_profiles') {
            vectorColumnName = 'interaction_summary_embeddings'; // Corrected based on Step 1 analysis
            if (userId) {
                baseFilter = `user_id = '${userId}'`;
            }
            else {
                log('Warning: Searching user_profiles without a specific userId.', 'info');
            }
        }
        else if (targetTable === 'knowledge_base' && userId) {
            baseFilter = `source = 'user_interaction_${userId}'`;
        }
        else if (targetTable === 'research_findings') {
            vectorColumnName = 'summary_embedding'; // Or 'query_embedding' or both, field needs to exist
        }
        // Add more conditions for other tables or vector columns as needed
        // Incorporate keywords into the filter (Basic Hybrid Search)
        let combinedFilter = baseFilter;
        if (options?.keywords && options.keywords.length > 0) {
            const keywordConditions = options.keywords
                .map((kw) => {
                let textFieldToSearch = 'text_content'; // Default for knowledge_base
                if (targetTable === 'research_findings') {
                    textFieldToSearch = 'summary'; // Could also search 'details_text'
                }
                else if (targetTable === 'user_profiles') {
                    // User profiles might not have a single 'text_content' field for keyword search.
                    // This part needs careful consideration. For now, let's assume keywords are less relevant for 'user_profiles'
                    // or would apply to a specific text field if one exists (e.g., a bio).
                    // Sticking to knowledge_base and research_findings for keyword search for now.
                    if (targetTable !== 'knowledge_base' &&
                        targetTable !== 'research_findings')
                        return null;
                }
                return `${textFieldToSearch} LIKE '%${kw.replace(/'/g, "''")}%'`;
            })
                .filter(Boolean)
                .join(' AND '); // filter(Boolean) removes nulls
            if (keywordConditions) {
                if (combinedFilter) {
                    combinedFilter = `(${combinedFilter}) AND (${keywordConditions})`;
                }
                else {
                    combinedFilter = keywordConditions;
                }
            }
        }
        log(`Querying table '${targetTable}' with vector column '${vectorColumnName}', limit ${fetchTopK}, filter: '${combinedFilter || 'None'}'`);
        const rawSearchResults = await searchTable(db, targetTable, queryEmbedding, fetchTopK, vectorColumnName, combinedFilter);
        log(`Retrieved ${rawSearchResults.length} raw results from LTM table '${targetTable}'.`);
        let finalResults = rawSearchResults.map((item) => {
            let id = item.fact_id || item.user_id || item.finding_id || uuidv4();
            let text = item.text_content ||
                item.summary ||
                (item.preferences ? JSON.stringify(item.preferences) : 'N/A');
            if (targetTable === 'user_profiles') {
                text = `User Profile: ${item.user_id}, Prefs: ${item.preferences}, Summaries: ${item.interaction_summaries?.join('; ')}`;
            }
            return {
                id,
                text,
                score: item._distance, // LanceDB vector search distance (lower is better)
                metadata: item.metadata
                    ? typeof item.metadata === 'string'
                        ? JSON.parse(item.metadata)
                        : item.metadata
                    : { original_fields: item },
                table: targetTable,
                updated_at: item.updated_at, // Ensure updated_at is selected and available
            };
        });
        // Post-retrieval Re-ranking for Recency Boost
        if (options?.boostRecency && finalResults.length > 0) {
            log('Applying recency boost re-ranking...');
            const similarityWeight = options.similarityWeight !== undefined ? options.similarityWeight : 0.7;
            const recencyWeight = options.recencyWeight !== undefined ? options.recencyWeight : 0.3;
            // Get min/max timestamps for normalization (only from the current batch)
            const timestamps = finalResults
                .map((r) => new Date(r.updated_at).getTime())
                .filter((t) => !isNaN(t));
            const minTimestamp = Math.min(...timestamps);
            const maxTimestamp = Math.max(...timestamps);
            finalResults.forEach((result) => {
                // Normalize similarity score (1 - distance, so higher is better)
                const normalizedSimilarity = 1 - result.score;
                // Normalize recency score (0 to 1, higher is more recent)
                let normalizedRecency = 0.5; // Default if only one item or no valid date
                if (maxTimestamp > minTimestamp) {
                    const itemTimestamp = new Date(result.updated_at).getTime();
                    if (!isNaN(itemTimestamp)) {
                        normalizedRecency =
                            (itemTimestamp - minTimestamp) / (maxTimestamp - minTimestamp);
                    }
                }
                else if (timestamps.length === 1) {
                    // if all items have the exact same timestamp or only one item
                    normalizedRecency = 1;
                }
                // Combined score
                result.score =
                    similarityWeight * normalizedSimilarity +
                        recencyWeight * normalizedRecency;
                // log(`Re-ranking: ID ${result.id}, OrigDist: ${1-normalizedSimilarity}, NormSim: ${normalizedSimilarity}, NormRec: ${normalizedRecency}, NewScore: ${result.score}`);
            });
            // Sort by the new combined score in descending order (higher is better)
            finalResults.sort((a, b) => b.score - a.score);
            log(`Re-ranking complete. Top score after re-ranking: ${finalResults[0]?.score}`);
        }
        else {
            // If not boosting recency, ensure score is similarity (1-distance)
            finalResults.forEach((result) => {
                result.score = 1 - result.score; // Higher is better
            });
            finalResults.sort((a, b) => b.score - a.score); // Sort by similarity
        }
        return finalResults.slice(0, initialTopK);
    }
    catch (error) {
        log('Error during LTM retrieval or LanceDB operation.', 'error', error);
        return []; // Return empty array on error, or re-throw
    }
}
/**
 * Loads retrieved LTM results into the Short-Term Memory (STM) or conversation state.
 * @param results The LTM query results to load.
 * @param conversationStateActions An object containing functions to update the conversation state.
 */
export async function loadLTMToSTM(results, conversationStateActions) {
    log('Loading LTM results into STM...');
    if (!results || results.length === 0) {
        log('No LTM results to load.');
        conversationStateActions.updateLtmRepoContext(null); // Clear context if no results
        return;
    }
    // Update the main LTM context in conversation state
    conversationStateActions.updateLtmRepoContext(results);
    log(`LTM context updated in conversation state with ${results.length} items.`);
    // Example of further processing: update user goal based on the top LTM result
    // This is illustrative and can be expanded.
    const topResult = results[0];
    if (topResult &&
        topResult.table === 'user_profiles' &&
        topResult.metadata?.goal) {
        log(`Updating user goal from top LTM result: ${topResult.metadata.goal}`);
        conversationStateActions.updateUserGoal(topResult.metadata.goal);
    }
    else if (topResult && topResult.metadata?.summaryGoal) {
        // Check for a differently named field
        log(`Updating user goal from top LTM result's summaryGoal: ${topResult.metadata.summaryGoal}`);
        conversationStateActions.updateUserGoal(topResult.metadata.summaryGoal);
    }
    // Potentially update entities based on LTM results as well
    // Example: if entities are directly stored or inferable from LTM text/metadata
    // for (const result of results) {
    //   if (result.metadata?.entities && typeof result.metadata.entities === 'object') {
    //     log('Updating entities from LTM result:', result.metadata.entities);
    //     conversationStateActions.updateIntentAndEntities(null, result.metadata.entities as Record<string, any>);
    //     // Note: This might overwrite entities from NLU. Decide on merging strategy.
    //   }
    // }
    log('Finished loading LTM results and potentially updating parts of STM.');
}
// Example of how this manager might be initialized and used (conceptual)
/*
async function mainMemoryCycle(userId: string, currentQuery?: string) {
  log("Starting main memory cycle...");

  // It's better to initialize DB once and pass the connection around.
  // For this example, assume `dbConnection` is an already initialized lancedb.Connection object.
  // const dbConnection = await initializeDB('agent_ltm_db');
  // if (!dbConnection) {
  //   log("Failed to initialize LanceDB. Aborting memory cycle.", 'error');
  //   return;
  // }

  // 1. Potentially retrieve LTM based on current query to inform current turn
  if (currentQuery && dbConnection) { // Make sure dbConnection is valid
    const relevantLtm = await retrieveRelevantLTM(currentQuery, userId, dbConnection, { table: 'knowledge_base' });
    if (relevantLtm.length > 0) {
      await loadLTMToSTM(relevantLtm, {
        updateUserGoal: updateUserGoal,
        updateIntentAndEntities: updateIntentAndEntities,
      });
    }
  }

  // 2. After agent response and user interaction, process STM to LTM
  const currentConversationState = getConversationStateSnapshot();
  if (currentConversationState.isActive && dbConnection) { // Make sure dbConnection is valid
    await processSTMToLTM(userId, currentConversationState, dbConnection);
  }

  log("Main memory cycle finished.");
}
*/
log('MemoryManager module loaded with implemented LTM interaction functions.');
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVtb3J5TWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIm1lbW9yeU1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsd0dBQXdHO0FBVXhHLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0sa0JBQWtCLENBQUMsQ0FBQyxrQ0FBa0M7QUFDN0YsT0FBTyxFQUFFLEVBQUUsSUFBSSxNQUFNLEVBQUUsTUFBTSxNQUFNLENBQUMsQ0FBQyw0QkFBNEI7QUFDakUsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDLENBQUMsc0JBQXNCO0FBRW5ELDJGQUEyRjtBQUMzRiw0REFBNEQ7QUFDNUQsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLENBQUM7QUFFdEMsMkJBQTJCO0FBQzNCLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDO0FBQ2hELElBQUksWUFBWSxHQUFrQixJQUFJLENBQUM7QUFDdkMsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQUNqQixZQUFZLEdBQUcsSUFBSSxNQUFNLENBQUMsRUFBRSxNQUFNLEVBQUUsWUFBWSxFQUFFLENBQUMsQ0FBQztJQUNwRCxPQUFPLENBQUMsR0FBRyxDQUFDLDRDQUE0QyxDQUFDLENBQUM7QUFDNUQsQ0FBQztLQUFNLENBQUM7SUFDTixPQUFPLENBQUMsS0FBSyxDQUNYLG9JQUFvSSxDQUNySSxDQUFDO0FBQ0osQ0FBQztBQUVELFNBQVMsR0FBRyxDQUFDLE9BQWUsRUFBRSxRQUEwQixNQUFNLEVBQUUsSUFBVTtJQUN4RSxNQUFNLE1BQU0sR0FBRyxtQkFBbUIsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO0lBQzdELElBQUksS0FBSyxLQUFLLE9BQU8sRUFBRSxDQUFDO1FBQ3RCLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLGFBQWEsT0FBTyxFQUFFLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzdELENB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T0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzdCLElBQ0UsU0FBUztRQUNULFNBQVMsQ0FBQyxLQUFLLEtBQUssZUFBZTtRQUNuQyxTQUFTLENBQUMsUUFBUSxFQUFFLElBQUksRUFDeEIsQ0FBQztRQUNELEdBQUcsQ0FBQywyQ0FBMkMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQzFFLHdCQUF3QixDQUFDLGNBQWMsQ0FBQyxTQUFTLENBQUMsUUFBUSxDQUFDLElBQWMsQ0FBQyxDQUFDO0lBQzdFLENBQUM7U0FBTSxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsUUFBUSxFQUFFLFdBQVcsRUFBRSxDQUFDO1FBQ3hELHNDQUFzQztRQUN0QyxHQUFHLENBQ0QseURBQXlELFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLENBQzFGLENBQUM7UUFDRix3QkFBd0IsQ0FBQyxjQUFjLENBQ3JDLFNBQVMsQ0FBQyxRQUFRLENBQUMsV0FBcUIsQ0FDekMsQ0FBQztJQUNKLENBQUM7SUFDRCwyREFBMkQ7SUFDM0QsK0VBQStFO0lBQy9FLGtDQUFrQztJQUNsQyxxRkFBcUY7SUFDckYsMkVBQTJFO0lBQzNFLCtHQUErRztJQUMvRyxtRkFBbUY7SUFDbkYsTUFBTTtJQUNOLElBQUk7SUFDSixHQUFHLENBQUMscUVBQXFFLENBQUMsQ0FBQztBQUM3RSxDQUFDO0FBRUQseUVBQXlFO0FBQ3pFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBK0JFO0FBRUYsR0FBRyxDQUFDLHlFQUF5RSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYW5hZ2VzIHRoZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIFNob3J0LVRlcm0gTWVtb3J5IChTVE0pIGFuZCBMb25nLVRlcm0gTWVtb3J5IChMVE0pIHN0b3JlZCBpbiBMYW5jZURCLlxuXG5pbXBvcnQgKiBhcyBsYW5jZWRiIGZyb20gJ0BsYW5jZWRiL2xhbmNlZGInOyAvLyBGb3IgTGFuY2VEQiBjb25uZWN0aW9uIHR5cGVcbmltcG9ydCB7XG4gIGdldENvbnZlcnNhdGlvblN0YXRlU25hcHNob3QsIC8vIEFzc3VtaW5nIHRoaXMgaXMgaG93IHdlIG1pZ2h0IGdldCBhIHN0YXRlIGlmIG5vdCBwYXNzZWQgZGlyZWN0bHlcbiAgdXBkYXRlVXNlckdvYWwsXG4gIHVwZGF0ZUludGVudEFuZEVudGl0aWVzLFxuICAvLyBBZGQgb3RoZXIgcmVsZXZhbnQgYWN0aW9uIGltcG9ydHMgZnJvbSBjb252ZXJzYXRpb25TdGF0ZS50cyBhcyBuZWVkZWRcbn0gZnJvbSAnLi9jb252ZXJzYXRpb25TdGF0ZSc7IC8vIEFkanVzdCBwYXRoIGFzIG5lY2Vzc2FyeVxuaW1wb3J0IHR5cGUgeyBDb252ZXJzYXRpb25TdGF0ZSB9IGZyb20gJy4vY29udmVyc2F0aW9uU3RhdGUnOyAvLyBJbXBvcnQgdHlwZVxuaW1wb3J0IHsgYWRkUmVjb3JkLCBzZWFyY2hUYWJsZSB9IGZyb20gJy4vbGFuY2VEQk1hbmFnZXInOyAvLyBJbXBvcnQgREIgaW50ZXJhY3Rpb24gZnVuY3Rpb25zXG5pbXBvcnQgeyB2NCBhcyB1dWlkdjQgfSBmcm9tICd1dWlkJzsgLy8gRm9yIGdlbmVyYXRpbmcgdW5pcXVlIElEc1xuaW1wb3J0IE9wZW5BSSBmcm9tICdvcGVuYWknOyAvLyBBZGRlZCBPcGVuQUkgaW1wb3J0XG5cbi8vIE5PVEU6IERFRkFVTFRfVkVDVE9SX0RJTUVOU0lPTiBpcyA3NjggaGVyZSwgYnV0IHdhcyBjaGFuZ2VkIHRvIDE1MzYgaW4gbGFuY2VEQk1hbmFnZXIudHNcbi8vIFRoaXMgbmVlZHMgdG8gYmUgY29uc2lzdGVudC4gQXNzdW1pbmcgMTUzNiBpcyB0aGUgdGFyZ2V0LlxuY29uc3QgREVGQVVMVF9WRUNUT1JfRElNRU5TSU9OID0gMTUzNjtcblxuLy8gSW5pdGlhbGl6ZSBPcGVuQUkgQ2xpZW50XG5jb25zdCBvcGVuYWlBcGlLZXkgPSBwcm9jZXNzLmVudi5PUEVOQUlfQVBJX0tFWTtcbmxldCBvcGVuYWlDbGllbnQ6IE9wZW5BSSB8IG51bGwgPSBudWxsO1xuaWYgKG9wZW5haUFwaUtleSkge1xuICBvcGVuYWlDbGllbnQgPSBuZXcgT3BlbkFJKHsgYXBpS2V5OiBvcGVuYWlBcGlLZXkgfSk7XG4gIGNvbnNvbGUubG9nKCdbTWVtb3J5TWFuYWdlcl0gT3BlbkFJIGNsaWVudCBpbml0aWFsaXplZC4nKTtcbn0gZWxzZSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1tNZW1vcnlNYW5hZ2VyXSBPUEVOQUlfQVBJX0tFWSBub3QgZm91bmQgaW4gZW52aXJvbm1lbnQgdmFyaWFibGVzLiBSZWFsIGVtYmVkZGluZ3Mgd2lsbCBub3QgYmUgZ2VuZXJhdGVkIGJ5IFRTIHNpZGUgTWVtb3J5TWFuYWdlci4nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGxvZyhtZXNzYWdlOiBzdHJpbmcsIGxldmVsOiAnaW5mbycgfCAnZXJyb3InID0gJ2luZm8nLCBkYXRhPzogYW55KSB7XG4gIGNvbnN0IHByZWZpeCA9IGBbTWVtb3J5TWFuYWdlcl0gJHtuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCl9YDtcbiAgaWYgKGxldmVsID09PSAnZXJyb3InKSB7XG4gICAgY29uc29sZS5lcnJvcihgJHtwcmVmaXh9IFtFUlJPUl06ICR7bWVzc2FnZX1gLCBkYXRhIHx8ICcnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmxvZyhgJHtwcmVmaXh9OiAke21lc3NhZ2V9YCwgZGF0YSB8fCAnJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBQbGFjZWhvbGRlciBmb3IgZ2VuZXJhdGluZyBlbWJlZGRpbmdzLlxuICogSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB0aGlzIHdvdWxkIGNhbGwgYW4gYWN0dWFsIGVtYmVkZGluZyBtb2RlbC5cbiAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGVtYmVkLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYSB2ZWN0b3IgKGFycmF5IG9mIG51bWJlcnMpIG9yIG51bGwgaWYgYW4gZXJyb3Igb2NjdXJzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVFbWJlZGRpbmcoXG4gIHRleHQ6IHN0cmluZ1xuKTogUHJvbWlzZTxudW1iZXJbXSB8IG51bGw+IHtcbiAgaWYgKCFvcGVuYWlDbGllbnQpIHtcbiAgICBsb2coXG4gICAgICAnW01lbW9yeU1hbmFnZXJdIE9wZW5BSSBjbGllbnQgbm90IGluaXRpYWxpemVkLiBDYW5ub3QgZ2VuZXJhdGUgcmVhbCBlbWJlZGRpbmcuIFJldHVybmluZyBudWxsLicsXG4gICAgICAnZXJyb3InXG4gICAgKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIXRleHQgfHwgdGV4dC50cmltKCkgPT09ICcnKSB7XG4gICAgbG9nKFxuICAgICAgJ1tNZW1vcnlNYW5hZ2VyXSBnZW5lcmF0ZUVtYmVkZGluZyBjYWxsZWQgd2l0aCBlbXB0eSBvciB3aGl0ZXNwYWNlLW9ubHkgdGV4dC4gUmV0dXJuaW5nIG51bGwuJyxcbiAgICAgICd3YXJuJ1xuICAgICk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB0cmltbWVkVGV4dCA9IHRleHQudHJpbSgpO1xuICBsb2coXG4gICAgYEdlbmVyYXRpbmcgT3BlbkFJIGVtYmVkZGluZyBmb3IgdGV4dCAoZmlyc3QgNTAgY2hhcnMpOiBcIiR7dHJpbW1lZFRleHQuc3Vic3RyaW5nKDAsIDUwKX0uLi5cImBcbiAgKTtcblxuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgb3BlbmFpQ2xpZW50LmVtYmVkZGluZ3MuY3JlYXRlKHtcbiAgICAgIG1vZGVsOiAndGV4dC1lbWJlZGRpbmctYWRhLTAwMicsIC8vIFRoaXMgbW9kZWwgb3V0cHV0cyAxNTM2IGRpbWVuc2lvbnNcbiAgICAgIGlucHV0OiB0cmltbWVkVGV4dCxcbiAgICB9KTtcbiAgICBpZiAoXG4gICAgICByZXNwb25zZS5kYXRhICYmXG4gICAgICByZXNwb25zZS5kYXRhLmxlbmd0aCA+IDAgJiZcbiAgICAgIHJlc3BvbnNlLmRhdGFbMF0uZW1iZWRkaW5nXG4gICAgKSB7XG4gICAgICBsb2coXG4gICAgICAgIGBTdWNjZXNzZnVsbHkgZ2VuZXJhdGVkIE9wZW5BSSBlbWJlZGRpbmcuIERpbWVuc2lvbjogJHtyZXNwb25zZS5kYXRhWzBdLmVtYmVkZGluZy5sZW5ndGh9YFxuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5kYXRhWzBdLmVtYmVkZGluZy5sZW5ndGggIT09IERFRkFVTFRfVkVDVE9SX0RJTUVOU0lPTikge1xuICAgICAgICBsb2coXG4gICAgICAgICAgYFtNZW1vcnlNYW5hZ2VyXSBXQVJOSU5HOiBPcGVuQUkgZW1iZWRkaW5nIGRpbWVuc2lvbiAoJHtyZXNwb25zZS5kYXRhWzBdLmVtYmVkZGluZy5sZW5ndGh9KSBkb2VzIG5vdCBtYXRjaCBERUZBVUxUX1ZFQ1RPUl9ESU1FTlNJT04gKCR7REVGQVVMVF9WRUNUT1JfRElNRU5TSU9OfSkuIENoZWNrIG1vZGVsIGFuZCBjb25maWcuYCxcbiAgICAgICAgICAnd2FybidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXNwb25zZS5kYXRhWzBdLmVtYmVkZGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgbG9nKFxuICAgICAgICAnW01lbW9yeU1hbmFnZXJdIE9wZW5BSSBlbWJlZGRpbmcgcmVzcG9uc2UgaXMgbWlzc2luZyBleHBlY3RlZCBkYXRhLicsXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIHJlc3BvbnNlXG4gICAgICApO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZygnW01lbW9yeU1hbmFnZXJdIEVycm9yIGdlbmVyYXRpbmcgT3BlbkFJIGVtYmVkZGluZzonLCAnZXJyb3InLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMdG1RdWVyeVJlc3VsdCB7XG4gIGlkOiBzdHJpbmc7XG4gIHRleHQ6IHN0cmluZzsgLy8gQ291bGQgYmUgc3VtbWFyeSwgZmFjdCwgZXRjLlxuICBzY29yZTogbnVtYmVyOyAvLyBSZWxldmFuY2Ugc2NvcmUgZnJvbSB2ZWN0b3Igc2VhcmNoXG4gIG1ldGFkYXRhPzogUmVjb3JkPHN0cmluZywgYW55PjtcbiAgdGFibGU6IHN0cmluZzsgLy8gU291cmNlIHRhYmxlXG59XG5cbi8qKlxuICogUHJvY2Vzc2VzIFNob3J0LVRlcm0gTWVtb3J5IChTVE0pIGFuZCBkZWNpZGVzIHdoYXQgdG8gc3RvcmUgaW4gTG9uZy1UZXJtIE1lbW9yeSAoTFRNKS5cbiAqIElmIHN1Y2Nlc3NmdWwsIHJlc29sdmVzIHRoZSBwcm9taXNlLiBJZiBhIGNyaXRpY2FsIGVycm9yIG9jY3VycyBkdXJpbmcgTFRNIHN0b3JhZ2UgKGUuZy4sIERCIGVycm9yKSxcbiAqIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkLiBGYWlsdXJlIHRvIGdlbmVyYXRlIGFuIGVtYmVkZGluZyBsb2dzIGFuIGVycm9yIGJ1dCBkb2VzIG5vdCBjYXVzZSBhIHJlamVjdGlvbi5cbiAqIEBwYXJhbSB1c2VySWQgVGhlIElEIG9mIHRoZSB1c2VyLlxuICogQHBhcmFtIGNvbnZlcnNhdGlvbiBUaGUgY3VycmVudCBjb252ZXJzYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gZGIgVGhlIExhbmNlREIgY29ubmVjdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyBpZiBwcm9jZXNzaW5nIGlzIHN1Y2Nlc3NmdWwgb3IgaWYgZW1iZWRkaW5nIGZhaWxzICh3aXRoIGxvZ2dlZCBlcnJvciksXG4gKiAgICAgICAgICBhbmQgcmVqZWN0cyBpZiB0aGVyZSdzIGEgY3JpdGljYWwgZXJyb3IgZHVyaW5nIExUTSBzdG9yYWdlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1NUTVRvTFRNKFxuICB1c2VySWQ6IHN0cmluZyxcbiAgY29udmVyc2F0aW9uOiBDb252ZXJzYXRpb25TdGF0ZSxcbiAgZGI6IGxhbmNlZGIuQ29ubmVjdGlvblxuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGxvZyhgUHJvY2Vzc2luZyBTVE0gdG8gTFRNIGZvciB1c2VyOiAke3VzZXJJZH1gKTtcbiAgLy8gbG9nKCdDdXJyZW50IGNvbnZlcnNhdGlvbiBzdGF0ZSByZWNlaXZlZDonLCBjb252ZXJzYXRpb24pOyAvLyBDYW4gYmUgdG9vIHZlcmJvc2VcblxuICBpZiAoIWRiKSB7XG4gICAgbG9nKCdMYW5jZURCIGNvbm5lY3Rpb24gbm90IHByb3ZpZGVkIHRvIHByb2Nlc3NTVE1Ub0xUTS4nLCAnZXJyb3InKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdMYW5jZURCIGNvbm5lY3Rpb24gbm90IHByb3ZpZGVkLicpKTtcbiAgfVxuXG4gIGxldCBzdW1tYXJ5ID0gJyc7XG4gIGlmIChjb252ZXJzYXRpb24udXNlckdvYWwpIHtcbiAgICBzdW1tYXJ5ICs9IGBVc2VyIEdvYWw6ICR7Y29udmVyc2F0aW9uLnVzZXJHb2FsfS4gYDtcbiAgfVxuXG4gIGNvbnN0IHJlY2VudFR1cm5zID0gY29udmVyc2F0aW9uLnR1cm5IaXN0b3J5LnNsaWNlKC0yKTsgLy8gTGFzdCAyIHR1cm5zXG4gIGlmIChyZWNlbnRUdXJucy5sZW5ndGggPiAwKSB7XG4gICAgc3VtbWFyeSArPSByZWNlbnRUdXJuc1xuICAgICAgLm1hcChcbiAgICAgICAgKHR1cm4pID0+XG4gICAgICAgICAgYFVzZXI6ICR7dHVybi51c2VySW5wdXR9IHwgQWdlbnQ6ICR7SlNPTi5zdHJpbmdpZnkodHVybi5hZ2VudFJlc3BvbnNlKS5zdWJzdHJpbmcoMCwgMTUwKX0uLi5gXG4gICAgICApXG4gICAgICAuam9pbignOyAnKTtcbiAgfVxuXG4gIGlmICghc3VtbWFyeS50cmltKCkpIHtcbiAgICBsb2coJ05vIHNpZ25pZmljYW50IGluZm9ybWF0aW9uIGZvdW5kIGluIFNUTSB0byBwcm9jZXNzIGZvciBMVE0uJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbG9nKGBHZW5lcmF0ZWQgc3VtbWFyeSBmb3IgTFRNOiBcIiR7c3VtbWFyeS5zdWJzdHJpbmcoMCwgMjAwKX0uLi5cImApO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZW1iZWRkaW5nID0gYXdhaXQgZ2VuZXJhdGVFbWJlZGRpbmcoc3VtbWFyeSk7XG4gICAgaWYgKCFlbWJlZGRpbmcpIHtcbiAgICAgIGxvZyhcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBlbWJlZGRpbmcgZm9yIFNUTSBzdW1tYXJ5LiBTa2lwcGluZyBMVE0gc3RvcmFnZSBmb3IgdGhpcyBjeWNsZS4nLFxuICAgICAgICAnZXJyb3InXG4gICAgICApO1xuICAgICAgLy8gSWYgZW1iZWRkaW5nIGdlbmVyYXRpb24gaXRzZWxmIGZhaWxzLCB3ZSBtaWdodCBub3Qgd2FudCB0byByZWplY3QgdGhlIHdob2xlIHByb2Nlc3MsXG4gICAgICAvLyBhcyBpdCBjb3VsZCBiZSBhIHRyYW5zaWVudCBpc3N1ZSB3aXRoIHRoZSBlbWJlZGRpbmcgc2VydmljZS5cbiAgICAgIC8vIEhvd2V2ZXIsIGlmIHByb2Nlc3Npbmcgc3RvcHMgaGVyZSwgdGhlIGNhbGxlciB3b24ndCBrbm93IHVubGVzcyBpbnNwZWN0aW5nIGxvZ3MuXG4gICAgICAvLyBGb3Igbm93LCByZXR1cm5pbmcgKG5vdCByZWplY3RpbmcpIHRvIG1haW50YWluIHByZXZpb3VzIGJlaGF2aW9yIGZvciB0aGlzIHNwZWNpZmljIGNhc2UuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKS50b0lTT1N0cmluZygpO1xuXG4gICAgY29uc3Qga2JEYXRhID0ge1xuICAgICAgZmFjdF9pZDogdXVpZHY0KCksXG4gICAgICB0ZXh0X2NvbnRlbnQ6IHN1bW1hcnksXG4gICAgICB0ZXh0X2NvbnRlbnRfZW1iZWRkaW5nOiBlbWJlZGRpbmcsXG4gICAgICBzb3VyY2U6IGB1c2VyX2ludGVyYWN0aW9uXyR7dXNlcklkfWAsXG4gICAgICBtZXRhZGF0YTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICB0eXBlOiAndXNlcl9pbnRlcmFjdGlvbl9zdW1tYXJ5JyxcbiAgICAgICAgdXNlcklkOiB1c2VySWQsXG4gICAgICAgIGdvYWw6IGNvbnZlcnNhdGlvbi51c2VyR29hbCB8fCBudWxsLFxuICAgICAgICB0dXJuQ291bnQ6IGNvbnZlcnNhdGlvbi50dXJuSGlzdG9yeS5sZW5ndGgsXG4gICAgICB9KSxcbiAgICAgIGNyZWF0ZWRfYXQ6IGN1cnJlbnRUaW1lLFxuICAgICAgdXBkYXRlZF9hdDogY3VycmVudFRpbWUsXG4gICAgfTtcblxuICAgIGxvZygnQWRkaW5nIHVzZXIgaW50ZXJhY3Rpb24gc3VtbWFyeSB0byBrbm93bGVkZ2VfYmFzZSBMVE0uJywga2JEYXRhKTtcbiAgICBhd2FpdCBhZGRSZWNvcmQoZGIsICdrbm93bGVkZ2VfYmFzZScsIGtiRGF0YSk7IC8vIFRoaXMgcmV0dXJucyBQcm9taXNlLnJlamVjdCBvbiBmYWlsdXJlXG4gICAgbG9nKFxuICAgICAgJ1N1Y2Nlc3NmdWxseSBwcm9jZXNzZWQgYW5kIHN0b3JlZCBTVE0gc25hcHNob3QgdG8gTFRNIGtub3dsZWRnZV9iYXNlLidcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGxvZyhcbiAgICAgICdFcnJvciBkdXJpbmcgU1RNIHRvIExUTSBwcm9jZXNzaW5nIG9yIExhbmNlREIgb3BlcmF0aW9uLicsXG4gICAgICAnZXJyb3InLFxuICAgICAgZXJyb3JcbiAgICApO1xuICAgIC8vIFJlLXRocm93IHRoZSBlcnJvciB0byBhbGxvdyB0aGUgY2FsbGVyIHRvIGhhbmRsZSBMVE0gc3RvcmFnZSBmYWlsdXJlcy5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG59XG5cbi8qKlxuICogUmV0cmlldmVzIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gTG9uZy1UZXJtIE1lbW9yeSAoTFRNKSBiYXNlZCBvbiBhIHF1ZXJ5LlxuICogU3VwcG9ydHMgYmFzaWMga2V5d29yZCBmaWx0ZXJpbmcgYW5kIG9wdGlvbmFsIHJlY2VuY3kgYm9vc3RpbmcgZm9yIHJlc3VsdHMuXG4gKiBAcGFyYW0gcXVlcnlUZXh0IFRoZSBxdWVyeSB0ZXh0IHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0gdXNlcklkIFRoZSBJRCBvZiB0aGUgdXNlciwgZm9yIGNvbnRleHQgKGNhbiBiZSBudWxsIGlmIG5vdCB1c2VyLXNwZWNpZmljKS5cbiAqIEBwYXJhbSBkYiBUaGUgTGFuY2VEQiBjb25uZWN0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIHBhcmFtZXRlcnMgdG8gY29udHJvbCByZXRyaWV2YWw6XG4gKiAgIEBwYXJhbSB0YWJsZSAtIFRoZSBMVE0gdGFibGUgdG8gc2VhcmNoIChkZWZhdWx0OiAna25vd2xlZGdlX2Jhc2UnKS5cbiAqICAgQHBhcmFtIHRvcEsgLSBUaGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuIChkZWZhdWx0OiA1KS5cbiAqICAgQHBhcmFtIGtleXdvcmRzIC0gQW4gYXJyYXkgb2Yga2V5d29yZHMgdG8gZmlsdGVyIGJ5ICh1c2VzIExJS0UgJyVrZXl3b3JkJScpLiBBcHBsaWVkIGFsb25nc2lkZSB2ZWN0b3Igc2VhcmNoLlxuICogICAgICAgICAgICAgICAgICAgICBQcmltYXJpbHkgZWZmZWN0aXZlIG9uICd0ZXh0X2NvbnRlbnQnIChrbm93bGVkZ2VfYmFzZSkgb3IgJ3N1bW1hcnknIChyZXNlYXJjaF9maW5kaW5ncykuXG4gKiAgIEBwYXJhbSBib29zdFJlY2VuY3kgLSBJZiB0cnVlLCByZS1yYW5rcyByZXN1bHRzIHRvIGJhbGFuY2Ugc2ltaWxhcml0eSBhbmQgcmVjZW5jeSAoZGVmYXVsdDogZmFsc2UpLlxuICogICBAcGFyYW0gcmVjZW5jeVdlaWdodCAtIFdlaWdodCBmb3IgcmVjZW5jeSBzY29yZSBkdXJpbmcgcmUtcmFua2luZyAoMCB0byAxLCBkZWZhdWx0OiAwLjMpLiBPbmx5IGlmIGJvb3N0UmVjZW5jeSBpcyB0cnVlLlxuICogICBAcGFyYW0gc2ltaWxhcml0eVdlaWdodCAtIFdlaWdodCBmb3Igc2ltaWxhcml0eSBzY29yZSBkdXJpbmcgcmUtcmFua2luZyAoMCB0byAxLCBkZWZhdWx0OiAwLjcpLiBPbmx5IGlmIGJvb3N0UmVjZW5jeSBpcyB0cnVlLlxuICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gYXJyYXkgb2YgTFRNIHF1ZXJ5IHJlc3VsdHMsIHNvcnRlZCBieSByZWxldmFuY2UuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZXRyaWV2ZVJlbGV2YW50TFRNKFxuICBxdWVyeVRleHQ6IHN0cmluZyxcbiAgdXNlcklkOiBzdHJpbmcgfCBudWxsLFxuICBkYjogbGFuY2VkYi5Db25uZWN0aW9uLFxuICBvcHRpb25zPzoge1xuICAgIHRhYmxlPzogc3RyaW5nO1xuICAgIHRvcEs/OiBudW1iZXI7XG4gICAga2V5d29yZHM/OiBzdHJpbmdbXTsgLy8gS2V5d29yZHMgZm9yIGJhc2ljIGZpbHRlcmluZ1xuICAgIGJvb3N0UmVjZW5jeT86IGJvb2xlYW47IC8vIEZsYWcgdG8gZW5hYmxlIHJlY2VuY3kgYm9vc3RpbmdcbiAgICByZWNlbmN5V2VpZ2h0PzogbnVtYmVyOyAvLyBXZWlnaHQgZm9yIHJlY2VuY3kgc2NvcmUgKDAgdG8gMSksIGFwcGxpZXMgaWYgYm9vc3RSZWNlbmN5IGlzIHRydWVcbiAgICBzaW1pbGFyaXR5V2VpZ2h0PzogbnVtYmVyOyAvLyBXZWlnaHQgZm9yIHNpbWlsYXJpdHkgc2NvcmUgKDAgdG8gMSksIGFwcGxpZXMgaWYgYm9vc3RSZWNlbmN5IGlzIHRydWVcbiAgfVxuKTogUHJvbWlzZTxMdG1RdWVyeVJlc3VsdFtdPiB7XG4gIGxvZyhcbiAgICBgUmV0cmlldmluZyByZWxldmFudCBMVE0gZm9yIHF1ZXJ5OiBcIiR7cXVlcnlUZXh0fVwiIChVc2VyOiAke3VzZXJJZCB8fCAnTi9BJ30pYCxcbiAgICBvcHRpb25zXG4gICk7XG5cbiAgaWYgKCFkYikge1xuICAgIGxvZygnTGFuY2VEQiBjb25uZWN0aW9uIG5vdCBwcm92aWRlZCB0byByZXRyaWV2ZVJlbGV2YW50TFRNLicsICdlcnJvcicpO1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0xhbmNlREIgY29ubmVjdGlvbiBub3QgcHJvdmlkZWQuJykpO1xuICB9XG5cbiAgaWYgKCFxdWVyeVRleHQudHJpbSgpKSB7XG4gICAgbG9nKCdRdWVyeSB0ZXh0IGlzIGVtcHR5LCBza2lwcGluZyBMVE0gcmV0cmlldmFsLicpO1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnlFbWJlZGRpbmcgPSBhd2FpdCBnZW5lcmF0ZUVtYmVkZGluZyhxdWVyeVRleHQpO1xuICAgIGlmICghcXVlcnlFbWJlZGRpbmcpIHtcbiAgICAgIGxvZyhcbiAgICAgICAgJ0ZhaWxlZCB0byBnZW5lcmF0ZSBxdWVyeSBlbWJlZGRpbmcuIENhbm5vdCByZXRyaWV2ZSBmcm9tIExUTS4nLFxuICAgICAgICAnZXJyb3InXG4gICAgICApO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxUb3BLID0gb3B0aW9ucz8udG9wSyB8fCA1O1xuICAgIC8vIElmIGJvb3N0aW5nIHJlY2VuY3ksIGZldGNoIG1vcmUgcmVzdWx0cyBpbml0aWFsbHkgZm9yIHJlLXJhbmtpbmdcbiAgICBjb25zdCBmZXRjaFRvcEsgPSBvcHRpb25zPy5ib29zdFJlY2VuY3kgPyBpbml0aWFsVG9wSyAqIDMgOiBpbml0aWFsVG9wSztcblxuICAgIGxldCB0YXJnZXRUYWJsZSA9IG9wdGlvbnM/LnRhYmxlIHx8ICdrbm93bGVkZ2VfYmFzZSc7XG4gICAgbGV0IHZlY3RvckNvbHVtbk5hbWUgPSAndGV4dF9jb250ZW50X2VtYmVkZGluZyc7IC8vIERlZmF1bHQgZm9yIGtub3dsZWRnZV9iYXNlXG4gICAgbGV0IGJhc2VGaWx0ZXI6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAgIC8vIERldGVybWluZSBiYXNlIGZpbHRlciBhbmQgdmVjdG9yIGNvbHVtbiBiYXNlZCBvbiB0YWJsZVxuICAgIGlmICh0YXJnZXRUYWJsZSA9PT0gJ3VzZXJfcHJvZmlsZXMnKSB7XG4gICAgICB2ZWN0b3JDb2x1bW5OYW1lID0gJ2ludGVyYWN0aW9uX3N1bW1hcnlfZW1iZWRkaW5ncyc7IC8vIENvcnJlY3RlZCBiYXNlZCBvbiBTdGVwIDEgYW5hbHlzaXNcbiAgICAgIGlmICh1c2VySWQpIHtcbiAgICAgICAgYmFzZUZpbHRlciA9IGB1c2VyX2lkID0gJyR7dXNlcklkfSdgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKFxuICAgICAgICAgICdXYXJuaW5nOiBTZWFyY2hpbmcgdXNlcl9wcm9maWxlcyB3aXRob3V0IGEgc3BlY2lmaWMgdXNlcklkLicsXG4gICAgICAgICAgJ2luZm8nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YXJnZXRUYWJsZSA9PT0gJ2tub3dsZWRnZV9iYXNlJyAmJiB1c2VySWQpIHtcbiAgICAgIGJhc2VGaWx0ZXIgPSBgc291cmNlID0gJ3VzZXJfaW50ZXJhY3Rpb25fJHt1c2VySWR9J2A7XG4gICAgfSBlbHNlIGlmICh0YXJnZXRUYWJsZSA9PT0gJ3Jlc2VhcmNoX2ZpbmRpbmdzJykge1xuICAgICAgdmVjdG9yQ29sdW1uTmFtZSA9ICdzdW1tYXJ5X2VtYmVkZGluZyc7IC8vIE9yICdxdWVyeV9lbWJlZGRpbmcnIG9yIGJvdGgsIGZpZWxkIG5lZWRzIHRvIGV4aXN0XG4gICAgfVxuICAgIC8vIEFkZCBtb3JlIGNvbmRpdGlvbnMgZm9yIG90aGVyIHRhYmxlcyBvciB2ZWN0b3IgY29sdW1ucyBhcyBuZWVkZWRcblxuICAgIC8vIEluY29ycG9yYXRlIGtleXdvcmRzIGludG8gdGhlIGZpbHRlciAoQmFzaWMgSHlicmlkIFNlYXJjaClcbiAgICBsZXQgY29tYmluZWRGaWx0ZXIgPSBiYXNlRmlsdGVyO1xuICAgIGlmIChvcHRpb25zPy5rZXl3b3JkcyAmJiBvcHRpb25zLmtleXdvcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGtleXdvcmRDb25kaXRpb25zID0gb3B0aW9ucy5rZXl3b3Jkc1xuICAgICAgICAubWFwKChrdykgPT4ge1xuICAgICAgICAgIGxldCB0ZXh0RmllbGRUb1NlYXJjaCA9ICd0ZXh0X2NvbnRlbnQnOyAvLyBEZWZhdWx0IGZvciBrbm93bGVkZ2VfYmFzZVxuICAgICAgICAgIGlmICh0YXJnZXRUYWJsZSA9PT0gJ3Jlc2VhcmNoX2ZpbmRpbmdzJykge1xuICAgICAgICAgICAgdGV4dEZpZWxkVG9TZWFyY2ggPSAnc3VtbWFyeSc7IC8vIENvdWxkIGFsc28gc2VhcmNoICdkZXRhaWxzX3RleHQnXG4gICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRUYWJsZSA9PT0gJ3VzZXJfcHJvZmlsZXMnKSB7XG4gICAgICAgICAgICAvLyBVc2VyIHByb2ZpbGVzIG1pZ2h0IG5vdCBoYXZlIGEgc2luZ2xlICd0ZXh0X2NvbnRlbnQnIGZpZWxkIGZvciBrZXl3b3JkIHNlYXJjaC5cbiAgICAgICAgICAgIC8vIFRoaXMgcGFydCBuZWVkcyBjYXJlZnVsIGNvbnNpZGVyYXRpb24uIEZvciBub3csIGxldCdzIGFzc3VtZSBrZXl3b3JkcyBhcmUgbGVzcyByZWxldmFudCBmb3IgJ3VzZXJfcHJvZmlsZXMnXG4gICAgICAgICAgICAvLyBvciB3b3VsZCBhcHBseSB0byBhIHNwZWNpZmljIHRleHQgZmllbGQgaWYgb25lIGV4aXN0cyAoZS5nLiwgYSBiaW8pLlxuICAgICAgICAgICAgLy8gU3RpY2tpbmcgdG8ga25vd2xlZGdlX2Jhc2UgYW5kIHJlc2VhcmNoX2ZpbmRpbmdzIGZvciBrZXl3b3JkIHNlYXJjaCBmb3Igbm93LlxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICB0YXJnZXRUYWJsZSAhPT0gJ2tub3dsZWRnZV9iYXNlJyAmJlxuICAgICAgICAgICAgICB0YXJnZXRUYWJsZSAhPT0gJ3Jlc2VhcmNoX2ZpbmRpbmdzJ1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGAke3RleHRGaWVsZFRvU2VhcmNofSBMSUtFICclJHtrdy5yZXBsYWNlKC8nL2csIFwiJydcIil9JSdgO1xuICAgICAgICB9KVxuICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgIC5qb2luKCcgQU5EICcpOyAvLyBmaWx0ZXIoQm9vbGVhbikgcmVtb3ZlcyBudWxsc1xuXG4gICAgICBpZiAoa2V5d29yZENvbmRpdGlvbnMpIHtcbiAgICAgICAgaWYgKGNvbWJpbmVkRmlsdGVyKSB7XG4gICAgICAgICAgY29tYmluZWRGaWx0ZXIgPSBgKCR7Y29tYmluZWRGaWx0ZXJ9KSBBTkQgKCR7a2V5d29yZENvbmRpdGlvbnN9KWA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tYmluZWRGaWx0ZXIgPSBrZXl3b3JkQ29uZGl0aW9ucztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxvZyhcbiAgICAgIGBRdWVyeWluZyB0YWJsZSAnJHt0YXJnZXRUYWJsZX0nIHdpdGggdmVjdG9yIGNvbHVtbiAnJHt2ZWN0b3JDb2x1bW5OYW1lfScsIGxpbWl0ICR7ZmV0Y2hUb3BLfSwgZmlsdGVyOiAnJHtjb21iaW5lZEZpbHRlciB8fCAnTm9uZSd9J2BcbiAgICApO1xuXG4gICAgY29uc3QgcmF3U2VhcmNoUmVzdWx0cyA9IGF3YWl0IHNlYXJjaFRhYmxlKFxuICAgICAgZGIsXG4gICAgICB0YXJnZXRUYWJsZSxcbiAgICAgIHF1ZXJ5RW1iZWRkaW5nLFxuICAgICAgZmV0Y2hUb3BLLFxuICAgICAgdmVjdG9yQ29sdW1uTmFtZSxcbiAgICAgIGNvbWJpbmVkRmlsdGVyXG4gICAgKTtcbiAgICBsb2coXG4gICAgICBgUmV0cmlldmVkICR7cmF3U2VhcmNoUmVzdWx0cy5sZW5ndGh9IHJhdyByZXN1bHRzIGZyb20gTFRNIHRhYmxlICcke3RhcmdldFRhYmxlfScuYFxuICAgICk7XG5cbiAgICBsZXQgZmluYWxSZXN1bHRzID0gcmF3U2VhcmNoUmVzdWx0cy5tYXAoKGl0ZW06IGFueSkgPT4ge1xuICAgICAgbGV0IGlkID0gaXRlbS5mYWN0X2lkIHx8IGl0ZW0udXNlcl9pZCB8fCBpdGVtLmZpbmRpbmdfaWQgfHwgdXVpZHY0KCk7XG4gICAgICBsZXQgdGV4dCA9XG4gICAgICAgIGl0ZW0udGV4dF9jb250ZW50IHx8XG4gICAgICAgIGl0ZW0uc3VtbWFyeSB8fFxuICAgICAgICAoaXRlbS5wcmVmZXJlbmNlcyA/IEpTT04uc3RyaW5naWZ5KGl0ZW0ucHJlZmVyZW5jZXMpIDogJ04vQScpO1xuICAgICAgaWYgKHRhcmdldFRhYmxlID09PSAndXNlcl9wcm9maWxlcycpIHtcbiAgICAgICAgdGV4dCA9IGBVc2VyIFByb2ZpbGU6ICR7aXRlbS51c2VyX2lkfSwgUHJlZnM6ICR7aXRlbS5wcmVmZXJlbmNlc30sIFN1bW1hcmllczogJHtpdGVtLmludGVyYWN0aW9uX3N1bW1hcmllcz8uam9pbignOyAnKX1gO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHRleHQsXG4gICAgICAgIHNjb3JlOiBpdGVtLl9kaXN0YW5jZSwgLy8gTGFuY2VEQiB2ZWN0b3Igc2VhcmNoIGRpc3RhbmNlIChsb3dlciBpcyBiZXR0ZXIpXG4gICAgICAgIG1ldGFkYXRhOiBpdGVtLm1ldGFkYXRhXG4gICAgICAgICAgPyB0eXBlb2YgaXRlbS5tZXRhZGF0YSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgID8gSlNPTi5wYXJzZShpdGVtLm1ldGFkYXRhKVxuICAgICAgICAgICAgOiBpdGVtLm1ldGFkYXRhXG4gICAgICAgICAgOiB7IG9yaWdpbmFsX2ZpZWxkczogaXRlbSB9LFxuICAgICAgICB0YWJsZTogdGFyZ2V0VGFibGUsXG4gICAgICAgIHVwZGF0ZWRfYXQ6IGl0ZW0udXBkYXRlZF9hdCwgLy8gRW5zdXJlIHVwZGF0ZWRfYXQgaXMgc2VsZWN0ZWQgYW5kIGF2YWlsYWJsZVxuICAgICAgfTtcbiAgICB9KTtcblxuICAgIC8vIFBvc3QtcmV0cmlldmFsIFJlLXJhbmtpbmcgZm9yIFJlY2VuY3kgQm9vc3RcbiAgICBpZiAob3B0aW9ucz8uYm9vc3RSZWNlbmN5ICYmIGZpbmFsUmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICBsb2coJ0FwcGx5aW5nIHJlY2VuY3kgYm9vc3QgcmUtcmFua2luZy4uLicpO1xuICAgICAgY29uc3Qgc2ltaWxhcml0eVdlaWdodCA9XG4gICAgICAgIG9wdGlvbnMuc2ltaWxhcml0eVdlaWdodCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5zaW1pbGFyaXR5V2VpZ2h0IDogMC43O1xuICAgICAgY29uc3QgcmVjZW5jeVdlaWdodCA9XG4gICAgICAgIG9wdGlvbnMucmVjZW5jeVdlaWdodCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5yZWNlbmN5V2VpZ2h0IDogMC4zO1xuXG4gICAgICAvLyBHZXQgbWluL21heCB0aW1lc3RhbXBzIGZvciBub3JtYWxpemF0aW9uIChvbmx5IGZyb20gdGhlIGN1cnJlbnQgYmF0Y2gpXG4gICAgICBjb25zdCB0aW1lc3RhbXBzID0gZmluYWxSZXN1bHRzXG4gICAgICAgIC5tYXAoKHIpID0+IG5ldyBEYXRlKHIudXBkYXRlZF9hdCkuZ2V0VGltZSgpKVxuICAgICAgICAuZmlsdGVyKCh0KSA9PiAhaXNOYU4odCkpO1xuICAgICAgY29uc3QgbWluVGltZXN0YW1wID0gTWF0aC5taW4oLi4udGltZXN0YW1wcyk7XG4gICAgICBjb25zdCBtYXhUaW1lc3RhbXAgPSBNYXRoLm1heCguLi50aW1lc3RhbXBzKTtcblxuICAgICAgZmluYWxSZXN1bHRzLmZvckVhY2goKHJlc3VsdCkgPT4ge1xuICAgICAgICAvLyBOb3JtYWxpemUgc2ltaWxhcml0eSBzY29yZSAoMSAtIGRpc3RhbmNlLCBzbyBoaWdoZXIgaXMgYmV0dGVyKVxuICAgICAgICBjb25zdCBub3JtYWxpemVkU2ltaWxhcml0eSA9IDEgLSByZXN1bHQuc2NvcmU7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHJlY2VuY3kgc2NvcmUgKDAgdG8gMSwgaGlnaGVyIGlzIG1vcmUgcmVjZW50KVxuICAgICAgICBsZXQgbm9ybWFsaXplZFJlY2VuY3kgPSAwLjU7IC8vIERlZmF1bHQgaWYgb25seSBvbmUgaXRlbSBvciBubyB2YWxpZCBkYXRlXG4gICAgICAgIGlmIChtYXhUaW1lc3RhbXAgPiBtaW5UaW1lc3RhbXApIHtcbiAgICAgICAgICBjb25zdCBpdGVtVGltZXN0YW1wID0gbmV3IERhdGUocmVzdWx0LnVwZGF0ZWRfYXQpLmdldFRpbWUoKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKGl0ZW1UaW1lc3RhbXApKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkUmVjZW5jeSA9XG4gICAgICAgICAgICAgIChpdGVtVGltZXN0YW1wIC0gbWluVGltZXN0YW1wKSAvIChtYXhUaW1lc3RhbXAgLSBtaW5UaW1lc3RhbXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIC8vIGlmIGFsbCBpdGVtcyBoYXZlIHRoZSBleGFjdCBzYW1lIHRpbWVzdGFtcCBvciBvbmx5IG9uZSBpdGVtXG4gICAgICAgICAgbm9ybWFsaXplZFJlY2VuY3kgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tYmluZWQgc2NvcmVcbiAgICAgICAgcmVzdWx0LnNjb3JlID1cbiAgICAgICAgICBzaW1pbGFyaXR5V2VpZ2h0ICogbm9ybWFsaXplZFNpbWlsYXJpdHkgK1xuICAgICAgICAgIHJlY2VuY3lXZWlnaHQgKiBub3JtYWxpemVkUmVjZW5jeTtcbiAgICAgICAgLy8gbG9nKGBSZS1yYW5raW5nOiBJRCAke3Jlc3VsdC5pZH0sIE9yaWdEaXN0OiAkezEtbm9ybWFsaXplZFNpbWlsYXJpdHl9LCBOb3JtU2ltOiAke25vcm1hbGl6ZWRTaW1pbGFyaXR5fSwgTm9ybVJlYzogJHtub3JtYWxpemVkUmVjZW5jeX0sIE5ld1Njb3JlOiAke3Jlc3VsdC5zY29yZX1gKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTb3J0IGJ5IHRoZSBuZXcgY29tYmluZWQgc2NvcmUgaW4gZGVzY2VuZGluZyBvcmRlciAoaGlnaGVyIGlzIGJldHRlcilcbiAgICAgIGZpbmFsUmVzdWx0cy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSk7XG4gICAgICBsb2coXG4gICAgICAgIGBSZS1yYW5raW5nIGNvbXBsZXRlLiBUb3Agc2NvcmUgYWZ0ZXIgcmUtcmFua2luZzogJHtmaW5hbFJlc3VsdHNbMF0/LnNjb3JlfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vdCBib29zdGluZyByZWNlbmN5LCBlbnN1cmUgc2NvcmUgaXMgc2ltaWxhcml0eSAoMS1kaXN0YW5jZSlcbiAgICAgIGZpbmFsUmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgcmVzdWx0LnNjb3JlID0gMSAtIHJlc3VsdC5zY29yZTsgLy8gSGlnaGVyIGlzIGJldHRlclxuICAgICAgfSk7XG4gICAgICBmaW5hbFJlc3VsdHMuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpOyAvLyBTb3J0IGJ5IHNpbWlsYXJpdHlcbiAgICB9XG5cbiAgICByZXR1cm4gZmluYWxSZXN1bHRzLnNsaWNlKDAsIGluaXRpYWxUb3BLKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBsb2coJ0Vycm9yIGR1cmluZyBMVE0gcmV0cmlldmFsIG9yIExhbmNlREIgb3BlcmF0aW9uLicsICdlcnJvcicsIGVycm9yKTtcbiAgICByZXR1cm4gW107IC8vIFJldHVybiBlbXB0eSBhcnJheSBvbiBlcnJvciwgb3IgcmUtdGhyb3dcbiAgfVxufVxuXG4vLyBEZWZpbmUgc3RydWN0dXJlIGZvciBhY3Rpb25zIHRoYXQgbW9kaWZ5IGNvbnZlcnNhdGlvbiBzdGF0ZSAoU1RNKVxuZXhwb3J0IGludGVyZmFjZSBDb252ZXJzYXRpb25TdGF0ZUFjdGlvbnMge1xuICAvLyBFeHBvcnQgaWYgdXNlZCBieSBoYW5kbGVyLnRzIGRpcmVjdGx5XG4gIHVwZGF0ZVVzZXJHb2FsOiAoZ29hbDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZDtcbiAgdXBkYXRlSW50ZW50QW5kRW50aXRpZXM6IChcbiAgICBpbnRlbnQ6IHN0cmluZyB8IG51bGwsXG4gICAgZW50aXRpZXM6IFJlY29yZDxzdHJpbmcsIGFueT4gfCBudWxsXG4gICkgPT4gdm9pZDtcbiAgdXBkYXRlTHRtUmVwb0NvbnRleHQ6IChjb250ZXh0OiBMdG1RdWVyeVJlc3VsdFtdIHwgbnVsbCkgPT4gdm9pZDsgLy8gTmV3IGFjdGlvblxufVxuXG4vKipcbiAqIExvYWRzIHJldHJpZXZlZCBMVE0gcmVzdWx0cyBpbnRvIHRoZSBTaG9ydC1UZXJtIE1lbW9yeSAoU1RNKSBvciBjb252ZXJzYXRpb24gc3RhdGUuXG4gKiBAcGFyYW0gcmVzdWx0cyBUaGUgTFRNIHF1ZXJ5IHJlc3VsdHMgdG8gbG9hZC5cbiAqIEBwYXJhbSBjb252ZXJzYXRpb25TdGF0ZUFjdGlvbnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgZnVuY3Rpb25zIHRvIHVwZGF0ZSB0aGUgY29udmVyc2F0aW9uIHN0YXRlLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZExUTVRvU1RNKFxuICByZXN1bHRzOiBMdG1RdWVyeVJlc3VsdFtdLFxuICBjb252ZXJzYXRpb25TdGF0ZUFjdGlvbnM6IENvbnZlcnNhdGlvblN0YXRlQWN0aW9uc1xuKTogUHJvbWlzZTx2b2lkPiB7XG4gIGxvZygnTG9hZGluZyBMVE0gcmVzdWx0cyBpbnRvIFNUTS4uLicpO1xuICBpZiAoIXJlc3VsdHMgfHwgcmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICBsb2coJ05vIExUTSByZXN1bHRzIHRvIGxvYWQuJyk7XG4gICAgY29udmVyc2F0aW9uU3RhdGVBY3Rpb25zLnVwZGF0ZUx0bVJlcG9Db250ZXh0KG51bGwpOyAvLyBDbGVhciBjb250ZXh0IGlmIG5vIHJlc3VsdHNcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBVcGRhdGUgdGhlIG1haW4gTFRNIGNvbnRleHQgaW4gY29udmVyc2F0aW9uIHN0YXRlXG4gIGNvbnZlcnNhdGlvblN0YXRlQWN0aW9ucy51cGRhdGVMdG1SZXBvQ29udGV4dChyZXN1bHRzKTtcbiAgbG9nKFxuICAgIGBMVE0gY29udGV4dCB1cGRhdGVkIGluIGNvbnZlcnNhdGlvbiBzdGF0ZSB3aXRoICR7cmVzdWx0cy5sZW5ndGh9IGl0ZW1zLmBcbiAgKTtcblxuICAvLyBFeGFtcGxlIG9mIGZ1cnRoZXIgcHJvY2Vzc2luZzogdXBkYXRlIHVzZXIgZ29hbCBiYXNlZCBvbiB0aGUgdG9wIExUTSByZXN1bHRcbiAgLy8gVGhpcyBpcyBpbGx1c3RyYXRpdmUgYW5kIGNhbiBiZSBleHBhbmRlZC5cbiAgY29uc3QgdG9wUmVzdWx0ID0gcmVzdWx0c1swXTtcbiAgaWYgKFxuICAgIHRvcFJlc3VsdCAmJlxuICAgIHRvcFJlc3VsdC50YWJsZSA9PT0gJ3VzZXJfcHJvZmlsZXMnICYmXG4gICAgdG9wUmVzdWx0Lm1ldGFkYXRhPy5nb2FsXG4gICkge1xuICAgIGxvZyhgVXBkYXRpbmcgdXNlciBnb2FsIGZyb20gdG9wIExUTSByZXN1bHQ6ICR7dG9wUmVzdWx0Lm1ldGFkYXRhLmdvYWx9YCk7XG4gICAgY29udmVyc2F0aW9uU3RhdGVBY3Rpb25zLnVwZGF0ZVVzZXJHb2FsKHRvcFJlc3VsdC5tZXRhZGF0YS5nb2FsIGFzIHN0cmluZyk7XG4gIH0gZWxzZSBpZiAodG9wUmVzdWx0ICYmIHRvcFJlc3VsdC5tZXRhZGF0YT8uc3VtbWFyeUdvYWwpIHtcbiAgICAvLyBDaGVjayBmb3IgYSBkaWZmZXJlbnRseSBuYW1lZCBmaWVsZFxuICAgIGxvZyhcbiAgICAgIGBVcGRhdGluZyB1c2VyIGdvYWwgZnJvbSB0b3AgTFRNIHJlc3VsdCdzIHN1bW1hcnlHb2FsOiAke3RvcFJlc3VsdC5tZXRhZGF0YS5zdW1tYXJ5R29hbH1gXG4gICAgKTtcbiAgICBjb252ZXJzYXRpb25TdGF0ZUFjdGlvbnMudXBkYXRlVXNlckdvYWwoXG4gICAgICB0b3BSZXN1bHQubWV0YWRhdGEuc3VtbWFyeUdvYWwgYXMgc3RyaW5nXG4gICAgKTtcbiAgfVxuICAvLyBQb3RlbnRpYWxseSB1cGRhdGUgZW50aXRpZXMgYmFzZWQgb24gTFRNIHJlc3VsdHMgYXMgd2VsbFxuICAvLyBFeGFtcGxlOiBpZiBlbnRpdGllcyBhcmUgZGlyZWN0bHkgc3RvcmVkIG9yIGluZmVyYWJsZSBmcm9tIExUTSB0ZXh0L21ldGFkYXRhXG4gIC8vIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgLy8gICBpZiAocmVzdWx0Lm1ldGFkYXRhPy5lbnRpdGllcyAmJiB0eXBlb2YgcmVzdWx0Lm1ldGFkYXRhLmVudGl0aWVzID09PSAnb2JqZWN0Jykge1xuICAvLyAgICAgbG9nKCdVcGRhdGluZyBlbnRpdGllcyBmcm9tIExUTSByZXN1bHQ6JywgcmVzdWx0Lm1ldGFkYXRhLmVudGl0aWVzKTtcbiAgLy8gICAgIGNvbnZlcnNhdGlvblN0YXRlQWN0aW9ucy51cGRhdGVJbnRlbnRBbmRFbnRpdGllcyhudWxsLCByZXN1bHQubWV0YWRhdGEuZW50aXRpZXMgYXMgUmVjb3JkPHN0cmluZywgYW55Pik7XG4gIC8vICAgICAvLyBOb3RlOiBUaGlzIG1pZ2h0IG92ZXJ3cml0ZSBlbnRpdGllcyBmcm9tIE5MVS4gRGVjaWRlIG9uIG1lcmdpbmcgc3RyYXRlZ3kuXG4gIC8vICAgfVxuICAvLyB9XG4gIGxvZygnRmluaXNoZWQgbG9hZGluZyBMVE0gcmVzdWx0cyBhbmQgcG90ZW50aWFsbHkgdXBkYXRpbmcgcGFydHMgb2YgU1RNLicpO1xufVxuXG4vLyBFeGFtcGxlIG9mIGhvdyB0aGlzIG1hbmFnZXIgbWlnaHQgYmUgaW5pdGlhbGl6ZWQgYW5kIHVzZWQgKGNvbmNlcHR1YWwpXG4vKlxuYXN5bmMgZnVuY3Rpb24gbWFpbk1lbW9yeUN5Y2xlKHVzZXJJZDogc3RyaW5nLCBjdXJyZW50UXVlcnk/OiBzdHJpbmcpIHtcbiAgbG9nKFwiU3RhcnRpbmcgbWFpbiBtZW1vcnkgY3ljbGUuLi5cIik7XG5cbiAgLy8gSXQncyBiZXR0ZXIgdG8gaW5pdGlhbGl6ZSBEQiBvbmNlIGFuZCBwYXNzIHRoZSBjb25uZWN0aW9uIGFyb3VuZC5cbiAgLy8gRm9yIHRoaXMgZXhhbXBsZSwgYXNzdW1lIGBkYkNvbm5lY3Rpb25gIGlzIGFuIGFscmVhZHkgaW5pdGlhbGl6ZWQgbGFuY2VkYi5Db25uZWN0aW9uIG9iamVjdC5cbiAgLy8gY29uc3QgZGJDb25uZWN0aW9uID0gYXdhaXQgaW5pdGlhbGl6ZURCKCdhZ2VudF9sdG1fZGInKTtcbiAgLy8gaWYgKCFkYkNvbm5lY3Rpb24pIHtcbiAgLy8gICBsb2coXCJGYWlsZWQgdG8gaW5pdGlhbGl6ZSBMYW5jZURCLiBBYm9ydGluZyBtZW1vcnkgY3ljbGUuXCIsICdlcnJvcicpO1xuICAvLyAgIHJldHVybjtcbiAgLy8gfVxuXG4gIC8vIDEuIFBvdGVudGlhbGx5IHJldHJpZXZlIExUTSBiYXNlZCBvbiBjdXJyZW50IHF1ZXJ5IHRvIGluZm9ybSBjdXJyZW50IHR1cm5cbiAgaWYgKGN1cnJlbnRRdWVyeSAmJiBkYkNvbm5lY3Rpb24pIHsgLy8gTWFrZSBzdXJlIGRiQ29ubmVjdGlvbiBpcyB2YWxpZFxuICAgIGNvbnN0IHJlbGV2YW50THRtID0gYXdhaXQgcmV0cmlldmVSZWxldmFudExUTShjdXJyZW50UXVlcnksIHVzZXJJZCwgZGJDb25uZWN0aW9uLCB7IHRhYmxlOiAna25vd2xlZGdlX2Jhc2UnIH0pO1xuICAgIGlmIChyZWxldmFudEx0bS5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCBsb2FkTFRNVG9TVE0ocmVsZXZhbnRMdG0sIHtcbiAgICAgICAgdXBkYXRlVXNlckdvYWw6IHVwZGF0ZVVzZXJHb2FsLFxuICAgICAgICB1cGRhdGVJbnRlbnRBbmRFbnRpdGllczogdXBkYXRlSW50ZW50QW5kRW50aXRpZXMsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyAyLiBBZnRlciBhZ2VudCByZXNwb25zZSBhbmQgdXNlciBpbnRlcmFjdGlvbiwgcHJvY2VzcyBTVE0gdG8gTFRNXG4gIGNvbnN0IGN1cnJlbnRDb252ZXJzYXRpb25TdGF0ZSA9IGdldENvbnZlcnNhdGlvblN0YXRlU25hcHNob3QoKTtcbiAgaWYgKGN1cnJlbnRDb252ZXJzYXRpb25TdGF0ZS5pc0FjdGl2ZSAmJiBkYkNvbm5lY3Rpb24pIHsgLy8gTWFrZSBzdXJlIGRiQ29ubmVjdGlvbiBpcyB2YWxpZFxuICAgIGF3YWl0IHByb2Nlc3NTVE1Ub0xUTSh1c2VySWQsIGN1cnJlbnRDb252ZXJzYXRpb25TdGF0ZSwgZGJDb25uZWN0aW9uKTtcbiAgfVxuXG4gIGxvZyhcIk1haW4gbWVtb3J5IGN5Y2xlIGZpbmlzaGVkLlwiKTtcbn1cbiovXG5cbmxvZygnTWVtb3J5TWFuYWdlciBtb2R1bGUgbG9hZGVkIHdpdGggaW1wbGVtZW50ZWQgTFRNIGludGVyYWN0aW9uIGZ1bmN0aW9ucy4nKTtcbiJdfQ==