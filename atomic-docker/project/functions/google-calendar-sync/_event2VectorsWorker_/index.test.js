import { event2VectorBody } from './index'; // Assuming index.ts is the entry point
import * as lancedbHelper from '../_libs/lancedb_helper';
import * as eventApiHelper from '../_libs/event2VectorsWorker/api-helper'; // For convertEventTitleToOpenAIVector
import { dayjs } from '@google_calendar_sync/_libs/date-utils'; // For date manipulations if needed in test data
// Mock dependencies
jest.mock('../_libs/lancedb_helper', () => ({
    bulkUpsertToLanceDBEvents: jest.fn(),
    bulkDeleteFromLanceDBEvents: jest.fn(),
}));
jest.mock('../_libs/event2VectorsWorker/api-helper', () => ({
    convertEventTitleToOpenAIVector: jest.fn(),
}));
const mockConvertEventTitleToOpenAIVector = eventApiHelper.convertEventTitleToOpenAIVector;
const mockBulkUpsert = lancedbHelper.bulkUpsertToLanceDBEvents;
const mockBulkDelete = lancedbHelper.bulkDeleteFromLanceDBEvents;
describe('event2VectorBody', () => {
    beforeEach(() => {
        // Clear mock history before each test
        mockConvertEventTitleToOpenAIVector.mockClear();
        mockBulkUpsert.mockClear();
        mockBulkDelete.mockClear();
    });
    const baseEvent = {
        id: 'testEvent1',
        summary: 'Test Event Summary',
        description: 'Test Event Description',
        start: { dateTime: '2024-01-01T10:00:00Z', timeZone: 'UTC' },
        end: { dateTime: '2024-01-01T11:00:00Z', timeZone: 'UTC' },
    };
    const userId = 'testUser';
    const calendarId = 'testCalendar';
    it('should handle upsert operations correctly', async () => {
        const mockVector = [0.1, 0.2, 0.3];
        mockConvertEventTitleToOpenAIVector.mockResolvedValue(mockVector);
        const eventObject = {
            method: 'upsert',
            event: baseEvent,
            calendarId,
        };
        const body = { userId, events: [eventObject] };
        await event2VectorBody(body);
        expect(mockConvertEventTitleToOpenAIVector).toHaveBeenCalledTimes(1);
        expect(mockConvertEventTitleToOpenAIVector).toHaveBeenCalledWith(`${baseEvent.summary}:${baseEvent.description}`);
        expect(mockBulkUpsert).toHaveBeenCalledTimes(1);
        expect(mockBulkUpsert).toHaveBeenCalledWith([
            expect.objectContaining({
                id: `${baseEvent.id}#${calendarId}`,
                userId,
                vector: mockVector,
                start_date: dayjs(baseEvent.start.dateTime.slice(0, 19))
                    .tz(baseEvent.start.timeZone, true)
                    .format(),
                end_date: dayjs(baseEvent.end.dateTime.slice(0, 19))
                    .tz(baseEvent.end.timeZone, true)
                    .format(),
                raw_event_text: `${baseEvent.summary}:${baseEvent.description}`,
            }),
        ]);
        expect(mockBulkDelete).not.toHaveBeenCalled();
    });
    it('should handle upsert operations for events with only summary', async () => {
        const mockVector = [0.4, 0.5, 0.6];
        mockConvertEventTitleToOpenAIVector.mockResolvedValue(mockVector);
        const eventWithoutDescription = { ...baseEvent, description: undefined };
        const eventObject = {
            method: 'upsert',
            event: eventWithoutDescription,
            calendarId,
        };
        const body = { userId, events: [eventObject] };
        await event2VectorBody(body);
        expect(mockConvertEventTitleToOpenAIVector).toHaveBeenCalledTimes(1);
        expect(mockConvertEventTitleToOpenAIVector).toHaveBeenCalledWith(eventWithoutDescription.summary);
        expect(mockBulkUpsert).toHaveBeenCalledTimes(1);
        expect(mockBulkUpsert).toHaveBeenCalledWith([
            expect.objectContaining({
                raw_event_text: eventWithoutDescription.summary,
            }),
        ]);
    });
    it('should handle delete operations correctly', async () => {
        const eventObject = {
            method: 'delete',
            event: { id: 'eventToDelete1' }, // Only ID is needed for delete
            calendarId,
        };
        const body = { userId, events: [eventObject] };
        await event2VectorBody(body);
        expect(mockConvertEventTitleToOpenAIVector).not.toHaveBeenCalled();
        expect(mockBulkUpsert).not.toHaveBeenCalled();
        expect(mockBulkDelete).toHaveBeenCalledTimes(1);
        expect(mockBulkDelete).toHaveBeenCalledWith([
            `${eventObject.event.id}#${calendarId}`,
        ]);
    });
    it('should handle mixed upsert and delete operations', async () => {
        const mockVectorUpsert = [0.7, 0.8, 0.9];
        mockConvertEventTitleToOpenAIVector.mockResolvedValue(mockVectorUpsert);
        const upsertEventObject = {
            method: 'upsert',
            event: baseEvent,
            calendarId: 'calUpsert',
        };
        const deleteEventObject = {
            method: 'delete',
            event: { id: 'eventToDelete2' },
            calendarId: 'calDelete',
        };
        const body = {
            userId,
            events: [upsertEventObject, deleteEventObject],
        };
        await event2VectorBody(body);
        // Upsert checks
        expect(mockConvertEventTitleToOpenAIVector).toHaveBeenCalledTimes(1);
        expect(mockBulkUpsert).toHaveBeenCalledTimes(1);
        expect(mockBulkUpsert).toHaveBeenCalledWith([
            expect.objectContaining({
                id: `${baseEvent.id}#${upsertEventObject.calendarId}`,
            }),
        ]);
        // Delete checks
        expect(mockBulkDelete).toHaveBeenCalledTimes(1);
        expect(mockBulkDelete).toHaveBeenCalledWith([
            `${deleteEventObject.event.id}#${deleteEventObject.calendarId}`,
        ]);
    });
    it('should handle empty events array', async () => {
        const body = { userId, events: [] };
        await event2VectorBody(body);
        expect(mockConvertEventTitleToOpenAIVector).not.toHaveBeenCalled();
        expect(mockBulkUpsert).not.toHaveBeenCalled();
        expect(mockBulkDelete).not.toHaveBeenCalled();
    });
    it('should handle events array with only unknown methods', async () => {
        const eventObject = {
            method: 'unknown_method', // Test invalid method
            event: baseEvent,
            calendarId,
        };
        const body = { userId, events: [eventObject] };
        await event2VectorBody(body);
        expect(mockConvertEventTitleToOpenAIVector).not.toHaveBeenCalled();
        expect(mockBulkUpsert).not.toHaveBeenCalled();
        expect(mockBulkDelete).not.toHaveBeenCalled();
    });
    it('should use end.timeZone if available, otherwise start.timeZone for end_date calculation', async () => {
        const mockVector = [0.1, 0.2, 0.3];
        mockConvertEventTitleToOpenAIVector.mockResolvedValue(mockVector);
        const eventWithSpecificEndTimeZone = {
            ...baseEvent,
            end: { dateTime: '2024-01-01T12:00:00Z', timeZone: 'America/New_York' }, // Different from start
        };
        const eventObject = {
            method: 'upsert',
            event: eventWithSpecificEndTimeZone,
            calendarId,
        };
        const body = { userId, events: [eventObject] };
        await event2VectorBody(body);
        expect(mockBulkUpsert).toHaveBeenCalledWith([
            expect.objectContaining({
                end_date: dayjs(eventWithSpecificEndTimeZone.end.dateTime.slice(0, 19))
                    .tz(eventWithSpecificEndTimeZone.end.timeZone, true)
                    .format(),
            }),
        ]);
        // Test fallback to start.timeZone for end_date if end.timeZone is missing
        mockBulkUpsert.mockClear();
        const eventWithoutEndTimeZone = {
            ...baseEvent,
            end: { dateTime: '2024-01-01T11:00:00Z', timeZone: undefined }, // end.timeZone is undefined
        };
        const eventObject2 = {
            method: 'upsert',
            event: eventWithoutEndTimeZone,
            calendarId,
        };
        const body2 = { userId, events: [eventObject2] };
        await event2VectorBody(body2);
        expect(mockBulkUpsert).toHaveBeenCalledWith([
            expect.objectContaining({
                end_date: dayjs(eventWithoutEndTimeZone.end.dateTime.slice(0, 19))
                    .tz(eventWithoutEndTimeZone.start.timeZone, true)
                    .format(),
            }),
        ]);
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImluZGV4LnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sU0FBUyxDQUFDLENBQUMsdUNBQXVDO0FBQ25GLE9BQU8sS0FBSyxhQUFhLE1BQU0seUJBQXlCLENBQUM7QUFDekQsT0FBTyxLQUFLLGNBQWMsTUFBTSx5Q0FBeUMsQ0FBQyxDQUFDLHNDQUFzQztBQUtqSCxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sd0NBQXdDLENBQUMsQ0FBQyxnREFBZ0Q7QUFFaEgsb0JBQW9CO0FBQ3BCLElBQUksQ0FBQyxJQUFJLENBQUMseUJBQXlCLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUMxQyx5QkFBeUIsRUFBRSxJQUFJLENBQUMsRUFBRSxFQUFFO0lBQ3BDLDJCQUEyQixFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7Q0FDdkMsQ0FBQyxDQUFDLENBQUM7QUFFSixJQUFJLENBQUMsSUFBSSxDQUFDLHlDQUF5QyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDMUQsK0JBQStCLEVBQUUsSUFBSSxDQUFDLEVBQUUsRUFBRTtDQUMzQyxDQUFDLENBQUMsQ0FBQztBQUVKLE1BQU0sbUNBQW1DLEdBQ3ZDLGNBQWMsQ0FBQywrQkFBNEMsQ0FBQztBQUM5RCxNQUFNLGNBQWMsR0FBRyxhQUFhLENBQUMseUJBQXNDLENBQUM7QUFDNUUsTUFBTSxjQUFjLEdBQUcsYUFBYSxDQUFDLDJCQUF3QyxDQUFDO0FBRTlFLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRSxHQUFHLEVBQUU7SUFDaEMsVUFBVSxDQUFDLEdBQUcsRUFBRTtRQUNkLHNDQUFzQztRQUN0QyxtQ0FBbUMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNoRCxjQUFjLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDM0IsY0FBYyxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQzdCLENBQUMsQ0FB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QUMzQixNQUFNLHVCQUF1QixHQUFHO1lBQzlCLEdBQUcsU0FBUztZQUNaLEdBQUcsRUFBRSxFQUFFLFFBQVEsRUFBRSxzQkFBc0IsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLEVBQUUsNEJBQTRCO1NBQzdGLENBQUM7UUFDRixNQUFNLFlBQVksR0FBZ0I7WUFDaEMsTUFBTSxFQUFFLFFBQVE7WUFDaEIsS0FBSyxFQUFFLHVCQUF1QjtZQUM5QixVQUFVO1NBQ1gsQ0FBQztRQUNGLE1BQU0sS0FBSyxHQUF5QixFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1FBQ3ZFLE1BQU0sZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFOUIsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLG9CQUFvQixDQUFDO1lBQzFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQztnQkFDdEIsUUFBUSxFQUFFLEtBQUssQ0FBQyx1QkFBdUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7cUJBQy9ELEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQyxLQUFLLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQztxQkFDaEQsTUFBTSxFQUFFO2FBQ1osQ0FBQztTQUNILENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldmVudDJWZWN0b3JCb2R5IH0gZnJvbSAnLi9pbmRleCc7IC8vIEFzc3VtaW5nIGluZGV4LnRzIGlzIHRoZSBlbnRyeSBwb2ludFxuaW1wb3J0ICogYXMgbGFuY2VkYkhlbHBlciBmcm9tICcuLi9fbGlicy9sYW5jZWRiX2hlbHBlcic7XG5pbXBvcnQgKiBhcyBldmVudEFwaUhlbHBlciBmcm9tICcuLi9fbGlicy9ldmVudDJWZWN0b3JzV29ya2VyL2FwaS1oZWxwZXInOyAvLyBGb3IgY29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3RvclxuaW1wb3J0IHtcbiAgRXZlbnQyVmVjdG9yQm9keVR5cGUsXG4gIEV2ZW50T2JqZWN0LFxufSBmcm9tICcuLi9fbGlicy90eXBlcy9ldmVudDJWZWN0b3JzL3R5cGVzJzsgLy8gQWRqdXN0IHBhdGggYXMgbmVlZGVkXG5pbXBvcnQgeyBkYXlqcyB9IGZyb20gJ0Bnb29nbGVfY2FsZW5kYXJfc3luYy9fbGlicy9kYXRlLXV0aWxzJzsgLy8gRm9yIGRhdGUgbWFuaXB1bGF0aW9ucyBpZiBuZWVkZWQgaW4gdGVzdCBkYXRhXG5cbi8vIE1vY2sgZGVwZW5kZW5jaWVzXG5qZXN0Lm1vY2soJy4uL19saWJzL2xhbmNlZGJfaGVscGVyJywgKCkgPT4gKHtcbiAgYnVsa1Vwc2VydFRvTGFuY2VEQkV2ZW50czogamVzdC5mbigpLFxuICBidWxrRGVsZXRlRnJvbUxhbmNlREJFdmVudHM6IGplc3QuZm4oKSxcbn0pKTtcblxuamVzdC5tb2NrKCcuLi9fbGlicy9ldmVudDJWZWN0b3JzV29ya2VyL2FwaS1oZWxwZXInLCAoKSA9PiAoe1xuICBjb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yOiBqZXN0LmZuKCksXG59KSk7XG5cbmNvbnN0IG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yID1cbiAgZXZlbnRBcGlIZWxwZXIuY29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3RvciBhcyBqZXN0Lk1vY2s7XG5jb25zdCBtb2NrQnVsa1Vwc2VydCA9IGxhbmNlZGJIZWxwZXIuYnVsa1Vwc2VydFRvTGFuY2VEQkV2ZW50cyBhcyBqZXN0Lk1vY2s7XG5jb25zdCBtb2NrQnVsa0RlbGV0ZSA9IGxhbmNlZGJIZWxwZXIuYnVsa0RlbGV0ZUZyb21MYW5jZURCRXZlbnRzIGFzIGplc3QuTW9jaztcblxuZGVzY3JpYmUoJ2V2ZW50MlZlY3RvckJvZHknLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIC8vIENsZWFyIG1vY2sgaGlzdG9yeSBiZWZvcmUgZWFjaCB0ZXN0XG4gICAgbW9ja0NvbnZlcnRFdmVudFRpdGxlVG9PcGVuQUlWZWN0b3IubW9ja0NsZWFyKCk7XG4gICAgbW9ja0J1bGtVcHNlcnQubW9ja0NsZWFyKCk7XG4gICAgbW9ja0J1bGtEZWxldGUubW9ja0NsZWFyKCk7XG4gIH0pO1xuXG4gIGNvbnN0IGJhc2VFdmVudCA9IHtcbiAgICBpZDogJ3Rlc3RFdmVudDEnLFxuICAgIHN1bW1hcnk6ICdUZXN0IEV2ZW50IFN1bW1hcnknLFxuICAgIGRlc2NyaXB0aW9uOiAnVGVzdCBFdmVudCBEZXNjcmlwdGlvbicsXG4gICAgc3RhcnQ6IHsgZGF0ZVRpbWU6ICcyMDI0LTAxLTAxVDEwOjAwOjAwWicsIHRpbWVab25lOiAnVVRDJyB9LFxuICAgIGVuZDogeyBkYXRlVGltZTogJzIwMjQtMDEtMDFUMTE6MDA6MDBaJywgdGltZVpvbmU6ICdVVEMnIH0sXG4gIH07XG5cbiAgY29uc3QgdXNlcklkID0gJ3Rlc3RVc2VyJztcbiAgY29uc3QgY2FsZW5kYXJJZCA9ICd0ZXN0Q2FsZW5kYXInO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIHVwc2VydCBvcGVyYXRpb25zIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrVmVjdG9yID0gWzAuMSwgMC4yLCAwLjNdO1xuICAgIG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tWZWN0b3IpO1xuXG4gICAgY29uc3QgZXZlbnRPYmplY3Q6IEV2ZW50T2JqZWN0ID0ge1xuICAgICAgbWV0aG9kOiAndXBzZXJ0JyxcbiAgICAgIGV2ZW50OiBiYXNlRXZlbnQsXG4gICAgICBjYWxlbmRhcklkLFxuICAgIH07XG4gICAgY29uc3QgYm9keTogRXZlbnQyVmVjdG9yQm9keVR5cGUgPSB7IHVzZXJJZCwgZXZlbnRzOiBbZXZlbnRPYmplY3RdIH07XG5cbiAgICBhd2FpdCBldmVudDJWZWN0b3JCb2R5KGJvZHkpO1xuXG4gICAgZXhwZWN0KG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGAke2Jhc2VFdmVudC5zdW1tYXJ5fToke2Jhc2VFdmVudC5kZXNjcmlwdGlvbn1gXG4gICAgKTtcblxuICAgIGV4cGVjdChtb2NrQnVsa1Vwc2VydCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIGV4cGVjdChtb2NrQnVsa1Vwc2VydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoW1xuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBpZDogYCR7YmFzZUV2ZW50LmlkfSMke2NhbGVuZGFySWR9YCxcbiAgICAgICAgdXNlcklkLFxuICAgICAgICB2ZWN0b3I6IG1vY2tWZWN0b3IsXG4gICAgICAgIHN0YXJ0X2RhdGU6IGRheWpzKGJhc2VFdmVudC5zdGFydC5kYXRlVGltZS5zbGljZSgwLCAxOSkpXG4gICAgICAgICAgLnR6KGJhc2VFdmVudC5zdGFydC50aW1lWm9uZSwgdHJ1ZSlcbiAgICAgICAgICAuZm9ybWF0KCksXG4gICAgICAgIGVuZF9kYXRlOiBkYXlqcyhiYXNlRXZlbnQuZW5kLmRhdGVUaW1lLnNsaWNlKDAsIDE5KSlcbiAgICAgICAgICAudHooYmFzZUV2ZW50LmVuZC50aW1lWm9uZSwgdHJ1ZSlcbiAgICAgICAgICAuZm9ybWF0KCksXG4gICAgICAgIHJhd19ldmVudF90ZXh0OiBgJHtiYXNlRXZlbnQuc3VtbWFyeX06JHtiYXNlRXZlbnQuZGVzY3JpcHRpb259YCxcbiAgICAgIH0pLFxuICAgIF0pO1xuICAgIGV4cGVjdChtb2NrQnVsa0RlbGV0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgdXBzZXJ0IG9wZXJhdGlvbnMgZm9yIGV2ZW50cyB3aXRoIG9ubHkgc3VtbWFyeScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBtb2NrVmVjdG9yID0gWzAuNCwgMC41LCAwLjZdO1xuICAgIG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yLm1vY2tSZXNvbHZlZFZhbHVlKG1vY2tWZWN0b3IpO1xuICAgIGNvbnN0IGV2ZW50V2l0aG91dERlc2NyaXB0aW9uID0geyAuLi5iYXNlRXZlbnQsIGRlc2NyaXB0aW9uOiB1bmRlZmluZWQgfTtcblxuICAgIGNvbnN0IGV2ZW50T2JqZWN0OiBFdmVudE9iamVjdCA9IHtcbiAgICAgIG1ldGhvZDogJ3Vwc2VydCcsXG4gICAgICBldmVudDogZXZlbnRXaXRob3V0RGVzY3JpcHRpb24sXG4gICAgICBjYWxlbmRhcklkLFxuICAgIH07XG4gICAgY29uc3QgYm9keTogRXZlbnQyVmVjdG9yQm9keVR5cGUgPSB7IHVzZXJJZCwgZXZlbnRzOiBbZXZlbnRPYmplY3RdIH07XG5cbiAgICBhd2FpdCBldmVudDJWZWN0b3JCb2R5KGJvZHkpO1xuXG4gICAgZXhwZWN0KG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChcbiAgICAgIGV2ZW50V2l0aG91dERlc2NyaXB0aW9uLnN1bW1hcnlcbiAgICApO1xuXG4gICAgZXhwZWN0KG1vY2tCdWxrVXBzZXJ0KS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KG1vY2tCdWxrVXBzZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIHJhd19ldmVudF90ZXh0OiBldmVudFdpdGhvdXREZXNjcmlwdGlvbi5zdW1tYXJ5LFxuICAgICAgfSksXG4gICAgXSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIGRlbGV0ZSBvcGVyYXRpb25zIGNvcnJlY3RseScsIGFzeW5jICgpID0+IHtcbiAgICBjb25zdCBldmVudE9iamVjdDogRXZlbnRPYmplY3QgPSB7XG4gICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgZXZlbnQ6IHsgaWQ6ICdldmVudFRvRGVsZXRlMScgfSwgLy8gT25seSBJRCBpcyBuZWVkZWQgZm9yIGRlbGV0ZVxuICAgICAgY2FsZW5kYXJJZCxcbiAgICB9O1xuICAgIGNvbnN0IGJvZHk6IEV2ZW50MlZlY3RvckJvZHlUeXBlID0geyB1c2VySWQsIGV2ZW50czogW2V2ZW50T2JqZWN0XSB9O1xuXG4gICAgYXdhaXQgZXZlbnQyVmVjdG9yQm9keShib2R5KTtcblxuICAgIGV4cGVjdChtb2NrQ29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3Rvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICBleHBlY3QobW9ja0J1bGtVcHNlcnQpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgZXhwZWN0KG1vY2tCdWxrRGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSk7XG4gICAgZXhwZWN0KG1vY2tCdWxrRGVsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXG4gICAgICBgJHtldmVudE9iamVjdC5ldmVudC5pZH0jJHtjYWxlbmRhcklkfWAsXG4gICAgXSk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgaGFuZGxlIG1peGVkIHVwc2VydCBhbmQgZGVsZXRlIG9wZXJhdGlvbnMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1ZlY3RvclVwc2VydCA9IFswLjcsIDAuOCwgMC45XTtcbiAgICBtb2NrQ29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3Rvci5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVmVjdG9yVXBzZXJ0KTtcblxuICAgIGNvbnN0IHVwc2VydEV2ZW50T2JqZWN0OiBFdmVudE9iamVjdCA9IHtcbiAgICAgIG1ldGhvZDogJ3Vwc2VydCcsXG4gICAgICBldmVudDogYmFzZUV2ZW50LFxuICAgICAgY2FsZW5kYXJJZDogJ2NhbFVwc2VydCcsXG4gICAgfTtcbiAgICBjb25zdCBkZWxldGVFdmVudE9iamVjdDogRXZlbnRPYmplY3QgPSB7XG4gICAgICBtZXRob2Q6ICdkZWxldGUnLFxuICAgICAgZXZlbnQ6IHsgaWQ6ICdldmVudFRvRGVsZXRlMicgfSxcbiAgICAgIGNhbGVuZGFySWQ6ICdjYWxEZWxldGUnLFxuICAgIH07XG4gICAgY29uc3QgYm9keTogRXZlbnQyVmVjdG9yQm9keVR5cGUgPSB7XG4gICAgICB1c2VySWQsXG4gICAgICBldmVudHM6IFt1cHNlcnRFdmVudE9iamVjdCwgZGVsZXRlRXZlbnRPYmplY3RdLFxuICAgIH07XG5cbiAgICBhd2FpdCBldmVudDJWZWN0b3JCb2R5KGJvZHkpO1xuXG4gICAgLy8gVXBzZXJ0IGNoZWNrc1xuICAgIGV4cGVjdChtb2NrQ29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3RvcikudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIGV4cGVjdChtb2NrQnVsa1Vwc2VydCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIGV4cGVjdChtb2NrQnVsa1Vwc2VydCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoW1xuICAgICAgZXhwZWN0Lm9iamVjdENvbnRhaW5pbmcoe1xuICAgICAgICBpZDogYCR7YmFzZUV2ZW50LmlkfSMke3Vwc2VydEV2ZW50T2JqZWN0LmNhbGVuZGFySWR9YCxcbiAgICAgIH0pLFxuICAgIF0pO1xuXG4gICAgLy8gRGVsZXRlIGNoZWNrc1xuICAgIGV4cGVjdChtb2NrQnVsa0RlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpO1xuICAgIGV4cGVjdChtb2NrQnVsa0RlbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoW1xuICAgICAgYCR7ZGVsZXRlRXZlbnRPYmplY3QuZXZlbnQuaWR9IyR7ZGVsZXRlRXZlbnRPYmplY3QuY2FsZW5kYXJJZH1gLFxuICAgIF0pO1xuICB9KTtcblxuICBpdCgnc2hvdWxkIGhhbmRsZSBlbXB0eSBldmVudHMgYXJyYXknLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgYm9keTogRXZlbnQyVmVjdG9yQm9keVR5cGUgPSB7IHVzZXJJZCwgZXZlbnRzOiBbXSB9O1xuICAgIGF3YWl0IGV2ZW50MlZlY3RvckJvZHkoYm9keSk7XG5cbiAgICBleHBlY3QobW9ja0NvbnZlcnRFdmVudFRpdGxlVG9PcGVuQUlWZWN0b3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gICAgZXhwZWN0KG1vY2tCdWxrVXBzZXJ0KS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIGV4cGVjdChtb2NrQnVsa0RlbGV0ZSkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgfSk7XG5cbiAgaXQoJ3Nob3VsZCBoYW5kbGUgZXZlbnRzIGFycmF5IHdpdGggb25seSB1bmtub3duIG1ldGhvZHMnLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZXZlbnRPYmplY3Q6IEV2ZW50T2JqZWN0ID0ge1xuICAgICAgbWV0aG9kOiAndW5rbm93bl9tZXRob2QnIGFzIGFueSwgLy8gVGVzdCBpbnZhbGlkIG1ldGhvZFxuICAgICAgZXZlbnQ6IGJhc2VFdmVudCxcbiAgICAgIGNhbGVuZGFySWQsXG4gICAgfTtcbiAgICBjb25zdCBib2R5OiBFdmVudDJWZWN0b3JCb2R5VHlwZSA9IHsgdXNlcklkLCBldmVudHM6IFtldmVudE9iamVjdF0gfTtcbiAgICBhd2FpdCBldmVudDJWZWN0b3JCb2R5KGJvZHkpO1xuXG4gICAgZXhwZWN0KG1vY2tDb252ZXJ0RXZlbnRUaXRsZVRvT3BlbkFJVmVjdG9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpO1xuICAgIGV4cGVjdChtb2NrQnVsa1Vwc2VydCkubm90LnRvSGF2ZUJlZW5DYWxsZWQoKTtcbiAgICBleHBlY3QobW9ja0J1bGtEZWxldGUpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKCk7XG4gIH0pO1xuXG4gIGl0KCdzaG91bGQgdXNlIGVuZC50aW1lWm9uZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBzdGFydC50aW1lWm9uZSBmb3IgZW5kX2RhdGUgY2FsY3VsYXRpb24nLCBhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgbW9ja1ZlY3RvciA9IFswLjEsIDAuMiwgMC4zXTtcbiAgICBtb2NrQ29udmVydEV2ZW50VGl0bGVUb09wZW5BSVZlY3Rvci5tb2NrUmVzb2x2ZWRWYWx1ZShtb2NrVmVjdG9yKTtcblxuICAgIGNvbnN0IGV2ZW50V2l0aFNwZWNpZmljRW5kVGltZVpvbmUgPSB7XG4gICAgICAuLi5iYXNlRXZlbnQsXG4gICAgICBlbmQ6IHsgZGF0ZVRpbWU6ICcyMDI0LTAxLTAxVDEyOjAwOjAwWicsIHRpbWVab25lOiAnQW1lcmljYS9OZXdfWW9yaycgfSwgLy8gRGlmZmVyZW50IGZyb20gc3RhcnRcbiAgICB9O1xuICAgIGNvbnN0IGV2ZW50T2JqZWN0OiBFdmVudE9iamVjdCA9IHtcbiAgICAgIG1ldGhvZDogJ3Vwc2VydCcsXG4gICAgICBldmVudDogZXZlbnRXaXRoU3BlY2lmaWNFbmRUaW1lWm9uZSxcbiAgICAgIGNhbGVuZGFySWQsXG4gICAgfTtcbiAgICBjb25zdCBib2R5OiBFdmVudDJWZWN0b3JCb2R5VHlwZSA9IHsgdXNlcklkLCBldmVudHM6IFtldmVudE9iamVjdF0gfTtcbiAgICBhd2FpdCBldmVudDJWZWN0b3JCb2R5KGJvZHkpO1xuXG4gICAgZXhwZWN0KG1vY2tCdWxrVXBzZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIGVuZF9kYXRlOiBkYXlqcyhldmVudFdpdGhTcGVjaWZpY0VuZFRpbWVab25lLmVuZC5kYXRlVGltZS5zbGljZSgwLCAxOSkpXG4gICAgICAgICAgLnR6KGV2ZW50V2l0aFNwZWNpZmljRW5kVGltZVpvbmUuZW5kLnRpbWVab25lLCB0cnVlKVxuICAgICAgICAgIC5mb3JtYXQoKSxcbiAgICAgIH0pLFxuICAgIF0pO1xuXG4gICAgLy8gVGVzdCBmYWxsYmFjayB0byBzdGFydC50aW1lWm9uZSBmb3IgZW5kX2RhdGUgaWYgZW5kLnRpbWVab25lIGlzIG1pc3NpbmdcbiAgICBtb2NrQnVsa1Vwc2VydC5tb2NrQ2xlYXIoKTtcbiAgICBjb25zdCBldmVudFdpdGhvdXRFbmRUaW1lWm9uZSA9IHtcbiAgICAgIC4uLmJhc2VFdmVudCxcbiAgICAgIGVuZDogeyBkYXRlVGltZTogJzIwMjQtMDEtMDFUMTE6MDA6MDBaJywgdGltZVpvbmU6IHVuZGVmaW5lZCB9LCAvLyBlbmQudGltZVpvbmUgaXMgdW5kZWZpbmVkXG4gICAgfTtcbiAgICBjb25zdCBldmVudE9iamVjdDI6IEV2ZW50T2JqZWN0ID0ge1xuICAgICAgbWV0aG9kOiAndXBzZXJ0JyxcbiAgICAgIGV2ZW50OiBldmVudFdpdGhvdXRFbmRUaW1lWm9uZSxcbiAgICAgIGNhbGVuZGFySWQsXG4gICAgfTtcbiAgICBjb25zdCBib2R5MjogRXZlbnQyVmVjdG9yQm9keVR5cGUgPSB7IHVzZXJJZCwgZXZlbnRzOiBbZXZlbnRPYmplY3QyXSB9O1xuICAgIGF3YWl0IGV2ZW50MlZlY3RvckJvZHkoYm9keTIpO1xuXG4gICAgZXhwZWN0KG1vY2tCdWxrVXBzZXJ0KS50b0hhdmVCZWVuQ2FsbGVkV2l0aChbXG4gICAgICBleHBlY3Qub2JqZWN0Q29udGFpbmluZyh7XG4gICAgICAgIGVuZF9kYXRlOiBkYXlqcyhldmVudFdpdGhvdXRFbmRUaW1lWm9uZS5lbmQuZGF0ZVRpbWUuc2xpY2UoMCwgMTkpKVxuICAgICAgICAgIC50eihldmVudFdpdGhvdXRFbmRUaW1lWm9uZS5zdGFydC50aW1lWm9uZSwgdHJ1ZSlcbiAgICAgICAgICAuZm9ybWF0KCksXG4gICAgICB9KSxcbiAgICBdKTtcbiAgfSk7XG59KTtcbiJdfQ==